SqlAttrDefList = SqlAttrDef ;
SqlAttrDefList = l::SqlAttrDefList COMMA a::SqlAttrDef ;
ABSGoal = CompilationUnit ;
Guard = DataExp ;
Guard = r::VarOrFieldRef QMARK ;
Guard = BAR e::Exp BAR ;
Guard = DURATION LPAREN min::DataExp COMMA max::DataExp RPAREN ;
Guard = g1::Guard GUARDAND g2::Guard ;
ModuleNameDecl = MODULE n::ModuleName SEMICOLON ;
DataConstructorList = DataConstructor ;
DataConstructorList = l::DataConstructorList BAR i::DataConstructor ;
Literal = IntLiteral ;
Literal = StringLiteral ;
AnnotationList = l::AnnotationList a::Annotation ;
AnnotationList = Annotation ;
DeclList = l::DeclList t::Decl ;
DeclList = Decl ;
BlockWithoutAnnotations = LBRACE s::StmtList? RBRACE ;
FeatureList = Feature ;
FeatureList = l::FeatureList COMMA f::Feature ;
Featvar = TYPE_IDENTIFIER ;
ExportList = Export ;
ExportList = l::ExportList t::Export ;
MlitExp = INTLITERAL ;
MlitExp = IDENTIFIER ;
MlitExp = f::TYPE_IDENTIFIER DOT a::IDENTIFIER ;
MlitExp = TYPE_IDENTIFIER ;
DatatypeparamListDecl = LT l::DatatypeparamList GT ;
ParamDecls = LPAREN f::ParamDeclList? RPAREN ;
SqlOrderingAttributes = ;
SqlOrderingAttributes = ORDER BY l::SqlOrderingAttributeList ;
StmtList = l::StmtList i::Stmt ;
StmtList = Stmt ;
FieldDecl = an::AnnotationList? PORT t::TypeExp i::IDENTIFIER ;
FieldDecl = an::AnnotationList? t::TypeExp i::IDENTIFIER ;
FieldDecl = an::AnnotationList? PORT t::TypeExp i::IDENTIFIER ASSIGN e::DataExp ;
FieldDecl = an::AnnotationList? t::TypeExp i::IDENTIFIER ASSIGN e::DataExp ;
EqualityExp = e1::EqualityExp EQEQ e2::RelationalExp ;
EqualityExp = RelationalExp ;
EqualityExp = e1::EqualityExp NOTEQ e2::RelationalExp ;
VarOrFieldRef = callee::THIS b::BANG method::IDENTIFIER? ;
VarOrFieldRef = IDENTIFIER ;
VarOrFieldRef = callee::THIS d::DOT ;
VarOrFieldRef = THIS DOT id::IDENTIFIER ;
Appcond = OrAppcond ;
FeatureDecl = TYPE_IDENTIFIER ;
FeatureDecl = f::TYPE_IDENTIFIER LBRACE g::Group? acl::AttributeConstraintList RBRACE ;
MfactorExp = MINUS e::MfactorExp ;
MfactorExp = MlitExp ;
MfactorExp = NEGATION e::MfactorExp ;
MfactorExp = LPAREN e::Mexp RPAREN ;
ImplementInterfacesRemove = REMOVES i::IfnameList ;
CaseExp = CASE caseterm::DataExp LBRACE branches::CaseBranchList? RBRACE ;
MultExp = e1::MultExp MULT e2::Factor ;
MultExp = e1::MultExp MOD e2::Factor ;
MultExp = Factor ;
MultExp = e1::MultExp DIV e2::Factor ;
Name = SimpleName ;
Name = QualifiedName ;
SqlAggregateFunction = COUNT LPAREN MULT RPAREN ;
SqlAggregateFunction = SqlTupleScalarFunction ;
SqlAggregateFunction = i::IDENTIFIER LPAREN f::SqlTupleScalarFunction RPAREN ;
IDENTIFIER = ;
ParamDecl = an::AnnotationList? t::TypeExp i::IDENTIFIER ;
Mexp = e1::Mexp OROR e2::MandExp ;
Mexp = MandExp ;
AfterCondition = AFTER l::DeltaList ;
Fextension = f::TYPE_IDENTIFIER LBRACE g::Group? acl::AttributeConstraintList RBRACE ;
SqlAttrDef = fun::SqlAggregateFunction AS e::DataExp ;
SqlAttrDef = Factor ;
FunctionDecl = al::AnnotationList? DEF t::Datatypeuse fn::IDENTIFIER p::DatatypeparamListDecl LPAREN l::ParamDeclList? RPAREN ASSIGN ef::ExpFunctionDef SEMICOLON ;
FunctionDecl = al::AnnotationList? DEF t::Datatypeuse fn::IDENTIFIER LPAREN l::ParamDeclList? RPAREN ASSIGN ef::ExpFunctionDef SEMICOLON ;
FunctionDecl = al::AnnotationList? DEF t::Datatypeuse fn::IDENTIFIER LPAREN l::ParamDeclList? RPAREN ASSIGN BUILTIN SEMICOLON ;
FunctionDecl = al::AnnotationList? DEF t::Datatypeuse fn::IDENTIFIER p::DatatypeparamListDecl LPAREN l::ParamDeclList? RPAREN ASSIGN BUILTIN SEMICOLON ;
ModuleModifierList = l::ModuleModifierList m::ModuleModifier ;
ModuleModifierList = ModuleModifier ;
DatatypeDecl = al::AnnotationList? DATA id::TYPE_IDENTIFIER p::DatatypeparamListDecl? SEMICOLON ;
DatatypeDecl = al::AnnotationList? DATA id::TYPE_IDENTIFIER p::DatatypeparamListDecl? ASSIGN l::DataConstructorList SEMICOLON ;
TYPE_IDENTIFIER = TYPE_IDENTIFIER_OLD ;
Product = PRODUCT id::TYPE_IDENTIFIER LPAREN l::FeatureList? RPAREN SEMICOLON ;
Product = PRODUCT id::TYPE_IDENTIFIER LPAREN l::FeatureList? RPAREN LBRACE al::AdaptationList RBRACE ;
Decl = DatatypeDecl ;
Decl = FunctionDecl ;
Decl = TypesynDecl ;
Decl = ClassDecl ;
Decl = InterfaceDecl ;
Feature = id::TYPE_IDENTIFIER PRIME attrs::AttrAssignments? ;
Feature = id::TYPE_IDENTIFIER attrs::AttrAssignments? ;
SimpleTypeName = TYPE_IDENTIFIER ;
PureExpPrefix = LPAREN e::IfExp RPAREN ;
PureExpPrefix = PureExpNoIf ;
DeltaId = TYPE_IDENTIFIER ;
CaseBranchList = l::CaseBranchList b::CaseBranch ;
CaseBranchList = CaseBranch ;
ExpFunctionDef = DataExp ;
AsyncCall = callee::PureExpPrefix BANG method::IDENTIFIER LPAREN params::DataExpList? RPAREN ;
AsyncCall = callee::THIS BANG method::IDENTIFIER LPAREN params::DataExpList? RPAREN ;
ConstructorArgList = l::ConstructorArgList COMMA a::ConstructorArg ;
ConstructorArgList = ConstructorArg ;
SqlOrderingAttributeList = l::SqlOrderingAttributeList COMMA a::SqlOrderingAttribute ;
SqlOrderingAttributeList = SqlOrderingAttribute ;
InfModifierFragmentList = l::InfModifierFragmentList f::InfModifierFragment ;
InfModifierFragmentList = InfModifierFragment ;
AndExp = e1::AndExp ANDAND e2::EqualityExp ;
AndExp = EqualityExp ;
WhenCondition = TO ac::Appcond ;
WhenCondition = WHEN ac::Appcond ;
MethodsigList = m::Methodsig SEMICOLON ;
MethodsigList = l::MethodsigList m::Methodsig SEMICOLON ;
SqlAttrAssignment = e::DataExp EQ f::SqlTupleScalarFunction ;
OoModifier = REMOVES CLASS id::TypeName SEMICOLON ;
OoModifier = MODIFIES INTERFACE id::TypeName LBRACE fragments::InfModifierFragmentList? RBRACE ;
OoModifier = ADDS ifacedecl::QualifiedInterfaceDecl ;
OoModifier = MODIFIES CLASS id::TypeName ifadd::ImplementInterfacesAdd? ifremove::ImplementInterfacesRemove? LBRACE fragments::ModifierFragmentList? RBRACE ;
OoModifier = ADDS classdecl::QualifiedClassDecl ;
MimplExp = MeqExp ;
MimplExp = e1::MimplExp IMPLIES e2::MeqExp ;
MimplExp = e1::MimplExp EQUIV e2::MeqExp ;
SqlTupleCaseBranches = l::SqlTupleCaseBranches b::SqlTupleCaseBranch ;
SqlTupleCaseBranches = SqlTupleCaseBranch ;
TypesynDecl = al::AnnotationList? TYPE lhs::TYPE_IDENTIFIER ASSIGN rhs::Datatypeuse SEMICOLON ;
IfnameList = l::IfnameList COMMA i::Ifname ;
IfnameList = Ifname ;
FnodeList = ;
FnodeList = l::FnodeList COMMA f::Fnode ;
FnodeList = Fnode ;
ImportList = Import ;
ImportList = l::ImportList t::Import ;
ProductList = Product ;
ProductList = l::ProductList p::Product ;
LocationExp = LOC LPAREN param::PureExp RPAREN ;
SqlAttrRefList = l::SqlAttrRefList COMMA a::SqlAttrRef ;
SqlAttrRefList = SqlAttrRef ;
DeltaParamDecl = ParamDecl ;
DeltaParamDecl = id::TYPE_IDENTIFIER c::HasCondition ;
ConstructorArg = Datatypeuse ;
ConstructorArg = u::Datatypeuse id::IDENTIFIER ;
FunctionalModifier = ADDS typesyndecl::TypesynDecl ;
FunctionalModifier = MODIFIES typesyndecl::TypesynDecl ;
FunctionalModifier = ADDS datatypedecl::DatatypeDecl ;
FunctionalModifier = ADDS functiondecl::FunctionDecl ;
FunctionalModifier = MODIFIES datatypedecl::DatatypeDecl ;
EffExp = AsyncCall ;
EffExp = NewlocExp '/'* Component* '/' ;
EffExp = NewExp ;
EffExp = IncompleteExp ;
EffExp = SyncCall ;
EffExp = SQL LPAREN e::SqlExp RPAREN ;
EffExp = OriginalCall ;
EffExp = p::PureExpPrefix DOT GET ;
FnappListExp = f::Name l::ListLiteralExp ;
LetExp = LET LPAREN var::ParamDecl RPAREN ASSIGN val::DataExp IN exp::DataExp ;
ClassDecl = annotations::AnnotationList? CLASS id::TYPE_IDENTIFIER params::ParamDecls? i::ImplementInterfaces? LBRACE fields::FieldDeclList? initBlock::InitBlock? methods::MethodList? RBRACE ;
DeltaDeclList = DeltaDecl ;
DeltaDeclList = l::DeltaDeclList t::DeltaDecl ;
PatternList = l::PatternList COMMA i::Pattern ;
PatternList = Pattern ;
SqlTupleScalarFunctionSum = f1::SqlTupleScalarFunctionSum MINUS f2::SqlTupleScalarFunctionProduct ;
SqlTupleScalarFunctionSum = f1::SqlTupleScalarFunctionSum PLUS f2::SqlTupleScalarFunctionProduct ;
SqlTupleScalarFunctionSum = f1::SqlTupleScalarFunctionSum MINUS LPAREN f2::SqlTupleScalarFunctionSum RPAREN ;
SqlTupleScalarFunctionSum = SqlTupleScalarFunctionProduct ;
InfModifierFragment = REMOVES ms::Methodsig SEMICOLON ;
InfModifierFragment = ADDS ms::Methodsig SEMICOLON ;
DeltaParamDecls = LPAREN f::DeltaParamDeclList? RPAREN ;
MainBlock = al::AnnotationList? LBRACE s::StmtList? RBRACE ;
DeltaparamList = l::DeltaparamList COMMA p::Deltaparam ;
DeltaparamList = Deltaparam ;
CompoundStmt = IfThenElseStmt ;
CompoundStmt = BlockWithoutAnnotations ;
CompoundStmt = WhileStmt ;
Methodsig = al::AnnotationList? returntype::TypeExp id::IDENTIFIER LPAREN params::ParamDeclList? RPAREN ;
SqlTupleConstantList = SqlTupleConstant ;
SqlTupleConstantList = l::SqlTupleConstantList COMMA c::SqlTupleConstant ;
NewlocExp = NEW LOC ;
DeltaclauseList = ;
DeltaclauseList = l::DeltaclauseList dc::DeltaClause SEMICOLON ;
PureExpNoIf = ConstructorExp ;
PureExpNoIf = NULL ;
PureExpNoIf = FnappExp ;
PureExpNoIf = CaseExp ;
PureExpNoIf = VarOrFieldRef ;
PureExpNoIf = THIS ;
PureExpNoIf = FnappListExp ;
PureExpNoIf = LetExp ;
DatatypeuseList = Datatypeuse ;
DatatypeuseList = l::DatatypeuseList COMMA i::Datatypeuse ;
OptfeatureList = OPTFEATURES l::FeatureList SEMICOLON ;
OptfeatureList = ;
ListLiteralExp = LBRACKET l::DataExpList? RBRACKET ;
MaddExp = e1::MaddExp MINUS e2::MmultExp ;
MaddExp = MmultExp ;
MaddExp = e1::MaddExp PLUS e2::MmultExp ;
DeltaList = l::DeltaList COMMA id::Delta ;
DeltaList = Delta ;
ConstructorPattern = co::TypeName p::PatternParams? ;
FactorAppcond = LPAREN ac::Appcond RPAREN ;
FactorAppcond = Feature ;
FactorAppcond = NEGATION ac::FactorAppcond ;
SqlStringLiteral = SQLSTRINGLITERAL ;
VarDecl = t::TypeExp i::IDENTIFIER ASSIGN e::Exp ;
VarDecl = t::TypeExp i::IDENTIFIER ;
Group = GROUP c::Cardinality LBRACE fs::FnodeList RBRACE ;
ModifierFragment = REMOVES f::FieldDecl SEMICOLON ;
ModifierFragment = MODIFIES m::Method ;
ModifierFragment = ADDS f::FieldDecl SEMICOLON ;
ModifierFragment = REMOVES ms::Methodsig SEMICOLON ;
ModifierFragment = ADDS m::Method ;
QualifiedInterfaceDecl = al::AnnotationList? INTERFACE id::TypeName i::ExtendsInterfaces? LBRACE l::MethodsigList? RBRACE ;
DeltaDecl = DELTA id::TYPE_IDENTIFIER params::DeltaParamDecls? SEMICOLON uses::DeltaAccessList? modifiers::ModuleModifierList? ;
TypeExp = TypeName ;
TypeExp = n::TypeName LT p::DatatypeuseList GT ;
Block = al::AnnotationList? b::BlockWithoutAnnotations ;
SqlRelationRef = r1::SqlRelationRef JOIN r2::SqlAtomicRelationRef ;
SqlRelationRef = r1::SqlRelationRef RIGHT JOIN r2::SqlAtomicRelationRef ;
SqlRelationRef = SqlAtomicRelationRef ;
SqlRelationRef = r1::SqlRelationRef LEFT JOIN r2::SqlAtomicRelationRef ;
AnyName = TypeName ;
AnyName = Name ;
AttrAssignments = LBRACE l::AttrAssignmentList RBRACE ;
FromCondition = FROM ac::Appcond ;
AdaptationList = l::AdaptationList ad::Adaptation ;
AdaptationList = Adaptation ;
SqlTupleConstant = IntLiteral ;
SqlTupleConstant = SqlStringLiteral ;
SqlTupleConstant = TRUE ;
SqlTupleConstant = MINUS i::IntLiteral ;
SqlTupleConstant = FALSE ;
SqlTupleConstant = VarOrFieldRef ;
NewExp = NEW c::Cog? i::TypeName LPAREN l::DataExpList? RPAREN ;
WhileStmt = WHILE LPAREN e1::DataExp RPAREN s1::Stmt ;
ModuleModifier = OoModifier ;
ModuleModifier = FunctionalModifier ;
QualifiedTypeName = qn::TypeName DOT n::TYPE_IDENTIFIER ;
SqlExp = INSERT INTO r::SqlRelationRef LPAREN a::SqlAttrRefList RPAREN VALUES LPAREN v::SqlTupleConstantList RPAREN ;
SqlExp = UPDATE r::SqlRelationRef SET a::SqlAttrAssignmentList c::OptSqlCondition ;
SqlExp = SELECT a::SqlAttrsDef FROM r::SqlRelationRef c::OptSqlCondition g::SqlGroupingAttributes o::SqlOrderingAttributes ;
SqlExp = SELECT DISTINCT a::SqlAttrsDef FROM r::SqlRelationRef c::OptSqlCondition g::SqlGroupingAttributes o::SqlOrderingAttributes ;
CorefeatureList = ;
CorefeatureList = COREFEATURES l::FeatureList SEMICOLON ;
Delta = TYPE_IDENTIFIER ;
ImplementInterfacesAdd = ADDS i::IfnameList ;
MeqExp = MrelExp ;
MeqExp = e1::MeqExp NOTEQ e2::MrelExp ;
MeqExp = e1::MeqExp EQEQ e2::MrelExp ;
ModifierFragmentList = ModifierFragment ;
ModifierFragmentList = l::ModifierFragmentList f::ModifierFragment ;
IfExp = IF e::DataExp THEN c::DataExp ELSE a::DataExp ;
SqlAttrAssignmentList = SqlAttrAssignment ;
SqlAttrAssignmentList = l::SqlAttrAssignmentList COMMA a::SqlAttrAssignment ;
AttributeConstraintList = acl::AttributeConstraintList t::TYPE_IDENTIFIER id::IDENTIFIER IN LBRACKET b1::BoundaryInt UNTIL b2::BoundaryInt RBRACKET SEMICOLON ;
AttributeConstraintList = acl::AttributeConstraintList t::TYPE_IDENTIFIER id::IDENTIFIER SEMICOLON '/'* Constraints* '/' ;
AttributeConstraintList = acl::AttributeConstraintList EXCLUDE COLON f::Featvar SEMICOLON ;
AttributeConstraintList = acl::AttributeConstraintList t::TYPE_IDENTIFIER id::IDENTIFIER IN LBRACE il::IntList RBRACE SEMICOLON ;
AttributeConstraintList = acl::AttributeConstraintList t::TYPE_IDENTIFIER LBRACKET b1::BoundaryInt UNTIL b2::BoundaryInt RBRACKET id::IDENTIFIER SEMICOLON ;
AttributeConstraintList = acl::AttributeConstraintList e::Mexp SEMICOLON ;
AttributeConstraintList = '/'* Attributes* '/' ;
AttributeConstraintList = acl::AttributeConstraintList REQUIRE COLON f::Featvar SEMICOLON ;
AttributeConstraintList = acl::AttributeConstraintList IFIN COLON e::Mexp SEMICOLON ;
AttributeConstraintList = acl::AttributeConstraintList IFOUT COLON e::Mexp SEMICOLON ;
AnyNameList = AnyName ;
AnyNameList = l::AnyNameList COMMA n::AnyName ;
ExtendsInterfaces = EXTENDS i::IfnameList ;
SqlAtomicRelationRef = StringLiteral ;
SqlAtomicRelationRef = VarOrFieldRef ;
AttrAssignment = n::IDENTIFIER ASSIGN i::INTLITERAL ;
AttrAssignment = n::IDENTIFIER ASSIGN c::TYPE_IDENTIFIER ;
IncompleteExp = callee::PureExpPrefix b::BANG method::IDENTIFIER? ;
IncompleteExp = callee::PureExpPrefix d::DOT method::IDENTIFIER? ;
IncompleteExp = NEW c::Cog? ;
ImplementInterfaces = IMPLEMENTS i::IfnameList ;
IfThenElseStmt = IF LPAREN e1::DataExp RPAREN s1::Stmt ELSE s2::Stmt ;
IfThenElseStmt = IF LPAREN e1::DataExp RPAREN s1::Stmt ;
SyncCall = callee::PureExpPrefix DOT method::IDENTIFIER LPAREN params::DataExpList? RPAREN ;
SyncCall = callee::THIS DOT method::IDENTIFIER LPAREN params::DataExpList? RPAREN ;
CompilationUnit = m::ModuleDeclList? d::DeltaDeclList? pl::ProductLine? p::ProductList? fm::Featuremodeldecl ;
Import = IMPORT l::AnyNameList FROM m::ModuleName SEMICOLON ;
Import = IMPORT l::AnyNameList SEMICOLON ;
Import = IMPORT MULT FROM m::ModuleName SEMICOLON ;
HasCondition = HASFIELD f::FieldDecl ;
HasCondition = HASMETHOD ms::Methodsig ;
HasCondition = HASINTERFACE n::TypeName ;
SqlTupleScalarFunctionQuotient = f1::SqlTupleScalarFunctionQuotient DIV LPAREN f2::SqlTupleScalarFunctionSum RPAREN ;
SqlTupleScalarFunctionQuotient = f1::SqlTupleScalarFunctionQuotient DIV f2::AtomicSqlTupleScalarFunction ;
SqlTupleScalarFunctionQuotient = AtomicSqlTupleScalarFunction ;
Export = EXPORT MULT SEMICOLON ;
Export = EXPORT l::AnyNameList SEMICOLON ;
Export = EXPORT MULT FROM m::ModuleName SEMICOLON ;
Export = EXPORT l::AnyNameList FROM m::ModuleName SEMICOLON ;
SqlAndCondition = c1::SqlAndCondition op::AND c2::SqlCondition ;
SqlAndCondition = SqlCondition ;
DataConstructor = co::TYPE_IDENTIFIER p::DataConstructorParams? ;
SqlTupleScalarFunctionProduct = f1::SqlTupleScalarFunctionProduct MULT f2::SqlTupleScalarFunctionQuotient ;
SqlTupleScalarFunctionProduct = SqlTupleScalarFunctionQuotient ;
SqlTupleScalarFunctionProduct = f1::SqlTupleScalarFunctionProduct MULT LPAREN f2::SqlTupleScalarFunctionSum RPAREN ;
SqlAttrsDef = MULT ;
SqlAttrsDef = SqlAttrDefList ;
AddExp = e1::AddExp PLUS e2::MultExp ;
AddExp = MultExp ;
AddExp = e1::AddExp MINUS e2::MultExp ;
DeltaAccessList = DeltaAccess ;
DeltaAccessList = l::DeltaAccessList t::DeltaAccess ;
PureExp = FatherExp '/'* Component* '/' ;
PureExp = LocationExp '/'* Component* '/' ;
PureExp = IfExp ;
PureExp = PureExpNoIf ;
ConstructorExp = TypeName ;
ConstructorExp = f::TypeName LPAREN l::DataExpList? RPAREN ;
INTLITERAL = ;
IntLiteral = INTLITERAL ;
MmultExp = e1::MmultExp MULT e2::MfactorExp ;
MmultExp = MfactorExp ;
MmultExp = e1::MmultExp DIV e2::MfactorExp ;
MmultExp = e1::MmultExp MOD e2::MfactorExp ;
OriginalCall = ORIGINAL LPAREN params::DataExpList? RPAREN ;
OriginalCall = delta::DeltaId DOTORIGINAL LPAREN params::DataExpList? RPAREN ;
OriginalCall = CORE DOTORIGINAL LPAREN params::DataExpList? RPAREN ;
SqlOrCondition = c1::SqlOrCondition op::OR c2::SqlAndCondition ;
SqlOrCondition = SqlAndCondition ;
Stmt = al::AnnotationList? s::CompoundStmt ;
Stmt = al::AnnotationList? s::StmtWithoutAnnotations SEMICOLON ;
Deltaparam = INTLITERAL ;
Deltaparam = TYPE_IDENTIFIER ;
Deltaparam = fid::TYPE_IDENTIFIER DOT aid::IDENTIFIER ;
ParamDeclList = l::ParamDeclList COMMA i::ParamDecl ;
ParamDeclList = ParamDecl ;
SqlTupleScalarFunctionConcat = f1::SqlTupleScalarFunctionConcat CONCAT f2::SqlTupleScalarFunctionSum ;
SqlTupleScalarFunctionConcat = SqlTupleScalarFunctionSum ;
DataExp = OrExp ;
Exp = DataExp ;
Exp = EffExp ;
TypeName = QualifiedTypeName ;
TypeName = SimpleTypeName ;
SqlTupleCaseFunction = CASE b::SqlTupleCaseBranches ELSE f::SqlTupleScalarFunction END ;
Datatypeuse = l::AnnotationList? n::TypeName LT p::DatatypeuseList GT ;
Datatypeuse = l::AnnotationList? n::TypeName ;
FatherExp = FATHER LPAREN param::PureExp RPAREN ;
Method = CRITICAL ms::Methodsig b::Block ;
Method = ms::Methodsig b::Block ;
AndAppcond = ac1::AndAppcond ANDAND ac2::FactorAppcond ;
AndAppcond = FactorAppcond ;
IntList = MINUS i::INTLITERAL ;
IntList = il::IntList COMMA MINUS i::INTLITERAL ;
IntList = il::IntList COMMA i::INTLITERAL ;
IntList = INTLITERAL ;
SqlCondition = NOT c::SqlCondition ;
SqlCondition = f1::SqlTupleScalarFunction r::SqlComparisonRelation f2::SqlTupleScalarFunction ;
SqlCondition = a::StringLiteral IS NULL ;
SqlCondition = LPAREN c::SqlOrCondition RPAREN ;
SqlGroupingAttributes = ;
SqlGroupingAttributes = GROUP BY a::SqlAttrRefList ;
Datatypeparam = TYPE_IDENTIFIER ;
PatternParams = LPAREN l::PatternList? RPAREN ;
ModuleDeclList = l::ModuleDeclList t::ModuleDecl ;
ModuleDeclList = ModuleDecl ;
CaseBranch = lhs::Pattern RARROW rhs::DataExp SEMICOLON ;
Deltaparams = LPAREN l::DeltaparamList RPAREN ;
DeltaAccess = USES m::ModuleName SEMICOLON ;
OrExp = AndExp ;
OrExp = e1::OrExp OROR e2::AndExp ;
SqlOrderingAttribute = e::DataExp DESC ;
SqlOrderingAttribute = DataExp ;
SqlOrderingAttribute = e::DataExp ASC ;
QualifiedClassDecl = annotations::AnnotationList? CLASS id::TypeName params::ParamDecls? i::ImplementInterfaces? LBRACE fields::FieldDeclList? initBlock::InitBlock? methods::MethodList? RBRACE ;
DeltaClause = DELTA d::Deltaspec a::AfterCondition? f::FromCondition? w::WhenCondition? ;
QualifiedName = qn::TypeName DOT n::IDENTIFIER ;
FnappExp = f::Name LPAREN l::DataExpList? RPAREN ;
OptSqlCondition = WHERE c::SqlOrCondition ;
OptSqlCondition = ;
LAYOUT = Comment ;
LAYOUT = ;
ModuleName = TypeName ;
Adaptation = product::TYPE_IDENTIFIER BY update::TYPE_IDENTIFIER SEMICOLON ;
DataExpList = l::DataExpList COMMA i::DataExp ;
DataExpList = DataExp ;
StringLiteral = STRINGLITERAL ;
SqlTupleScalarFunction = SqlTupleScalarFunctionConcat ;
MethodList = l::MethodList i::Method ;
MethodList = Method ;
Featuremodeldecl = l::Featuremodeldecl EXTENSION ext::Fextension ;
Featuremodeldecl = l::Featuremodeldecl ROOT f::FeatureDecl ;
Featuremodeldecl = ;
InitBlock = Block ;
DatatypeparamList = l::DatatypeparamList COMMA p::Datatypeparam ;
DatatypeparamList = Datatypeparam ;
StmtWithoutAnnotations = REBIND field::IDENTIFIER ASSIGN e::Exp ;
StmtWithoutAnnotations = r::VarOrFieldRef ASSIGN e::Exp ;
StmtWithoutAnnotations = SKIP ;
StmtWithoutAnnotations = REBIND obj::Exp COLON field::IDENTIFIER ASSIGN e::Exp ;
StmtWithoutAnnotations = EffExp ;
StmtWithoutAnnotations = VarDecl ;
StmtWithoutAnnotations = DURATION LPAREN min::DataExp COMMA max::DataExp RPAREN ;
StmtWithoutAnnotations = SUBLOC sub::PureExp IN father::PureExp ;
StmtWithoutAnnotations = ASSERT e::DataExp ;
StmtWithoutAnnotations = AWAIT Guard ;
StmtWithoutAnnotations = SUSPEND ;
StmtWithoutAnnotations = RETURN e::Exp ;
StmtWithoutAnnotations = MOVECOGTO DataExp ;
BoundaryInt = INTLITERAL ;
BoundaryInt = MULT ;
BoundaryInt = MINUS i::INTLITERAL ;
OrAppcond = ac1::OrAppcond OROR ac2::AndAppcond ;
OrAppcond = AndAppcond ;
Annotation = LBRACKET type::TypeExp COLON exp::DataExp RBRACKET ;
Annotation = LBRACKET exp::DataExp RBRACKET ;
SqlTupleCaseBranch = WHEN c::SqlOrCondition THEN f::SqlTupleScalarFunction ;
Ifname = TypeName ;
Fnode = OPT f::FeatureDecl ;
Fnode = FeatureDecl ;
AtomicSqlTupleScalarFunction = StringLiteral ;
AtomicSqlTupleScalarFunction = SqlTupleConstant ;
AtomicSqlTupleScalarFunction = SqlTupleCaseFunction ;
RelationalExp = e1::RelationalExp LTEQ e2::AddExp ;
RelationalExp = AddExp ;
RelationalExp = e1::RelationalExp LT e2::AddExp ;
RelationalExp = e1::RelationalExp GT e2::AddExp ;
RelationalExp = e1::RelationalExp GTEQ e2::AddExp ;
ModuleDecl = n::ModuleNameDecl el::ExportList? il::ImportList? dl::DeclList? b::MainBlock? ;
SqlAttrRef = DataExp ;
MandExp = MimplExp ;
MandExp = e1::MandExp ANDAND e2::MimplExp ;
Deltaspec = id::TYPE_IDENTIFIER params::Deltaparams? ;
MrelExp = e1::MrelExp GTEQ e2::MaddExp ;
MrelExp = e1::MrelExp GT e2::MaddExp ;
MrelExp = e1::MrelExp LT e2::MaddExp ;
MrelExp = MaddExp ;
MrelExp = e1::MrelExp LTEQ e2::MaddExp ;
DeltaParamDeclList = DeltaParamDecl ;
DeltaParamDeclList = l::DeltaParamDeclList COMMA i::DeltaParamDecl ;
Cog = annotations::AnnotationList? COG ;
FieldDeclList = i::FieldDecl SEMICOLON ;
FieldDeclList = l::FieldDeclList i::FieldDecl SEMICOLON ;
ProductLine = PRODUCTLINE id::TYPE_IDENTIFIER SEMICOLON o::OptfeatureList c::CorefeatureList d::DeltaclauseList ;
InterfaceDecl = al::AnnotationList? INTERFACE id::TYPE_IDENTIFIER i::ExtendsInterfaces? LBRACE l::MethodsigList? RBRACE ;
Cardinality = ONEOF ;
Cardinality = LBRACKET i1::INTLITERAL UNTIL i2::INTLITERAL RBRACKET ;
Cardinality = ALLOF ;
Cardinality = LBRACKET i::INTLITERAL UNTIL MULT RBRACKET ;
Factor = NEGATION b::Factor ;
Factor = MINUS e::Factor ;
Factor = Literal ;
Factor = PureExp ;
Factor = LPAREN e::OrExp RPAREN ;
DataConstructorParams = LPAREN l::ConstructorArgList? RPAREN ;
SqlComparisonRelation = LT ;
SqlComparisonRelation = LTEQ ;
SqlComparisonRelation = GTEQ ;
SqlComparisonRelation = NOTEQ ;
SqlComparisonRelation = EQ ;
SqlComparisonRelation = GT ;
Pattern = USCORE ;
Pattern = Literal ;
Pattern = IDENTIFIER ;
Pattern = ConstructorPattern ;
AttrAssignmentList = AttrAssignment ;
AttrAssignmentList = l::AttrAssignmentList COMMA a::AttrAssignment ;
SimpleName = IDENTIFIER ;
