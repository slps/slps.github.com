module Main

exports
  sorts
        SqlAttrDefList ABSGoal Guard PORT ModuleNameDecl DataConstructorList Literal AnnotationList DeclList BlockWithoutAnnotations IMPLIES FeatureList Featvar ExportList MlitExp OPT DatatypeparamListDecl DESC SEMICOLON QMARK THIS NOTEQ ParamDecls ONEOF SqlOrderingAttributes StmtList FieldDecl EqualityExp VarOrFieldRef Appcond HASFIELD ANDAND FeatureDecl ImplementInterfacesRemove MfactorExp EQ CaseExp MultExp Name SqlAggregateFunction IDENTIFIER ParamDecl COMMA NOT Mexp AfterCondition LBRACKET END Fextension INSERT SqlAttrDef WHERE FunctionDecl ModuleModifierList DatatypeDecl TYPE-IDENTIFIER PRODUCT Product Decl UPDATE Feature RARROW PureExpPrefix SimpleTypeName DeltaId CaseBranchList ExpFunctionDef AsyncCall ConstructorArgList SqlOrderingAttributeList MODIFIES InfModifierFragmentList AndExp MOD ROOT WhenCondition MethodsigList COUNT ASSIGN SqlAttrAssignment GT OoModifier MimplExp REBIND IFOUT SELECT DISTINCT SqlTupleCaseBranches TypesynDecl IfnameList FnodeList LEFT YYINITIAL BUILTIN ImportList ProductList LocationExp EQUIV SqlAttrRefList LPAREN EXTENSION DeltaParamDecl ConstructorArg SUSPEND THEN FunctionalModifier EffExp FnappListExp LetExp ClassDecl DeltaDeclList PatternList SqlTupleScalarFunctionSum InfModifierFragment DeltaParamDecls LTEQ MainBlock AS CompoundStmt DeltaparamList Methodsig SqlTupleConstantList NewlocExp BANG DeltaclauseList SET PureExpNoIf OptfeatureList DatatypeuseList REMOVES ListLiteralExp MaddExp DeltaList ConstructorPattern BY FactorAppcond SqlStringLiteral MINUS ASC VarDecl Group GROUP PRIME EQEQ GTEQ ModifierFragment QualifiedInterfaceDecl DeltaDecl TypeExp INTO MODULE Block SqlRelationRef AnyName AttrAssignments DIV FromCondition AdaptationList SqlTupleConstant NewExp EXTENDS WhileStmt NULL ModuleModifier NEW QualifiedTypeName TRUE SqlExp LT DURATION CorefeatureList CORE CRITICAL PLUS Delta DELTA ImplementInterfacesAdd MeqExp IMPORT ModifierFragmentList IfExp SQL FROM SqlAttrAssignmentList DATA AttributeConstraintList AND EXPORT AnyNameList ExtendsInterfaces IMPLEMENTS SqlAtomicRelationRef AttrAssignment IncompleteExp AFTER ImplementInterfaces EXCLUDE IfThenElseStmt SyncCall CompilationUnit Import HasCondition USES SqlTupleScalarFunctionQuotient Export SqlAndCondition OPTFEATURES DataConstructor ORIGINAL SqlTupleScalarFunctionProduct SqlAttrsDef HASINTERFACE AddExp DeltaAccessList HASMETHOD RPAREN MOVECOGTO PureExp DEF OR ConstructorExp INTLITERAL IntLiteral MmultExp OriginalCall SqlOrCondition Stmt RBRACKET ParamDeclList Deltaparam ADDS SqlTupleScalarFunctionConcat BAR DataExp RIGHT Exp DOTORIGINAL LET OROR TypeName IFIN SqlTupleCaseFunction FALSE Datatypeuse SUBLOC FatherExp RBRACE Method AndAppcond IntList SqlCondition SqlGroupingAttributes Datatypeparam PatternParams ModuleDeclList CONCAT CaseBranch GUARDAND WHILE Deltaparams DeltaAccess IF OrExp SqlOrderingAttribute ALLOF INTERFACE QualifiedClassDecl DeltaClause QualifiedName FnappExp IN VALUES OptSqlCondition LOC ORDER IS JOIN LAYOUT DOT GET AWAIT ModuleName Adaptation MULT CASE RETURN DataExpList UNTIL StringLiteral SqlTupleScalarFunction COLON MethodList USCORE Featuremodeldecl InitBlock TYPE WHEN ELSE ASSERT LBRACE DatatypeparamList StmtWithoutAnnotations REQUIRE BoundaryInt PRODUCTLINE OrAppcond Annotation SqlTupleCaseBranch Ifname Fnode AtomicSqlTupleScalarFunction RelationalExp ModuleDecl SqlAttrRef MandExp Deltaspec MrelExp FATHER DeltaParamDeclList COG Cog CLASS NEGATION FieldDeclList ProductLine InterfaceDecl Cardinality Factor DataConstructorParams SqlComparisonRelation Pattern SKIP AttrAssignmentList SimpleName 
  context-free syntax
        l::SqlAttrDefList COMMA a::SqlAttrDef -> SqlAttrDefList

        SqlAttrDef -> SqlAttrDefList {cons(a)}

        CompilationUnit -> ABSGoal {cons(cu)}

        r::VarOrFieldRef QMARK -> Guard

        DataExp -> Guard {cons(e)}

        g1::Guard GUARDAND g2::Guard -> Guard

        BAR e::Exp BAR -> Guard

        DURATION LPAREN min::DataExp COMMA max::DataExp RPAREN -> Guard

        "port" -> PORT

        MODULE n::ModuleName SEMICOLON -> ModuleNameDecl

        l::DataConstructorList BAR i::DataConstructor -> DataConstructorList

        DataConstructor -> DataConstructorList {cons(i)}

        IntLiteral -> Literal {cons(i)}

        StringLiteral -> Literal {cons(s)}

        l::AnnotationList a::Annotation -> AnnotationList

        Annotation -> AnnotationList {cons(a)}

        l::DeclList t::Decl -> DeclList

        Decl -> DeclList {cons(t)}

        LBRACE RBRACE -> BlockWithoutAnnotations

        "->" -> IMPLIES

        l::FeatureList COMMA f::Feature -> FeatureList

        Feature -> FeatureList {cons(f)}

        TYPE-IDENTIFIER -> Featvar {cons(f)}

        Export -> ExportList {cons(t)}

        l::ExportList t::Export -> ExportList

        INTLITERAL -> MlitExp {cons(i)}

        IDENTIFIER -> MlitExp {cons(id)}

        f::TYPE-IDENTIFIER DOT a::IDENTIFIER -> MlitExp

        TYPE-IDENTIFIER -> MlitExp {cons(id)}

        "opt" -> OPT

        LT l::DatatypeparamList GT -> DatatypeparamListDecl

        "desc" -> DESC

        ";" -> SEMICOLON

        "?" -> QMARK

        "this" -> THIS

        "!=" -> NOTEQ

        "<>" -> NOTEQ

        LPAREN RPAREN -> ParamDecls

        "oneof" -> ONEOF

        ORDER BY l::SqlOrderingAttributeList -> SqlOrderingAttributes

         -> SqlOrderingAttributes

        l::StmtList i::Stmt -> StmtList

        Stmt -> StmtList {cons(i)}

        PORT t::TypeExp i::IDENTIFIER -> FieldDecl

        PORT t::TypeExp i::IDENTIFIER ASSIGN e::DataExp -> FieldDecl

        t::TypeExp i::IDENTIFIER ASSIGN e::DataExp -> FieldDecl

        t::TypeExp i::IDENTIFIER -> FieldDecl

        e1::EqualityExp NOTEQ e2::RelationalExp -> EqualityExp

        RelationalExp -> EqualityExp

        e1::EqualityExp EQEQ e2::RelationalExp -> EqualityExp

        callee::THIS d::DOT -> VarOrFieldRef

        callee::THIS b::BANG -> VarOrFieldRef

        THIS DOT id::IDENTIFIER -> VarOrFieldRef

        IDENTIFIER -> VarOrFieldRef {cons(n)}

        OrAppcond -> Appcond

        "hasField" -> HASFIELD

        "&&" -> ANDAND

        TYPE-IDENTIFIER -> FeatureDecl {cons(f)}

        f::TYPE-IDENTIFIER LBRACE acl::AttributeConstraintList RBRACE -> FeatureDecl

        REMOVES i::IfnameList -> ImplementInterfacesRemove

        NEGATION e::MfactorExp -> MfactorExp

        MINUS e::MfactorExp -> MfactorExp

        MlitExp -> MfactorExp

        LPAREN e::Mexp RPAREN -> MfactorExp

        "=" -> EQ

        CASE caseterm::DataExp LBRACE RBRACE -> CaseExp

        e1::MultExp MOD e2::Factor -> MultExp

        e1::MultExp DIV e2::Factor -> MultExp

        Factor -> MultExp {cons(f)}

        e1::MultExp MULT e2::Factor -> MultExp

        SimpleName -> Name

        QualifiedName -> Name

        i::IDENTIFIER LPAREN f::SqlTupleScalarFunction RPAREN -> SqlAggregateFunction

        SqlTupleScalarFunction -> SqlAggregateFunction {cons(f)}

        COUNT LPAREN MULT RPAREN -> SqlAggregateFunction

         -> IDENTIFIER

        t::TypeExp i::IDENTIFIER -> ParamDecl

        "," -> COMMA

        "not" -> NOT

        MandExp -> Mexp

        e1::Mexp OROR e2::MandExp -> Mexp

        AFTER l::DeltaList -> AfterCondition

        "[" -> LBRACKET

        "end" -> END

        f::TYPE-IDENTIFIER LBRACE acl::AttributeConstraintList RBRACE -> Fextension

        "insert" -> INSERT

        Factor -> SqlAttrDef {cons(f)}

        fun::SqlAggregateFunction AS e::DataExp -> SqlAttrDef

        "where" -> WHERE

        DEF t::Datatypeuse fn::IDENTIFIER p::DatatypeparamListDecl LPAREN RPAREN ASSIGN ef::ExpFunctionDef SEMICOLON -> FunctionDecl

        DEF t::Datatypeuse fn::IDENTIFIER LPAREN RPAREN ASSIGN ef::ExpFunctionDef SEMICOLON -> FunctionDecl

        DEF t::Datatypeuse fn::IDENTIFIER p::DatatypeparamListDecl LPAREN RPAREN ASSIGN BUILTIN SEMICOLON -> FunctionDecl

        DEF t::Datatypeuse fn::IDENTIFIER LPAREN RPAREN ASSIGN BUILTIN SEMICOLON -> FunctionDecl

        l::ModuleModifierList m::ModuleModifier -> ModuleModifierList

        ModuleModifier -> ModuleModifierList {cons(m)}

        DATA id::TYPE-IDENTIFIER ASSIGN l::DataConstructorList SEMICOLON -> DatatypeDecl

        DATA id::TYPE-IDENTIFIER SEMICOLON -> DatatypeDecl

        TYPE-IDENTIFIER-OLD -> TYPE-IDENTIFIER

        "product" -> PRODUCT

        PRODUCT id::TYPE-IDENTIFIER LPAREN RPAREN SEMICOLON -> Product

        PRODUCT id::TYPE-IDENTIFIER LPAREN RPAREN LBRACE al::AdaptationList RBRACE -> Product

        DatatypeDecl -> Decl

        FunctionDecl -> Decl

        TypesynDecl -> Decl

        ClassDecl -> Decl

        InterfaceDecl -> Decl

        "update" -> UPDATE

        id::TYPE-IDENTIFIER -> Feature

        id::TYPE-IDENTIFIER PRIME -> Feature

        "=>" -> RARROW

        LPAREN e::IfExp RPAREN -> PureExpPrefix

        PureExpNoIf -> PureExpPrefix

        TYPE-IDENTIFIER -> SimpleTypeName {cons(id)}

        TYPE-IDENTIFIER -> DeltaId {cons(delta)}

        l::CaseBranchList b::CaseBranch -> CaseBranchList

        CaseBranch -> CaseBranchList {cons(b)}

        DataExp -> ExpFunctionDef {cons(ef)}

        callee::THIS BANG method::IDENTIFIER LPAREN RPAREN -> AsyncCall

        callee::PureExpPrefix BANG method::IDENTIFIER LPAREN RPAREN -> AsyncCall

        ConstructorArg -> ConstructorArgList {cons(a)}

        l::ConstructorArgList COMMA a::ConstructorArg -> ConstructorArgList

        SqlOrderingAttribute -> SqlOrderingAttributeList {cons(a)}

        l::SqlOrderingAttributeList COMMA a::SqlOrderingAttribute -> SqlOrderingAttributeList

        "modifies" -> MODIFIES

        l::InfModifierFragmentList f::InfModifierFragment -> InfModifierFragmentList

        InfModifierFragment -> InfModifierFragmentList {cons(f)}

        e1::AndExp ANDAND e2::EqualityExp -> AndExp

        EqualityExp -> AndExp

        "%" -> MOD

        "root" -> ROOT

        WHEN ac::Appcond -> WhenCondition

        TO ac::Appcond -> WhenCondition

        m::Methodsig SEMICOLON -> MethodsigList

        l::MethodsigList m::Methodsig SEMICOLON -> MethodsigList

        "count" -> COUNT

        "=" -> ASSIGN

        e::DataExp EQ f::SqlTupleScalarFunction -> SqlAttrAssignment

        ">" -> GT

        ADDS classdecl::QualifiedClassDecl -> OoModifier

        REMOVES CLASS id::TypeName SEMICOLON -> OoModifier

        MODIFIES INTERFACE id::TypeName LBRACE RBRACE -> OoModifier

        ADDS ifacedecl::QualifiedInterfaceDecl -> OoModifier

        MODIFIES CLASS id::TypeName LBRACE RBRACE -> OoModifier

        MeqExp -> MimplExp

        e1::MimplExp EQUIV e2::MeqExp -> MimplExp

        e1::MimplExp IMPLIES e2::MeqExp -> MimplExp

        "rebind" -> REBIND

        "ifout" -> IFOUT

        "select" -> SELECT

        "distinct" -> DISTINCT

        l::SqlTupleCaseBranches b::SqlTupleCaseBranch -> SqlTupleCaseBranches

        SqlTupleCaseBranch -> SqlTupleCaseBranches {cons(b)}

        TYPE lhs::TYPE-IDENTIFIER ASSIGN rhs::Datatypeuse SEMICOLON -> TypesynDecl

        l::IfnameList COMMA i::Ifname -> IfnameList

        Ifname -> IfnameList {cons(i)}

        l::FnodeList COMMA f::Fnode -> FnodeList

         -> FnodeList

        Fnode -> FnodeList {cons(f)}

        "left" -> LEFT

        "after" -> YYINITIAL

        "exclude" -> YYINITIAL

        "sql" -> YYINITIAL

        "null" -> YYINITIAL

        "duration" -> YYINITIAL

        "father" -> YYINITIAL

        "skip" -> YYINITIAL

        "productline" -> YYINITIAL

        "if" -> YYINITIAL

        "interface" -> YYINITIAL

        "return" -> YYINITIAL

        "else" -> YYINITIAL

        "in" -> YYINITIAL

        "product" -> YYINITIAL

        "extends" -> YYINITIAL

        "by" -> YYINITIAL

        "def" -> YYINITIAL

        "hasMethod" -> YYINITIAL

        "movecogto" -> YYINITIAL

        "features" -> YYINITIAL

        "builtin" -> YYINITIAL

        "extension" -> YYINITIAL

        "core" -> YYINITIAL

        "critical" -> YYINITIAL

        "hasInterface" -> YYINITIAL

        "implements" -> YYINITIAL

        "data" -> YYINITIAL

        "from" -> YYINITIAL

        "location" -> YYINITIAL

        "get" -> YYINITIAL

        "ifin" -> YYINITIAL

        "type" -> YYINITIAL

        "hasField" -> YYINITIAL

        "this" -> YYINITIAL

        "opt" -> YYINITIAL

        "module" -> YYINITIAL

        "group" -> YYINITIAL

        "then" -> YYINITIAL

        "original" -> YYINITIAL

        "new" -> YYINITIAL

        "await" -> YYINITIAL

        "class" -> YYINITIAL

        "cog" -> YYINITIAL

        "require" -> YYINITIAL

        "ifout" -> YYINITIAL

        "root" -> YYINITIAL

        "rebind" -> YYINITIAL

        "port" -> YYINITIAL

        "removes" -> YYINITIAL

        "suspend" -> YYINITIAL

        "uses" -> YYINITIAL

        "move" -> YYINITIAL

        "adds" -> YYINITIAL

        ".original" -> YYINITIAL

        "import" -> YYINITIAL

        "export" -> YYINITIAL

        "delta" -> YYINITIAL

        "assert" -> YYINITIAL

        "when" -> YYINITIAL

        "while" -> YYINITIAL

        "case" -> YYINITIAL

        "allof" -> YYINITIAL

        "modifies" -> YYINITIAL

        "oneof" -> YYINITIAL

        "let" -> YYINITIAL

        "builtin" -> BUILTIN

        Import -> ImportList {cons(t)}

        l::ImportList t::Import -> ImportList

        Product -> ProductList {cons(p)}

        l::ProductList p::Product -> ProductList

        LOC LPAREN param::PureExp RPAREN -> LocationExp

        "<->" -> EQUIV

        l::SqlAttrRefList COMMA a::SqlAttrRef -> SqlAttrRefList

        SqlAttrRef -> SqlAttrRefList {cons(a)}

        "(" -> LPAREN

        "extension" -> EXTENSION

        ParamDecl -> DeltaParamDecl {cons(p)}

        id::TYPE-IDENTIFIER c::HasCondition -> DeltaParamDecl

        Datatypeuse -> ConstructorArg {cons(u)}

        u::Datatypeuse id::IDENTIFIER -> ConstructorArg

        "suspend" -> SUSPEND

        "then" -> THEN

        MODIFIES datatypedecl::DatatypeDecl -> FunctionalModifier

        ADDS functiondecl::FunctionDecl -> FunctionalModifier

        ADDS datatypedecl::DatatypeDecl -> FunctionalModifier

        MODIFIES typesyndecl::TypesynDecl -> FunctionalModifier

        ADDS typesyndecl::TypesynDecl -> FunctionalModifier

        AsyncCall -> EffExp

        NewlocExp "/" -> EffExp

        p::PureExpPrefix DOT GET -> EffExp

        NewExp -> EffExp

        SyncCall -> EffExp

        IncompleteExp -> EffExp

        SQL LPAREN e::SqlExp RPAREN -> EffExp

        OriginalCall -> EffExp

        f::Name l::ListLiteralExp -> FnappListExp

        LET LPAREN var::ParamDecl RPAREN ASSIGN val::DataExp IN exp::DataExp -> LetExp

        CLASS id::TYPE-IDENTIFIER LBRACE RBRACE -> ClassDecl

        DeltaDecl -> DeltaDeclList {cons(t)}

        l::DeltaDeclList t::DeltaDecl -> DeltaDeclList

        Pattern -> PatternList {cons(i)}

        l::PatternList COMMA i::Pattern -> PatternList

        f1::SqlTupleScalarFunctionSum PLUS f2::SqlTupleScalarFunctionProduct -> SqlTupleScalarFunctionSum

        f1::SqlTupleScalarFunctionSum MINUS f2::SqlTupleScalarFunctionProduct -> SqlTupleScalarFunctionSum

        SqlTupleScalarFunctionProduct -> SqlTupleScalarFunctionSum

        f1::SqlTupleScalarFunctionSum MINUS LPAREN f2::SqlTupleScalarFunctionSum RPAREN -> SqlTupleScalarFunctionSum

        REMOVES ms::Methodsig SEMICOLON -> InfModifierFragment

        ADDS ms::Methodsig SEMICOLON -> InfModifierFragment

        LPAREN RPAREN -> DeltaParamDecls

        "<=" -> LTEQ

        LBRACE RBRACE -> MainBlock

        "as" -> AS

        IfThenElseStmt -> CompoundStmt

        BlockWithoutAnnotations -> CompoundStmt

        WhileStmt -> CompoundStmt

        l::DeltaparamList COMMA p::Deltaparam -> DeltaparamList

        Deltaparam -> DeltaparamList {cons(p)}

        returntype::TypeExp id::IDENTIFIER LPAREN RPAREN -> Methodsig

        l::SqlTupleConstantList COMMA c::SqlTupleConstant -> SqlTupleConstantList

        SqlTupleConstant -> SqlTupleConstantList {cons(c)}

        NEW LOC -> NewlocExp

        "!" -> BANG

        l::DeltaclauseList dc::DeltaClause SEMICOLON -> DeltaclauseList

         -> DeltaclauseList

        "set" -> SET

        ConstructorExp -> PureExpNoIf

        NULL -> PureExpNoIf

        FnappExp -> PureExpNoIf

        VarOrFieldRef -> PureExpNoIf

        CaseExp -> PureExpNoIf

        THIS -> PureExpNoIf

        LetExp -> PureExpNoIf

        FnappListExp -> PureExpNoIf

        OPTFEATURES l::FeatureList SEMICOLON -> OptfeatureList

         -> OptfeatureList

        l::DatatypeuseList COMMA i::Datatypeuse -> DatatypeuseList

        Datatypeuse -> DatatypeuseList {cons(i)}

        "removes" -> REMOVES

        LBRACKET RBRACKET -> ListLiteralExp

        e1::MaddExp PLUS e2::MmultExp -> MaddExp

        MmultExp -> MaddExp {cons(e)}

        e1::MaddExp MINUS e2::MmultExp -> MaddExp

        Delta -> DeltaList {cons(id)}

        l::DeltaList COMMA id::Delta -> DeltaList

        co::TypeName -> ConstructorPattern

        "by" -> BY

        NEGATION ac::FactorAppcond -> FactorAppcond

        LPAREN ac::Appcond RPAREN -> FactorAppcond

        Feature -> FactorAppcond {cons(f)}

        SQLSTRINGLITERAL -> SqlStringLiteral {cons(s)}

        "-" -> MINUS

        "asc" -> ASC

        t::TypeExp i::IDENTIFIER ASSIGN e::Exp -> VarDecl

        t::TypeExp i::IDENTIFIER -> VarDecl

        GROUP c::Cardinality LBRACE fs::FnodeList RBRACE -> Group

        "group" -> GROUP

        "'" -> PRIME

        "==" -> EQEQ

        ">=" -> GTEQ

        ADDS m::Method -> ModifierFragment

        REMOVES f::FieldDecl SEMICOLON -> ModifierFragment

        MODIFIES m::Method -> ModifierFragment

        ADDS f::FieldDecl SEMICOLON -> ModifierFragment

        REMOVES ms::Methodsig SEMICOLON -> ModifierFragment

        INTERFACE id::TypeName LBRACE RBRACE -> QualifiedInterfaceDecl

        DELTA id::TYPE-IDENTIFIER SEMICOLON -> DeltaDecl

        TypeName -> TypeExp {cons(n)}

        n::TypeName LT p::DatatypeuseList GT -> TypeExp

        "into" -> INTO

        "module" -> MODULE

        b::BlockWithoutAnnotations -> Block

        r1::SqlRelationRef LEFT JOIN r2::SqlAtomicRelationRef -> SqlRelationRef

        SqlAtomicRelationRef -> SqlRelationRef

        r1::SqlRelationRef RIGHT JOIN r2::SqlAtomicRelationRef -> SqlRelationRef

        r1::SqlRelationRef JOIN r2::SqlAtomicRelationRef -> SqlRelationRef

        TypeName -> AnyName

        Name -> AnyName

        LBRACE l::AttrAssignmentList RBRACE -> AttrAssignments

        "/" -> DIV

        FROM ac::Appcond -> FromCondition

        l::AdaptationList ad::Adaptation -> AdaptationList

        Adaptation -> AdaptationList {cons(ad)}

        MINUS i::IntLiteral -> SqlTupleConstant

        IntLiteral -> SqlTupleConstant {cons(i)}

        SqlStringLiteral -> SqlTupleConstant {cons(s)}

        FALSE -> SqlTupleConstant

        TRUE -> SqlTupleConstant

        VarOrFieldRef -> SqlTupleConstant {cons(r)}

        NEW i::TypeName LPAREN RPAREN -> NewExp

        "extends" -> EXTENDS

        WHILE LPAREN e1::DataExp RPAREN s1::Stmt -> WhileStmt

        "null" -> NULL

        OoModifier -> ModuleModifier {cons(m)}

        FunctionalModifier -> ModuleModifier {cons(m)}

        "new" -> NEW

        qn::TypeName DOT n::TYPE-IDENTIFIER -> QualifiedTypeName

        "true" -> TRUE

        INSERT INTO r::SqlRelationRef LPAREN a::SqlAttrRefList RPAREN VALUES LPAREN v::SqlTupleConstantList RPAREN -> SqlExp

        UPDATE r::SqlRelationRef SET a::SqlAttrAssignmentList c::OptSqlCondition -> SqlExp

        SELECT DISTINCT a::SqlAttrsDef FROM r::SqlRelationRef c::OptSqlCondition g::SqlGroupingAttributes o::SqlOrderingAttributes -> SqlExp

        SELECT a::SqlAttrsDef FROM r::SqlRelationRef c::OptSqlCondition g::SqlGroupingAttributes o::SqlOrderingAttributes -> SqlExp

        "<" -> LT

        "duration" -> DURATION

         -> CorefeatureList

        COREFEATURES l::FeatureList SEMICOLON -> CorefeatureList

        "core" -> CORE

        "critical" -> CRITICAL

        "+" -> PLUS

        TYPE-IDENTIFIER -> Delta {cons(id)}

        "delta" -> DELTA

        ADDS i::IfnameList -> ImplementInterfacesAdd

        e1::MeqExp EQEQ e2::MrelExp -> MeqExp

        MrelExp -> MeqExp

        e1::MeqExp NOTEQ e2::MrelExp -> MeqExp

        "import" -> IMPORT

        ModifierFragment -> ModifierFragmentList {cons(f)}

        l::ModifierFragmentList f::ModifierFragment -> ModifierFragmentList

        IF e::DataExp THEN c::DataExp ELSE a::DataExp -> IfExp

        "update" -> SQL

        "end" -> SQL

        "select" -> SQL

        "where" -> SQL

        "left" -> SQL

        "as" -> SQL

        "by" -> SQL

        "set" -> SQL

        "true" -> SQL

        "null" -> SQL

        "and" -> SQL

        "sql" -> SQL

        "or" -> SQL

        "count" -> SQL

        "join" -> SQL

        "values" -> SQL

        "false" -> SQL

        "is" -> SQL

        "else" -> SQL

        "desc" -> SQL

        "insert" -> SQL

        "not" -> SQL

        "distinct" -> SQL

        "right" -> SQL

        "then" -> SQL

        "group" -> SQL

        "asc" -> SQL

        "into" -> SQL

        "from" -> SQL

        "case" -> SQL

        "when" -> SQL

        "order" -> SQL

        "from" -> FROM

        SqlAttrAssignment -> SqlAttrAssignmentList {cons(a)}

        l::SqlAttrAssignmentList COMMA a::SqlAttrAssignment -> SqlAttrAssignmentList

        "data" -> DATA

        acl::AttributeConstraintList t::TYPE-IDENTIFIER id::IDENTIFIER SEMICOLON "/" -> AttributeConstraintList

        acl::AttributeConstraintList EXCLUDE COLON f::Featvar SEMICOLON -> AttributeConstraintList

        acl::AttributeConstraintList REQUIRE COLON f::Featvar SEMICOLON -> AttributeConstraintList

        acl::AttributeConstraintList t::TYPE-IDENTIFIER id::IDENTIFIER IN LBRACKET b1::BoundaryInt UNTIL b2::BoundaryInt RBRACKET SEMICOLON -> AttributeConstraintList

        acl::AttributeConstraintList IFIN COLON e::Mexp SEMICOLON -> AttributeConstraintList

        "/" -> AttributeConstraintList

        acl::AttributeConstraintList t::TYPE-IDENTIFIER LBRACKET b1::BoundaryInt UNTIL b2::BoundaryInt RBRACKET id::IDENTIFIER SEMICOLON -> AttributeConstraintList

        acl::AttributeConstraintList t::TYPE-IDENTIFIER id::IDENTIFIER IN LBRACE il::IntList RBRACE SEMICOLON -> AttributeConstraintList

        acl::AttributeConstraintList IFOUT COLON e::Mexp SEMICOLON -> AttributeConstraintList

        acl::AttributeConstraintList e::Mexp SEMICOLON -> AttributeConstraintList

        "and" -> AND

        "export" -> EXPORT

        l::AnyNameList COMMA n::AnyName -> AnyNameList

        AnyName -> AnyNameList {cons(n)}

        EXTENDS i::IfnameList -> ExtendsInterfaces

        "implements" -> IMPLEMENTS

        StringLiteral -> SqlAtomicRelationRef {cons(r)}

        VarOrFieldRef -> SqlAtomicRelationRef {cons(r)}

        n::IDENTIFIER ASSIGN c::TYPE-IDENTIFIER -> AttrAssignment

        n::IDENTIFIER ASSIGN i::INTLITERAL -> AttrAssignment

        NEW -> IncompleteExp

        callee::PureExpPrefix b::BANG -> IncompleteExp

        callee::PureExpPrefix d::DOT -> IncompleteExp

        "after" -> AFTER

        IMPLEMENTS i::IfnameList -> ImplementInterfaces

        "exclude" -> EXCLUDE

        IF LPAREN e1::DataExp RPAREN s1::Stmt -> IfThenElseStmt

        IF LPAREN e1::DataExp RPAREN s1::Stmt ELSE s2::Stmt -> IfThenElseStmt

        callee::PureExpPrefix DOT method::IDENTIFIER LPAREN RPAREN -> SyncCall

        callee::THIS DOT method::IDENTIFIER LPAREN RPAREN -> SyncCall

        fm::Featuremodeldecl -> CompilationUnit

        IMPORT l::AnyNameList FROM m::ModuleName SEMICOLON -> Import

        IMPORT MULT FROM m::ModuleName SEMICOLON -> Import

        IMPORT l::AnyNameList SEMICOLON -> Import

        HASINTERFACE n::TypeName -> HasCondition

        HASMETHOD ms::Methodsig -> HasCondition

        HASFIELD f::FieldDecl -> HasCondition

        "uses" -> USES

        f1::SqlTupleScalarFunctionQuotient DIV LPAREN f2::SqlTupleScalarFunctionSum RPAREN -> SqlTupleScalarFunctionQuotient

        f1::SqlTupleScalarFunctionQuotient DIV f2::AtomicSqlTupleScalarFunction -> SqlTupleScalarFunctionQuotient

        AtomicSqlTupleScalarFunction -> SqlTupleScalarFunctionQuotient

        EXPORT MULT FROM m::ModuleName SEMICOLON -> Export

        EXPORT l::AnyNameList SEMICOLON -> Export

        EXPORT l::AnyNameList FROM m::ModuleName SEMICOLON -> Export

        EXPORT MULT SEMICOLON -> Export

        SqlCondition -> SqlAndCondition

        c1::SqlAndCondition op::AND c2::SqlCondition -> SqlAndCondition

        "features" -> OPTFEATURES

        co::TYPE-IDENTIFIER -> DataConstructor

        "original" -> ORIGINAL

        SqlTupleScalarFunctionQuotient -> SqlTupleScalarFunctionProduct

        f1::SqlTupleScalarFunctionProduct MULT LPAREN f2::SqlTupleScalarFunctionSum RPAREN -> SqlTupleScalarFunctionProduct

        f1::SqlTupleScalarFunctionProduct MULT f2::SqlTupleScalarFunctionQuotient -> SqlTupleScalarFunctionProduct

        MULT -> SqlAttrsDef

        SqlAttrDefList -> SqlAttrsDef {cons(l)}

        "hasInterface" -> HASINTERFACE

        MultExp -> AddExp {cons(e)}

        e1::AddExp MINUS e2::MultExp -> AddExp

        e1::AddExp PLUS e2::MultExp -> AddExp

        DeltaAccess -> DeltaAccessList {cons(t)}

        l::DeltaAccessList t::DeltaAccess -> DeltaAccessList

        "hasMethod" -> HASMETHOD

        ")" -> RPAREN

        "movecogto" -> MOVECOGTO

        FatherExp "/" -> PureExp

        LocationExp "/" -> PureExp

        IfExp -> PureExp

        PureExpNoIf -> PureExp

        "def" -> DEF

        "or" -> OR

        TypeName -> ConstructorExp {cons(f)}

        f::TypeName LPAREN RPAREN -> ConstructorExp

         -> INTLITERAL

        INTLITERAL -> IntLiteral {cons(i)}

        e1::MmultExp DIV e2::MfactorExp -> MmultExp

        e1::MmultExp MOD e2::MfactorExp -> MmultExp

        MfactorExp -> MmultExp {cons(e)}

        e1::MmultExp MULT e2::MfactorExp -> MmultExp

        ORIGINAL LPAREN RPAREN -> OriginalCall

        delta::DeltaId DOTORIGINAL LPAREN RPAREN -> OriginalCall

        CORE DOTORIGINAL LPAREN RPAREN -> OriginalCall

        c1::SqlOrCondition op::OR c2::SqlAndCondition -> SqlOrCondition

        SqlAndCondition -> SqlOrCondition

        s::CompoundStmt -> Stmt

        s::StmtWithoutAnnotations SEMICOLON -> Stmt

        "]" -> RBRACKET

        l::ParamDeclList COMMA i::ParamDecl -> ParamDeclList

        ParamDecl -> ParamDeclList {cons(i)}

        fid::TYPE-IDENTIFIER DOT aid::IDENTIFIER -> Deltaparam

        INTLITERAL -> Deltaparam {cons(i)}

        TYPE-IDENTIFIER -> Deltaparam {cons(c)}

        "adds" -> ADDS

        f1::SqlTupleScalarFunctionConcat CONCAT f2::SqlTupleScalarFunctionSum -> SqlTupleScalarFunctionConcat

        SqlTupleScalarFunctionSum -> SqlTupleScalarFunctionConcat

        "|" -> BAR

        OrExp -> DataExp

        "right" -> RIGHT

        DataExp -> Exp {cons(e)}

        EffExp -> Exp {cons(e)}

        ".original" -> DOTORIGINAL

        "let" -> LET

        "||" -> OROR

        QualifiedTypeName -> TypeName

        SimpleTypeName -> TypeName

        "ifin" -> IFIN

        CASE b::SqlTupleCaseBranches ELSE f::SqlTupleScalarFunction END -> SqlTupleCaseFunction

        "false" -> FALSE

        n::TypeName LT p::DatatypeuseList GT -> Datatypeuse

        n::TypeName -> Datatypeuse

        "move" -> SUBLOC

        FATHER LPAREN param::PureExp RPAREN -> FatherExp

        "}" -> RBRACE

        CRITICAL ms::Methodsig b::Block -> Method

        ms::Methodsig b::Block -> Method

        FactorAppcond -> AndAppcond

        ac1::AndAppcond ANDAND ac2::FactorAppcond -> AndAppcond

        il::IntList COMMA MINUS i::INTLITERAL -> IntList

        il::IntList COMMA i::INTLITERAL -> IntList

        MINUS i::INTLITERAL -> IntList

        INTLITERAL -> IntList {cons(i)}

        f1::SqlTupleScalarFunction r::SqlComparisonRelation f2::SqlTupleScalarFunction -> SqlCondition

        a::StringLiteral IS NULL -> SqlCondition

        NOT c::SqlCondition -> SqlCondition

        LPAREN c::SqlOrCondition RPAREN -> SqlCondition

        GROUP BY a::SqlAttrRefList -> SqlGroupingAttributes

         -> SqlGroupingAttributes

        TYPE-IDENTIFIER -> Datatypeparam {cons(id)}

        LPAREN RPAREN -> PatternParams

        l::ModuleDeclList t::ModuleDecl -> ModuleDeclList

        ModuleDecl -> ModuleDeclList {cons(t)}

        "||" -> CONCAT

        lhs::Pattern RARROW rhs::DataExp SEMICOLON -> CaseBranch

        "&" -> GUARDAND

        "while" -> WHILE

        LPAREN l::DeltaparamList RPAREN -> Deltaparams

        USES m::ModuleName SEMICOLON -> DeltaAccess

        "if" -> IF

        e1::OrExp OROR e2::AndExp -> OrExp

        AndExp -> OrExp

        e::DataExp ASC -> SqlOrderingAttribute

        e::DataExp DESC -> SqlOrderingAttribute

        DataExp -> SqlOrderingAttribute {cons(e)}

        "allof" -> ALLOF

        "interface" -> INTERFACE

        CLASS id::TypeName LBRACE RBRACE -> QualifiedClassDecl

        DELTA d::Deltaspec -> DeltaClause

        qn::TypeName DOT n::IDENTIFIER -> QualifiedName

        f::Name LPAREN RPAREN -> FnappExp

        "in" -> IN

        "values" -> VALUES

         -> OptSqlCondition

        WHERE c::SqlOrCondition -> OptSqlCondition

        "location" -> LOC

        "order" -> ORDER

        "is" -> IS

        "join" -> JOIN

        Comment -> LAYOUT

         -> LAYOUT

        "." -> DOT

        "get" -> GET

        "await" -> AWAIT

        TypeName -> ModuleName

        product::TYPE-IDENTIFIER BY update::TYPE-IDENTIFIER SEMICOLON -> Adaptation

        "*" -> MULT

        "case" -> CASE

        "return" -> RETURN

        DataExp -> DataExpList {cons(i)}

        l::DataExpList COMMA i::DataExp -> DataExpList

        ".." -> UNTIL

        STRINGLITERAL -> StringLiteral {cons(s)}

        SqlTupleScalarFunctionConcat -> SqlTupleScalarFunction

        ":" -> COLON

        l::MethodList i::Method -> MethodList

        Method -> MethodList {cons(i)}

        "_" -> USCORE

        l::Featuremodeldecl ROOT f::FeatureDecl -> Featuremodeldecl

         -> Featuremodeldecl

        l::Featuremodeldecl EXTENSION ext::Fextension -> Featuremodeldecl

        Block -> InitBlock

        "type" -> TYPE

        "when" -> WHEN

        "else" -> ELSE

        "assert" -> ASSERT

        "{" -> LBRACE

        Datatypeparam -> DatatypeparamList {cons(p)}

        l::DatatypeparamList COMMA p::Datatypeparam -> DatatypeparamList

        ASSERT e::DataExp -> StmtWithoutAnnotations

        MOVECOGTO DataExp -> StmtWithoutAnnotations

        RETURN e::Exp -> StmtWithoutAnnotations

        AWAIT Guard -> StmtWithoutAnnotations

        SKIP -> StmtWithoutAnnotations

        EffExp -> StmtWithoutAnnotations {cons(e)}

        SUBLOC sub::PureExp IN father::PureExp -> StmtWithoutAnnotations

        VarDecl -> StmtWithoutAnnotations {cons(vd)}

        SUSPEND -> StmtWithoutAnnotations

        REBIND obj::Exp COLON field::IDENTIFIER ASSIGN e::Exp -> StmtWithoutAnnotations

        DURATION LPAREN min::DataExp COMMA max::DataExp RPAREN -> StmtWithoutAnnotations

        r::VarOrFieldRef ASSIGN e::Exp -> StmtWithoutAnnotations

        REBIND field::IDENTIFIER ASSIGN e::Exp -> StmtWithoutAnnotations

        "require" -> REQUIRE

        MULT -> BoundaryInt

        MINUS i::INTLITERAL -> BoundaryInt

        INTLITERAL -> BoundaryInt {cons(i)}

        "productline" -> PRODUCTLINE

        AndAppcond -> OrAppcond

        ac1::OrAppcond OROR ac2::AndAppcond -> OrAppcond

        LBRACKET type::TypeExp COLON exp::DataExp RBRACKET -> Annotation

        LBRACKET exp::DataExp RBRACKET -> Annotation

        WHEN c::SqlOrCondition THEN f::SqlTupleScalarFunction -> SqlTupleCaseBranch

        TypeName -> Ifname {cons(n)}

        OPT f::FeatureDecl -> Fnode

        FeatureDecl -> Fnode {cons(f)}

        StringLiteral -> AtomicSqlTupleScalarFunction {cons(a)}

        SqlTupleConstant -> AtomicSqlTupleScalarFunction

        SqlTupleCaseFunction -> AtomicSqlTupleScalarFunction

        e1::RelationalExp GTEQ e2::AddExp -> RelationalExp

        AddExp -> RelationalExp

        e1::RelationalExp GT e2::AddExp -> RelationalExp

        e1::RelationalExp LT e2::AddExp -> RelationalExp

        e1::RelationalExp LTEQ e2::AddExp -> RelationalExp

        n::ModuleNameDecl -> ModuleDecl

        DataExp -> SqlAttrRef

        e1::MandExp ANDAND e2::MimplExp -> MandExp

        MimplExp -> MandExp

        id::TYPE-IDENTIFIER -> Deltaspec

        e1::MrelExp LTEQ e2::MaddExp -> MrelExp

        e1::MrelExp LT e2::MaddExp -> MrelExp

        e1::MrelExp GT e2::MaddExp -> MrelExp

        MaddExp -> MrelExp

        e1::MrelExp GTEQ e2::MaddExp -> MrelExp

        "father" -> FATHER

        DeltaParamDecl -> DeltaParamDeclList {cons(i)}

        l::DeltaParamDeclList COMMA i::DeltaParamDecl -> DeltaParamDeclList

        "cog" -> COG

        COG -> Cog

        "class" -> CLASS

        "~" -> NEGATION

        i::FieldDecl SEMICOLON -> FieldDeclList

        l::FieldDeclList i::FieldDecl SEMICOLON -> FieldDeclList

        PRODUCTLINE id::TYPE-IDENTIFIER SEMICOLON o::OptfeatureList c::CorefeatureList d::DeltaclauseList -> ProductLine

        INTERFACE id::TYPE-IDENTIFIER LBRACE RBRACE -> InterfaceDecl

        LBRACKET i::INTLITERAL UNTIL MULT RBRACKET -> Cardinality

        ONEOF -> Cardinality

        LBRACKET i1::INTLITERAL UNTIL i2::INTLITERAL RBRACKET -> Cardinality

        ALLOF -> Cardinality

        Literal -> Factor

        MINUS e::Factor -> Factor

        PureExp -> Factor

        LPAREN e::OrExp RPAREN -> Factor

        NEGATION b::Factor -> Factor

        LPAREN RPAREN -> DataConstructorParams

        LT -> SqlComparisonRelation

        GT -> SqlComparisonRelation

        EQ -> SqlComparisonRelation

        NOTEQ -> SqlComparisonRelation

        GTEQ -> SqlComparisonRelation

        LTEQ -> SqlComparisonRelation

        Literal -> Pattern {cons(l)}

        USCORE -> Pattern

        IDENTIFIER -> Pattern {cons(v)}

        ConstructorPattern -> Pattern

        "skip" -> SKIP

        AttrAssignment -> AttrAssignmentList {cons(a)}

        l::AttrAssignmentList COMMA a::AttrAssignment -> AttrAssignmentList

        IDENTIFIER -> SimpleName {cons(id)}
