LocatedElement = ;
Body = rules::ANY+ ;
InWhereHolds = var::ANY in::ANY where::ANY holds::ANY ;
AsmLFile = elements::ANY+ main::ANY ;
AsmLElement = ;
VarDeclaration = isConstant::ANY isDeclaration::ANY isLocal::ANY name::ANY type::ANY ;
Namespace = name::ANY ;
Structure = name::ANY varOrCase::ANY+ superStructureName::ANY ;
VarOrCase = ;
Case = name::ANY variables::ANY+ ;
Class = name::ANY isAbstract::ANY superClassName::ANY varOrMethod::ANY+ ;
VarOrMethod = ownerClass::ANY ;
Enumeration = name::ANY enumerators::ANY+ ;
Enumerator = name::ANY value::ANY ;
Function = ;
Method = isAbstract::ANY isShared::ANY isEntryPoint::ANY isOverride::ANY returnType::ANY parameters::ANY+ ;
Parameter = name::ANY type::ANY ownerMethod::ANY ;
Main = mainFile::ANY initialisations::ANY+ ;
Initially = id::ANY val::ANY ;
Rule = ;
SkipRule = ownerBody::ANY ;
Step = ;
StepUntilFixPoint = name::ANY ;
StepExpression = ;
StepWhile = expression::ANY ;
StepUntil = expression::ANY ;
StepForEach = expressions::ANY+ ;
MethodInvocation = called::ANY ;
UpdateRule = ;
UpdateVarRule = updateVar::ANY ;
UpdateFieldRule = path::ANY ;
UpdateMapRule = updateMap::ANY parameters::ANY+ ;
ChooseRule = expressions::ANY+ ifChoosenRules::ANY ifNotChoosenRule::ANY ;
ForallRule = expressions::ANY+ doRule::ANY ;
ConditionalRule = condition::ANY thenRule::ANY elseRule::ANY elseIfRule::ANY ;
ElseIf = ;
ReturnRule = term::ANY ;
AddRule = val::ANY set::ANY ;
RemoveRule = val::ANY set::ANY ;
Type = ;
NamedType = name::ANY ;
MapType = ofType::ANY toType::ANY ;
TupletType = types::ANY ;
SetType = of::ANY ;
SequenceType = of::ANY ;
Term = ;
VarTerm = name::ANY ;
Operator = opName::ANY leftExp::ANY rightExp::ANY ;
MapTerm = ofTerm::ANY toTerm::ANY separator::ANY ;
TulpletTerm = terms::ANY ;
MethodCallTerm = name::ANY parameters::ANY+ ;
NewInstance = ;
PredicateTerm = expressions::ANY+ ;
ForAllTerm = ;
ExistsTerm = isUnique::ANY ;
AnyIn = ;
SetTerm = ;
EnumerateSet = vals::ANY+ ;
RangeSet = minval::ANY maxval::ANY ;
AlgorithmSet = expressions::ANY+ ;
SequenceTerm = ;
EnumerateSequence = vals::ANY+ ;
RangeSequence = minval::ANY maxval::ANY ;
Constant = ;
BooleanConstant = val::ANY ;
IntegerConstant = val::ANY ;
StringConstant = val::ANY ;
NullConstant =  ;
