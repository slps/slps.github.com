AST = root::ANY ;
ASTNode = ;
AnonymousClassDeclaration = bodyDeclarations::ANY+ ;
BodyDeclaration = ;
CatchClause = body::ANY exception::ANY ;
Comment = ;
CompilationUnit = comments::ANY+ package::ANY imports::ANY+ types::ANY+ ;
Expression = ;
ImportDeclaration = onDemand::ANY static::ANY name::ANY ;
MemberRef = name::ANY qualifier::ANY ;
MemberValuePair = name::ANY value::ANY ;
MethodRef = name::ANY qualifier::ANY parameters::ANY+ ;
MethodRefParameter = name::ANY type::ANY varargs::ANY ;
ExtendedModifier = ;
Modifier = abstract::ANY final::ANY native::ANY none::ANY private::ANY protected::ANY public::ANY static::ANY strictfp::ANY synchronized::ANY transient::ANY volatile::ANY ;
PackageDeclaration = annotations::ANY+ javadoc::ANY name::ANY ;
Statement = ;
TagElement = fragments::ANY+ tagName::ANY nested::ANY ;
TextElement = text::ANY ;
Type = ;
TypeParameter = name::ANY typeBounds::ANY+ ;
VariableDeclaration = ;
AbstractTypeDeclaration = ;
AnnotationTypeMemberDeclaration = default::ANY name::ANY type::ANY ;
EnumConstantDeclaration = arguments::ANY+ anonymousClassDeclaration::ANY name::ANY ;
FieldDeclaration = fragments::ANY+ type::ANY ;
Initializer = body::ANY ;
MethodDeclaration = body::ANY extraDimensions::ANY name::ANY returnType::ANY constructor::ANY varargs::ANY parameters::ANY+ thrownExceptions::ANY+ typeParameters::ANY+ ;
AnnotationTypeDeclaration = ;
EnumDeclaration = superInterfaceTypes::ANY+ enumConstants::ANY+ ;
TypeDeclaration = superclassType::ANY interface::ANY superInterfaceTypes::ANY+ typeParameters::ANY+ ;
BlockComment = ;
Javadoc = tags::ANY+ ;
LineComment = ;
Annotation = ;
ArrayAccess = array::ANY index::ANY ;
ArrayCreation = dimensions::ANY+ initializer::ANY type::ANY ;
ArrayInitializer = expressions::ANY+ ;
Assignment = leftHandSide::ANY operator::ANY rightHandSide::ANY ;
AssignementOperatorKind = RIGHT_SHIFT_SIGNED_ASSIGN:: ;
AssignementOperatorKind = BIT_XOR_ASSIGN:: ;
AssignementOperatorKind = TIMES_ASSIGN:: ;
AssignementOperatorKind = LEFT_SHIFT_ASSIGN:: ;
AssignementOperatorKind = MINUS_ASSIGN:: ;
AssignementOperatorKind = BIT_OR_ASSIGN:: ;
AssignementOperatorKind = PLUS_ASSIGN:: ;
AssignementOperatorKind = ASSIGN:: ;
AssignementOperatorKind = RIGHT_SHIFT_UNSIGNED_ASSIGN:: ;
AssignementOperatorKind = REMAINDER_ASSIGN:: ;
AssignementOperatorKind = DIVIDE_ASSIGN:: ;
AssignementOperatorKind = BIT_AND_ASSIGN:: ;
BooleanLiteral = booleanValue::ANY ;
CastExpression = expression::ANY type::ANY ;
CharacterLiteral = charValue::ANY escapedValue::ANY ;
ClassInstanceCreation = arguments::ANY+ anonymousClassDeclaration::ANY expression::ANY type::ANY typeArguments::ANY+ ;
ConditionalExpression = elseExpression::ANY expression::ANY thenExpression::ANY ;
FieldAccess = expression::ANY name::ANY ;
InfixExpression = extendedOperands::ANY+ leftOperand::ANY operator::ANY rightOperand::ANY ;
InfixExpressionOperatorKind = GREATER_EQUALS:: ;
InfixExpressionOperatorKind = OR:: ;
InfixExpressionOperatorKind = RIGHT_SHIFT_SIGNED:: ;
InfixExpressionOperatorKind = MINUS:: ;
InfixExpressionOperatorKind = XOR:: ;
InfixExpressionOperatorKind = LESS_EQUALS:: ;
InfixExpressionOperatorKind = EQUALS:: ;
InfixExpressionOperatorKind = NOT_EQUALS:: ;
InfixExpressionOperatorKind = AND:: ;
InfixExpressionOperatorKind = PLUS:: ;
InfixExpressionOperatorKind = GREATER:: ;
InfixExpressionOperatorKind = CONDITIONAL_OR:: ;
InfixExpressionOperatorKind = REMAINDER:: ;
InfixExpressionOperatorKind = LESS:: ;
InfixExpressionOperatorKind = LEFT_SHIFT:: ;
InfixExpressionOperatorKind = RIGHT_SHIFT_UNSIGNED:: ;
InfixExpressionOperatorKind = CONDITIONAL_AND:: ;
InfixExpressionOperatorKind = TIMES:: ;
InfixExpressionOperatorKind = DIVIDE:: ;
InstanceofExpression = leftOperand::ANY rightOperand::ANY ;
MethodInvocation = arguments::ANY+ expression::ANY name::ANY typeArguments::ANY+ ;
Name = ;
NullLiteral = ;
NumberLiteral = token::ANY ;
ParenthesizedExpression = expression::ANY ;
PostfixExpression = operand::ANY operator::ANY ;
PostfixExpresssionOperatorKind = INCREMENT:: ;
PostfixExpresssionOperatorKind = DECREMENT:: ;
PrefixExpression = operand::ANY operator::ANY ;
PrefixExpresssionOperatorKind = MINUS:: ;
PrefixExpresssionOperatorKind = NOT:: ;
PrefixExpresssionOperatorKind = DECREMENT:: ;
PrefixExpresssionOperatorKind = COMPLEMENT:: ;
PrefixExpresssionOperatorKind = INCREMENT:: ;
PrefixExpresssionOperatorKind = PLUS:: ;
StringLiteral = escapedValue::ANY literalValue::ANY ;
SuperFieldAccess = name::ANY qualifier::ANY ;
SuperMethodInvocation = arguments::ANY+ name::ANY qualifier::ANY typeArguments::ANY+ ;
ThisExpression = qualifier::ANY ;
TypeLiteral = type::ANY ;
VariableDeclarationExpression = fragments::ANY+ modifiers::ANY+ type::ANY ;
AssertStatement = expression::ANY message::ANY ;
Block = statements::ANY+ ;
BreakStatement = label::ANY ;
ConstructorInvocation = arguments::ANY+ typeArguments::ANY+ ;
ContinueStatement = label::ANY ;
DoStatement = body::ANY expression::ANY ;
EmptyStatement = ;
EnhancedForStatement = body::ANY expression::ANY parameter::ANY ;
ExpressionStatement = expression::ANY ;
ForStatement = body::ANY expression::ANY initializers::ANY+ updaters::ANY+ ;
IfStatement = elseStatement::ANY expression::ANY thenStatement::ANY ;
LabeledStatement = body::ANY label::ANY ;
ReturnStatement = expression::ANY ;
SuperConstructorInvocation = arguments::ANY+ expression::ANY typeArguments::ANY+ ;
SwitchCase = expression::ANY default::ANY ;
SwitchStatement = expression::ANY statements::ANY+ ;
SynchronizedStatement = body::ANY expression::ANY ;
ThrowStatement = expression::ANY ;
TryStatement = catchClauses::ANY+ body::ANY finally::ANY ;
TypeDeclarationStatement = declaration::ANY ;
VariableDeclarationStatement = fragments::ANY+ modifiers::ANY+ type::ANY ;
WhileStatement = body::ANY expression::ANY ;
ArrayType = componentType::ANY dimensions::ANY elementType::ANY ;
ParameterizedType = type::ANY typeArguments::ANY+ ;
PrimitiveType = code::ANY ;
QualifiedType = name::ANY qualifier::ANY ;
SimpleType = name::ANY ;
WildcardType = bound::ANY upperBound::ANY ;
SingleVariableDeclaration = type::ANY varargs::ANY modifiers::ANY+ ;
VariableDeclarationFragment = ;
QualifiedName = name::ANY qualifier::ANY ;
SimpleName = identifier::ANY declaration::ANY ;
MarkerAnnotation = ;
NormalAnnotation = values::ANY+ ;
SingleMemberAnnotation = value::ANY ;
