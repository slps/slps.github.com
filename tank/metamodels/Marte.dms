Element = ;
Comment = body::ANY annotatedElement::ANY+ ;
Package = ownedType::ANY+ packageMerge::ANY+ packagedElement::ANY+ nestedPackage::ANY+ nestingPackage::ANY profileApplication::ANY+ ;
NamedElement = ;
StructuralFeature = ;
ConnectableElement = ;
TemplateableElement = ;
Property = class::ANY datatype::ANY owningAssociation::ANY association::ANY isDerived::ANY isDerivedUnion::ANY default::ANY aggregation::ANY isComposite::ANY redefinedProperty::ANY+ defaultValue::ANY opposite::ANY subsettedProperty::ANY+ qualifier::ANY+ associationEnd::ANY ;
VisibilityKind = public:: ;
VisibilityKind = private:: ;
VisibilityKind = protected:: ;
VisibilityKind = package:: ;
Dependency = supplier::ANY+ client::ANY+ ;
DirectedRelationship = ;
Relationship = ;
Namespace = ;
ElementImport = visibility::ANY alias::ANY importedElement::ANY importingNamespace::ANY ;
PackageImport = visibility::ANY importedPackage::ANY importingNamespace::ANY ;
Constraint = constrainedElement::ANY+ specification::ANY context::ANY ;
TypedElement = ;
Type = ;
Association = isDerived::ANY ownedEnd::ANY+ endType::ANY+ memberEnd::ANY navigableOwnedEnd::ANY+ ;
Classifier = ;
RedefinableElement = ;
TemplateBinding = signature::ANY parameterSubstitution::ANY+ boundElement::ANY ;
TemplateSignature = parameter::ANY+ ownedParameter::ANY+ template::ANY ;
TemplateParameter = signature::ANY parameteredElement::ANY ownedParameteredElement::ANY default::ANY ownedDefault::ANY ;
ParameterableElement = ;
TemplateParameterSubstitution = formal::ANY actual::ANY+ ownedActual::ANY+ templateBinding::ANY ;
Generalization = isSubstitutable::ANY general::ANY generalizationSet::ANY+ specific::ANY ;
GeneralizationSet = isCovering::ANY isDisjoint::ANY powertype::ANY generalization::ANY+ ;
Feature = ;
Substitution = contract::ANY substitutingClassifier::ANY ;
PackageableElement = ;
PackageMerge = mergedPackage::ANY receivingPackage::ANY ;
ProfileApplication = appliedProfile::ANY isStrict::ANY applyingPackage::ANY ;
Profile = ownedStereotype::ANY+ metaclassReference::ANY+ metamodelReference::ANY+ ;
Stereotype = icon::ANY+ ;
Class = nestedClassifier::ANY+ ownedOperation::ANY+ superClass::ANY+ isActive::ANY ownedReception::ANY+ extension::ANY+ ;
StringExpression = subExpression::ANY+ owningExpression::ANY ;
Expression = symbol::ANY operand::ANY+ ;
ValueSpecification = ;
BehavioredClassifier = ;
Behavior = ;
MultiplicityElement = ;
DeploymentTarget = ;
DataType = ownedAttribute::ANY+ ownedOperation::ANY+ ;
AggregationKind = none:: ;
AggregationKind = shared:: ;
AggregationKind = composite:: ;
CollaborationUse = type::ANY roleBinding::ANY+ ;
UseCase = include::ANY+ extend::ANY+ extensionPoint::ANY+ subject::ANY+ ;
Realization = ;
Abstraction = mapping::ANY ;
Image = content::ANY location::ANY format::ANY ;
OpaqueExpression = body::ANY+ language::ANY+ result::ANY behavior::ANY ;
Parameter = direction::ANY default::ANY defaultValue::ANY operation::ANY parameterSet::ANY+ isException::ANY isStream::ANY effect::ANY ;
EncapsulatedClassifier = ;
Operation = interface::ANY class::ANY isQuery::ANY isOrdered::ANY isUnique::ANY lower::ANY upper::ANY precondition::ANY+ postcondition::ANY+ redefinedOperation::ANY+ datatype::ANY bodyCondition::ANY type::ANY ;
Reception = signal::ANY ;
Extension = isRequired::ANY metaclass::ANY ;
EnumerationLiteral = enumeration::ANY ;
ActivityPartition = isDimension::ANY isExternal::ANY node::ANY+ subpartition::ANY+ superPartition::ANY represents::ANY edge::ANY+ ;
Enumeration = ownedLiteral::ANY+ ;
InstanceSpecification = classifier::ANY+ slot::ANY+ specification::ANY ;
BehavioralFeature = ;
Signal = ownedAttribute::ANY+ ;
TimeExpression = expr::ANY observation::ANY+ ;
Observation = ;
Duration = expr::ANY observation::ANY+ ;
DurationInterval = ;
Interval = min::ANY max::ANY ;
TimeConstraint = firstEvent::ANY ;
IntervalConstraint = ;
TimeInterval = ;
DurationConstraint = firstEvent::ANY ;
TimeObservation = event::ANY firstEvent::ANY ;
DurationObservation = event::ANY firstEvent::ANY ;
ConnectorEnd = definingEnd::ANY partWithPort::ANY role::ANY ;
TimeEvent = isRelative::ANY when::ANY ;
Event = ;
Port = isBehavior::ANY isService::ANY required::ANY+ redefinedPort::ANY+ provided::ANY+ protocol::ANY ;
Action = ;
Message = messageKind::ANY messageSort::ANY receiveEvent::ANY sendEvent::ANY connector::ANY interaction::ANY argument::ANY+ signature::ANY ;
Lifeline = represents::ANY interaction::ANY selector::ANY decomposedAs::ANY coveredBy::ANY+ ;
ExecutionSpecification = ;
InvocationAction = ;
Connector = type::ANY redefinedConnector::ANY+ end::ANY kind::ANY contract::ANY+ ;
Collaboration = collaborationRole::ANY+ ;
Interface = ownedAttribute::ANY+ ownedOperation::ANY+ nestedClassifier::ANY+ redefinedInterface::ANY+ ownedReception::ANY+ protocol::ANY ;
InterfaceRealization = contract::ANY implementingClassifier::ANY ;
Trigger = event::ANY port::ANY+ ;
ProtocolStateMachine = conformance::ANY+ ;
StateMachine = region::ANY+ submachineState::ANY+ connectionPoint::ANY+ extendedStateMachine::ANY+ ;
ProtocolConformance = generalMachine::ANY specificMachine::ANY ;
Deployment = deployedArtifact::ANY+ configuration::ANY+ location::ANY ;
Include = addition::ANY includingCase::ANY ;
Extend = extendedCase::ANY condition::ANY extensionLocation::ANY+ extension::ANY ;
ExtensionPoint = useCase::ANY ;
Region = subvertex::ANY+ transition::ANY+ state::ANY extendedRegion::ANY stateMachine::ANY ;
StructuredClassifier = ;
Vertex = ;
Transition = kind::ANY container::ANY redefinedTransition::ANY guard::ANY effect::ANY trigger::ANY+ target::ANY source::ANY ;
TransitionKind = internal:: ;
TransitionKind = local:: ;
TransitionKind = external:: ;
State = isComposite::ANY isOrthogonal::ANY isSimple::ANY isSubmachineState::ANY submachine::ANY connection::ANY+ connectionPoint::ANY+ redefinedState::ANY stateInvariant::ANY entry::ANY exit::ANY doActivity::ANY deferrableTrigger::ANY+ region::ANY+ ;
ParameterSet = parameter::ANY+ condition::ANY+ ;
ActivityNode = ;
ActivityGroup = ;
ParameterDirectionKind = in:: ;
ParameterDirectionKind = inout:: ;
ParameterDirectionKind = out:: ;
ParameterDirectionKind = return:: ;
ParameterEffectKind = create:: ;
ParameterEffectKind = read:: ;
ParameterEffectKind = update:: ;
ParameterEffectKind = delete:: ;
ActivityEdge = ;
InterruptibleActivityRegion = node::ANY+ interruptingEdge::ANY+ ;
DeployedArtifact = ;
Slot = definingFeature::ANY value::ANY+ owningInstance::ANY ;
ExecutableNode = ;
OutputPin = ;
Pin = isControl::ANY ;
InputPin = ;
MessageKind = complete:: ;
MessageKind = lost:: ;
MessageKind = found:: ;
MessageKind = unknown:: ;
ExceptionHandler = handlerBody::ANY exceptionInput::ANY exceptionType::ANY+ protectedNode::ANY ;
ObjectNode = ;
ObjectNodeOrderingKind = unordered:: ;
ObjectNodeOrderingKind = ordered:: ;
ObjectNodeOrderingKind = LIFO:: ;
ObjectNodeOrderingKind = FIFO:: ;
MessageEnd = ;
MessageSort = synchCall:: ;
MessageSort = asynchCall:: ;
MessageSort = asynchSignal:: ;
MessageSort = createMessage:: ;
MessageSort = deleteMessage:: ;
MessageSort = reply:: ;
Interaction = lifeline::ANY+ fragment::ANY+ action::ANY+ formalGate::ANY+ message::ANY+ ;
PartDecomposition = ;
InteractionUse = refersTo::ANY actualGate::ANY+ argument::ANY+ ;
InteractionFragment = ;
ConnectorKind = assembly:: ;
ConnectorKind = delegation:: ;
Pseudostate = kind::ANY stateMachine::ANY state::ANY ;
PseudostateKind = initial:: ;
PseudostateKind = deepHistory:: ;
PseudostateKind = shallowHistory:: ;
PseudostateKind = join:: ;
PseudostateKind = fork:: ;
PseudostateKind = junction:: ;
PseudostateKind = choice:: ;
PseudostateKind = entryPoint:: ;
PseudostateKind = exitPoint:: ;
PseudostateKind = terminate:: ;
ConnectionPointReference = entry::ANY+ exit::ANY+ state::ANY ;
StructuredActivityNode = variable::ANY+ edge::ANY+ mustIsolate::ANY node::ANY+ ;
Variable = scope::ANY activityScope::ANY ;
Activity = structuredNode::ANY+ variable::ANY+ node::ANY+ isReadOnly::ANY edge::ANY+ partition::ANY+ isSingleExecution::ANY group::ANY+ ;
OccurrenceSpecification = toBefore::ANY+ event::ANY toAfter::ANY+ ;
DeploymentSpecification = deploymentLocation::ANY executionLocation::ANY deployment::ANY ;
Gate = message::ANY ;
Artifact = fileName::ANY nestedArtifact::ANY+ manifestation::ANY+ ownedOperation::ANY+ ownedAttribute::ANY+ ;
GeneralOrdering = before::ANY after::ANY ;
Manifestation = utilizedElement::ANY ;
InteractionOperand = guard::ANY fragment::ANY+ ;
InteractionConstraint = minint::ANY maxint::ANY ;
