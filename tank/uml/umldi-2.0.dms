Collaboration = usedCollaboration::Collaboration+ representedOperation::Operation representedClassifier::Classifier interaction::Interaction+ constrainingElement::ModelElement+ ;
ClassifierRole = availableContents::ModelElement+ base::Classifier+ conformingInstance::Instance+ availableFeature::Feature+ multiplicity::Multiplicity ;
AssociationRole = base::Association conformingLink::Link+ message::Message+ multiplicity::Multiplicity ;
AssociationEndRole = base::AssociationEnd availableQualifier::Attribute+ collaborationMultiplicity::Multiplicity ;
Message = interaction::Interaction conformingStimulus::Stimulus+ action::Action communicationConnection::AssociationRole activator::Message receiver::ClassifierRole sender::ClassifierRole predecessor::Message+ ;
Interaction = message::Message+ context::Collaboration ;
InteractionInstanceSet = interaction::Interaction context::CollaborationInstanceSet participatingStimulus::Stimulus+ ;
CollaborationInstanceSet = collaboration::Collaboration constrainingElement::ModelElement+ participatingInstance::Instance+ interactionInstanceSet::InteractionInstanceSet+ participatingLink::Link+ ;
UseCase = include::Include+ extend::Extend+ extensionPoint::ExtensionPoint+ ;
Actor = powertypeRange::Generalization+ feature::Feature+ ;
UseCaseInstance = ownedInstance::Instance+ linkEnd::LinkEnd+ classifier::Classifier+ componentInstance::ComponentInstance slot::AttributeLink+ ownedLink::Link+ ;
Extend = extensionPoint::ExtensionPoint+ extension::UseCase base::UseCase condition::BooleanExpression ;
Include = addition::UseCase base::UseCase ;
ExtensionPoint = useCase::UseCase location::String ;
AggregationKind = ak_none:: ;
AggregationKind = ak_aggregate:: ;
AggregationKind = ak_composite:: ;
CallConcurrencyKind = cck_sequential:: ;
CallConcurrencyKind = cck_guarded:: ;
CallConcurrencyKind = cck_concurrent:: ;
ChangeableKind = ck_changeable:: ;
ChangeableKind = ck_frozen:: ;
ChangeableKind = ck_addOnly:: ;
OrderingKind = ok_unordered:: ;
OrderingKind = ok_ordered:: ;
ParameterDirectionKind = pdk_in:: ;
ParameterDirectionKind = pdk_inout:: ;
ParameterDirectionKind = pdk_out:: ;
ParameterDirectionKind = pdk_return:: ;
ScopeKind = sk_instance:: ;
ScopeKind = sk_classifier:: ;
VisibilityKind = vk_public:: ;
VisibilityKind = vk_protected:: ;
VisibilityKind = vk_private:: ;
VisibilityKind = vk_package:: ;
Multiplicity = range::MultiplicityRange+ ;
MultiplicityRange = multiplicity::Multiplicity lower::Integer upper::Integer ;
Expression = BooleanExpression ;
Expression = TypeExpression ;
Expression = MappingExpression ;
Expression = ProcedureExpression ;
Expression = ObjectSetExpression ;
Expression = ActionExpression ;
Expression = IterationExpression ;
Expression = TimeExpression ;
Expression = ArgListsExpression ;
Expression = language::String body::String ;
BooleanExpression = ;
TypeExpression = ;
MappingExpression = ;
ProcedureExpression = ;
ObjectSetExpression = ;
ActionExpression = ;
IterationExpression = ;
TimeExpression = ;
ArgListsExpression = ;
PseudostateKind = pk_choice:: ;
PseudostateKind = pk_deepHistory:: ;
PseudostateKind = pk_fork:: ;
PseudostateKind = pk_initial:: ;
PseudostateKind = pk_join:: ;
PseudostateKind = pk_junction:: ;
PseudostateKind = pk_shallowHistory:: ;
Instance = UseCaseInstance ;
Instance = Object ;
Instance = DataValue ;
Instance = ComponentInstance ;
Instance = NodeInstance ;
Instance = SubsystemInstance ;
Signal = Exception ;
Signal = Exception ;
Action = CreateAction ;
Action = DestroyAction ;
Action = UninterpretedAction ;
Action = CallAction ;
Action = SendAction ;
Action = ActionSequence ;
Action = ReturnAction ;
Action = TerminateAction ;
CreateAction = instantiation::Classifier ;
DestroyAction = actualArgument::Argument+ actionSequence::ActionSequence recurrence::IterationExpression target::ObjectSetExpression isAsynchronous::Boolean script::ActionExpression ;
UninterpretedAction = actualArgument::Argument+ actionSequence::ActionSequence recurrence::IterationExpression target::ObjectSetExpression isAsynchronous::Boolean script::ActionExpression ;
AttributeLink = instance::Instance value::Instance linkEnd::LinkEnd attribute::Attribute ;
Object = ownedInstance::Instance+ linkEnd::LinkEnd+ classifier::Classifier+ componentInstance::ComponentInstance slot::AttributeLink+ ownedLink::Link+ ;
Link = association::Association connection::LinkEnd ;
LinkObject = ;
DataValue = ownedInstance::Instance+ linkEnd::LinkEnd+ classifier::Classifier+ componentInstance::ComponentInstance slot::AttributeLink+ ownedLink::Link+ ;
CallAction = operation::Operation ;
SendAction = signal::Signal ;
ActionSequence = action::Action+ ;
Argument = action::Action value::Expression ;
Reception = signal::Signal specification::String isRoot::Boolean isLeaf::Boolean isAbstract::Boolean ;
LinkEnd = link::Link qualifiedValue::AttributeLink+ instance::Instance associationEnd::AssociationEnd ;
ReturnAction = actualArgument::Argument+ actionSequence::ActionSequence recurrence::IterationExpression target::ObjectSetExpression isAsynchronous::Boolean script::ActionExpression ;
TerminateAction = actualArgument::Argument+ actionSequence::ActionSequence recurrence::IterationExpression target::ObjectSetExpression isAsynchronous::Boolean script::ActionExpression ;
Stimulus = argument::Instance+ communicationLink::Link receiver::Instance dispatchAction::Action sender::Instance ;
Exception = ;
ComponentInstance = resident::Instance+ nodeInstance::NodeInstance ;
NodeInstance = resident::ComponentInstance+ ;
SubsystemInstance = ownedInstance::Instance+ linkEnd::LinkEnd+ classifier::Classifier+ componentInstance::ComponentInstance slot::AttributeLink+ ownedLink::Link+ ;
ActivityGraph = partition::Partition+ ;
Partition = contents::ModelElement+ activityGraph::ActivityGraph ;
SubactivityState = isDynamic::Boolean dynamicArguments::ArgListsExpression dynamicMultiplicity::Multiplicity ;
ActionState = CallState ;
ActionState = isDynamic::Boolean dynamicArguments::ArgListsExpression dynamicMultiplicity::Multiplicity ;
CallState = ;
ObjectFlowState = type::Classifier parameter::Parameter+ isSynch::Boolean ;
ClassifierInState = inState::State+ type::Classifier ;
StateMachine = ActivityGraph ;
StateMachine = context::ModelElement submachineState::SubmachineState+ top::State transitions::Transition+ ;
Event = TimeEvent ;
Event = CallEvent ;
Event = SignalEvent ;
Event = ChangeEvent ;
StateVertex = State ;
StateVertex = Pseudostate ;
StateVertex = SynchState ;
StateVertex = StubState ;
State = CompositeState ;
State = SimpleState ;
State = FinalState ;
TimeEvent = when::TimeExpression ;
CallEvent = operation::Operation ;
SignalEvent = signal::Signal ;
Transition = target::StateVertex trigger::Event stateMachine::StateMachine source::StateVertex effect::Action guard::Guard ;
CompositeState = SubmachineState ;
CompositeState = subvertex::StateVertex+ isConcurrent::Boolean ;
ChangeEvent = changeExpression::BooleanExpression ;
Guard = transition::Transition expression::BooleanExpression ;
Pseudostate = kind::PseudostateKind ;
SimpleState = ActionState ;
SimpleState = ObjectFlowState ;
SimpleState = ActionState ;
SimpleState = ObjectFlowState ;
SubmachineState = SubactivityState ;
SubmachineState = submachine::StateMachine ;
SynchState = bound::Integer ;
StubState = referenceState::String ;
FinalState = deferrableEvent::Event+ internalTransition::Transition+ exit::Action doActivity::Action entry::Action stateMachine::StateMachine ;
Point = x::Double y::Double ;
Dimension = width::Double height::Double ;
BezierPoint = base::Point control1::Point control2::Point ;
DiagramElement = GraphElement ;
DiagramElement = LeafElement ;
DiagramElement = Reference ;
GraphElement = GraphEdge ;
GraphElement = GraphNode ;
SemanticModelBridge = SimpleSemanticModelElement ;
SemanticModelBridge = Uml1SemanticModelBridge ;
SemanticModelBridge = CoreSemanticModelBridge ;
GraphEdge = anchor::GraphConnector waypoints::BezierPoint ;
GraphNode = Diagram ;
GraphNode = size::Dimension ;
GraphConnector = graphElement::GraphElement graphEdge::GraphEdge+ position::Point ;
LeafElement = TextElement ;
LeafElement = GraphicPrimitive ;
LeafElement = Image ;
Reference = referenced::DiagramElement ;
TextElement = text::String ;
GraphicPrimitive = Polyline ;
GraphicPrimitive = Ellipse ;
Polyline = waypoints::BezierPoint closed::Boolean ;
Ellipse = center::Point radiusX::Double radiusY::Double rotation::Double startAngle::Double endAngle::Double ;
Image = uri::String mimeType::String ;
Property = key::String value::String ;
SimpleSemanticModelElement = typeInfo::String ;
Uml1SemanticModelBridge = element::Element ;
CoreSemanticModelBridge = diagram::Diagram graphElement::GraphElement presentation::String ;
DiagramLink = graphElement::GraphElement diagram::Diagram zoom::Double viewport::Point ;
Diagram = owner::SemanticModelBridge diagramLink::DiagramLink+ name::String zoom::Double viewport::Point ;
Element = ModelElement ;
Element = PresentationElement ;
ModelElement = Message ;
ModelElement = Interaction ;
ModelElement = InteractionInstanceSet ;
ModelElement = CollaborationInstanceSet ;
ModelElement = ExtensionPoint ;
ModelElement = Instance ;
ModelElement = Action ;
ModelElement = AttributeLink ;
ModelElement = Link ;
ModelElement = Argument ;
ModelElement = LinkEnd ;
ModelElement = Stimulus ;
ModelElement = Partition ;
ModelElement = StateMachine ;
ModelElement = Event ;
ModelElement = StateVertex ;
ModelElement = Transition ;
ModelElement = Guard ;
ModelElement = GeneralizableElement ;
ModelElement = Namespace ;
ModelElement = Feature ;
ModelElement = AssociationEnd ;
ModelElement = Constraint ;
ModelElement = Relationship ;
ModelElement = Parameter ;
ModelElement = Comment ;
ModelElement = EnumerationLiteral ;
ModelElement = TagDefinition ;
ModelElement = TaggedValue ;
GeneralizableElement = Stereotype ;
Classifier = ClassifierRole ;
Classifier = UseCase ;
Classifier = Actor ;
Classifier = Signal ;
Classifier = ClassifierInState ;
Classifier = Class ;
Classifier = DataType ;
Classifier = Interface ;
Classifier = Component ;
Classifier = Node ;
Classifier = Artifact ;
Class = isActive::Boolean ;
DataType = Primitive ;
DataType = Enumeration ;
DataType = ProgrammingLanguageDataType ;
DataType = Primitive ;
DataType = Enumeration ;
DataType = ProgrammingLanguageDataType ;
Feature = StructuralFeature ;
Feature = BehavioralFeature ;
StructuralFeature = Attribute ;
AssociationEnd = AssociationEndRole ;
AssociationEnd = association::Association specification::Classifier+ participant::Classifier qualifier::Attribute+ isNavigable::Boolean ordering::OrderingKind aggregation::AggregationKind targetScope::ScopeKind multiplicity::Multiplicity changeability::ChangeableKind ;
Interface = powertypeRange::Generalization+ feature::Feature+ ;
Constraint = constrainedElement::ModelElement+ body::BooleanExpression ;
Relationship = Extend ;
Relationship = Include ;
Relationship = Generalization ;
Relationship = Dependency ;
Relationship = Flow ;
Association = AssociationRole ;
Association = connection::AssociationEnd ;
Attribute = associationEnd::AssociationEnd initialValue::Expression ;
BehavioralFeature = Reception ;
BehavioralFeature = Operation ;
BehavioralFeature = Method ;
Operation = concurrency::CallConcurrencyKind isRoot::Boolean isLeaf::Boolean isAbstract::Boolean specification::String ;
Parameter = type::Classifier behavioralFeature::BehavioralFeature defaultValue::Expression kind::ParameterDirectionKind ;
Method = specification::Operation body::ProcedureExpression ;
Generalization = parent::GeneralizableElement powertype::Classifier child::GeneralizableElement discriminator::String ;
AssociationClass = ;
Dependency = Abstraction ;
Dependency = Usage ;
Dependency = Binding ;
Dependency = Permission ;
Dependency = client::ModelElement+ supplier::ModelElement+ ;
Abstraction = mapping::MappingExpression ;
Usage = ;
Binding = argument::TemplateArgument+ ;
Component = deploymentLocation::Node+ residentElement::ElementResidence+ implementation::Artifact+ ;
Node = deployedComponent::Component+ ;
Permission = ;
Comment = annotatedElement::ModelElement+ body::String ;
Flow = source::ModelElement+ target::ModelElement+ ;
ElementResidence = container::Component resident::ModelElement visibility::VisibilityKind ;
TemplateParameter = template::ModelElement parameter::ModelElement defaultElement::ModelElement ;
Primitive = ;
Enumeration = literal::EnumerationLiteral+ ;
EnumerationLiteral = enumeration::Enumeration ;
Stereotype = stereotypeConstraint::Constraint+ definedTag::TagDefinition+ icon::String baseClass::String+ ;
TagDefinition = owner::Stereotype tagType::String multiplicity::Multiplicity ;
TaggedValue = type::TagDefinition referenceValue::ModelElement+ modelElement::ModelElement dataValue::String+ ;
ProgrammingLanguageDataType = expression::TypeExpression ;
Artifact = powertypeRange::Generalization+ feature::Feature+ ;
TemplateArgument = binding::Binding modelElement::ModelElement ;
Package = Model ;
Package = elementImport::ElementImport+ ;
Model = ;
Subsystem = isInstantiable::Boolean ;
ElementImport = package::Package importedElement::ModelElement visibility::VisibilityKind alias::String isSpecification::Boolean ;
