module Main

exports
  sorts
        Character Graphic-character Identifier Letter-or-digit Numeric-literal Decimal-literal Numeral Exponent Based-literal Base Based-numeral Extended-digit Character-literal String-literal String-element Comment Pragma Pragma-argument-association Basic-declaration Defining-identifier Type-declaration Full-type-declaration Type-definition Subtype-declaration Subtype-indication Subtype-mark Constraint Scalar-constraint Composite-constraint Object-declaration Defining-identifier-list Number-declaration Derived-type-definition Range-constraint Range Enumeration-type-definition Enumeration-literal-specification Defining-character-literal Integer-type-definition Signed-integer-type-definition Modular-type-definition Real-type-definition Floating-point-definition Real-range-specification Fixed-point-definition Ordinary-fixed-point-definition Decimal-fixed-point-definition Digits-constraint Array-type-definition Unconstrained-array-definition Index-subtype-definition Constrained-array-definition Discrete-subtype-definition Component-definition Index-constraint Discrete-range Discriminant-part Unknown-discriminant-part Known-discriminant-part Discriminant-specification Default-expression Discriminant-constraint Discriminant-association Record-type-definition Record-definition Component-list Component-item Component-declaration Variant-part Variant Discrete-choice-list Discrete-choice Record-extension-part Access-type-definition Access-to-object-definition General-access-modifier Access-to-subprogram-definition Access-definition Incomplete-type-declaration Declarative-part Declarative-item Basic-declarative-item Body Proper-body Name Direct-name Prefix Explicit-dereference Implicit-dereference Indexed-component Slice Selected-component Selector-name Attribute-reference Attribute-designator Range-attribute-reference Range-attribute-designator Aggregate Record-aggregate Record-component-association-list Record-component-association Component-choice-list Extension-aggregate Ancestor-part Array-aggregate Positional-array-aggregate Named-array-aggregate Array-component-association Expression Relation Simple-expression Term Factor Primary Logical-operator Relational-operator Binary-adding-operator Unary-adding-operator Multiplying-operator Highest-precedence-operator Type-conversion Qualified-expression Allocator Sequence-of-statements Statement Simple-statement Compound-statement Null-statement Label Statement-identifier Assignment-statement If-statement Condition Case-statement Case-statement-alternative Loop-statement Iteration-scheme Loop-parameter-specification Block-statement Exit-statement Goto-statement Subprogram-declaration Abstract-subprogram-declaration Subprogram-specification Designator Defining-designator Defining-program-unit-name Operator-symbol Defining-operator-symbol Parameter-profile Parameter-and-result-profile Formal-part Parameter-specification Mode Subprogram-body Procedure-call-statement Function-call Actual-parameter-part Parameter-association Explicit-actual-parameter Return-statement Package-declaration Package-specification Package-body Private-type-declaration Private-extension-declaration Use-clause Use-package-clause Use-type-clause Renaming-declaration Object-renaming-declaration Exception-renaming-declaration Package-renaming-declaration Subprogram-renaming-declaration Generic-renaming-declaration Task-type-declaration Single-task-declaration Task-definition Task-item Task-body Protected-type-declaration Single-protected-declaration Protected-definition Protected-operation-declaration Protected-element-declaration Protected-body Protected-operation-item Entry-declaration Accept-statement Entry-index Entry-body Entry-body-formal-part Entry-barrier Entry-index-specification Entry-call-statement Requeue-statement Delay-statement Delay-until-statement Delay-relative-statement Select-statement Selective-accept Guard Select-alternative Accept-alternative Delay-alternative Terminate-alternative Timed-entry-call Entry-call-alternative Triggering-alternative Triggering-statement Abortable-part Abort-statement Compilation Compilation-unit Library-item Library-unit-declaration Library-unit-renaming-declaration Library-unit-body Parent-unit-name Context-clause Context-item With-clause Body-stub Subprogram-body-stub Conditional-entry-call Asynchronous-select Package-body-stub Task-body-stub Protected-body-stub Subunit Exception-declaration Handled-sequence-of-statements Exception-handler Choice-parameter-specification Exception-choice Raise-statement Generic-declaration Generic-subprogram-declaration Generic-package-declaration Generic-formal-part Generic-formal-parameter-declaration Generic-instantiation Generic-actual-part Generic-association Explicit-generic-actual-parameter Formal-object-declaration Formal-type-declaration Formal-type-definition Formal-private-type-definition Formal-derived-type-definition Formal-discrete-type-definition Formal-signed-integer-type-definition Formal-modular-type-definition Formal-floating-point-definition Formal-ordinary-fixed-point-definition Formal-decimal-fixed-point-definition Formal-array-type-definition Formal-access-type-definition Formal-subprogram-declaration Subprogram-default Default-name Formal-package-declaration Formal-package-actual-part Aspect-clause Local-name Attribute-definition-clause Enumeration-representation-clause Enumeration-aggregate Record-representation-clause Component-clause Position First-bit Last-bit Code-statement Restriction Delta-constraint At-clause Mod-clause 
  context-free syntax
        Graphic-character -> Character
        Format-effector -> Character
        Other-control-function -> Character

        Identifier-letter -> Graphic-character
        Digit -> Graphic-character
        Space-character -> Graphic-character
        Special-character -> Graphic-character

        Identifier-letter (Underline? Letter-or-digit)* -> Identifier

        Identifier-letter -> Letter-or-digit
        Digit -> Letter-or-digit

        Decimal-literal -> Numeric-literal
        Based-literal -> Numeric-literal

        Numeral ("." Numeral)? Exponent? -> Decimal-literal

        Digit (Underline? Digit)* -> Numeral

        "E" "+"? Numeral -> Exponent
        "E" "-" Numeral -> Exponent

        Base "#" Based-numeral ("." Based-numeral)? "#" Exponent? -> Based-literal

        Numeral -> Base

        Extended-digit (Underline? Extended-digit)* -> Based-numeral

        Digit -> Extended-digit
        "A" -> Extended-digit
        "B" -> Extended-digit
        "C" -> Extended-digit
        "D" -> Extended-digit
        "E" -> Extended-digit
        "F" -> Extended-digit

        "'" Graphic-character "'" -> Character-literal

        """ String-element* """ -> String-literal

        """" -> String-element
        Non-quotation-mark-graphic-character -> String-element

        "-" "-" Non-end-of-line-character* -> Comment

        "pragma" Identifier ("(" Pragma-argument-association ("," Pragma-argument-association)* ")")? ";" -> Pragma

        (Pragma-argument-identifier "=>")? Name -> Pragma-argument-association
        (Pragma-argument-identifier "=>")? Expression -> Pragma-argument-association

        Type-declaration -> Basic-declaration
        Object-declaration -> Basic-declaration
        Subprogram-declaration -> Basic-declaration
        Package-declaration -> Basic-declaration
        Exception-declaration -> Basic-declaration
        Generic-instantiation -> Basic-declaration
        Subtype-declaration -> Basic-declaration
        Number-declaration -> Basic-declaration
        Abstract-subprogram-declaration -> Basic-declaration
        Renaming-declaration -> Basic-declaration
        Generic-declaration -> Basic-declaration

        Identifier -> Defining-identifier

        Full-type-declaration -> Type-declaration
        Incomplete-type-declaration -> Type-declaration
        Private-type-declaration -> Type-declaration
        Private-extension-declaration -> Type-declaration

        "type" Defining-identifier Known-discriminant-part? "is" Type-definition ";" -> Full-type-declaration
        Task-type-declaration -> Full-type-declaration
        Protected-type-declaration -> Full-type-declaration

        Enumeration-type-definition -> Type-definition
        Real-type-definition -> Type-definition
        Record-type-definition -> Type-definition
        Derived-type-definition -> Type-definition
        Integer-type-definition -> Type-definition
        Array-type-definition -> Type-definition
        Access-type-definition -> Type-definition

        "subtype" Defining-identifier "is" Subtype-indication ";" -> Subtype-declaration

        Subtype-mark Constraint? -> Subtype-indication

        Subtype-name -> Subtype-mark

        Scalar-constraint -> Constraint
        Composite-constraint -> Constraint

        Range-constraint -> Scalar-constraint
        Digits-constraint -> Scalar-constraint
        Delta-constraint -> Scalar-constraint

        Index-constraint -> Composite-constraint
        Discriminant-constraint -> Composite-constraint

        Defining-identifier-list ":" "aliased"? "constant"? Subtype-indication (":=" Expression)? ";" -> Object-declaration
        Defining-identifier-list ":" "aliased"? "constant"? Array-type-definition (":=" Expression)? ";" -> Object-declaration
        Single-task-declaration -> Object-declaration
        Single-protected-declaration -> Object-declaration

        Defining-identifier ("," Defining-identifier)* -> Defining-identifier-list

        Defining-identifier-list ":" "constant" ":=" Static-expression ";" -> Number-declaration

        "abstract"? "new" Parent-subtype-indication Record-extension-part? -> Derived-type-definition

        "range" Range -> Range-constraint

        Range-attribute-reference -> Range
        Simple-expression ".." Simple-expression -> Range

        "(" Enumeration-literal-specification ("," Enumeration-literal-specification)* ")" -> Enumeration-type-definition

        Defining-identifier -> Enumeration-literal-specification
        Defining-character-literal -> Enumeration-literal-specification

        Character-literal -> Defining-character-literal

        Signed-integer-type-definition -> Integer-type-definition
        Modular-type-definition -> Integer-type-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Signed-integer-type-definition

        "mod" Static-expression -> Modular-type-definition

        Floating-point-definition -> Real-type-definition
        Fixed-point-definition -> Real-type-definition

        "digits" Static-expression Real-range-specification? -> Floating-point-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Real-range-specification

        Ordinary-fixed-point-definition -> Fixed-point-definition
        Decimal-fixed-point-definition -> Fixed-point-definition

        "delta" Static-expression Real-range-specification -> Ordinary-fixed-point-definition

        "delta" Static-expression "digits" Static-expression Real-range-specification? -> Decimal-fixed-point-definition

        "digits" Static-expression Range-constraint? -> Digits-constraint

        Unconstrained-array-definition -> Array-type-definition
        Constrained-array-definition -> Array-type-definition

        "array" "(" Index-subtype-definition ("," Index-subtype-definition)* ")" "of" Component-definition -> Unconstrained-array-definition

        Subtype-mark "range" "<>" -> Index-subtype-definition

        "array" "(" Discrete-subtype-definition ("," Discrete-subtype-definition)* ")" "of" Component-definition -> Constrained-array-definition

        Discrete-subtype-indication -> Discrete-subtype-definition
        Range -> Discrete-subtype-definition

        "aliased"? Subtype-indication -> Component-definition

        "(" Discrete-range ("," Discrete-range)* ")" -> Index-constraint

        Discrete-subtype-indication -> Discrete-range
        Range -> Discrete-range

        Unknown-discriminant-part -> Discriminant-part
        Known-discriminant-part -> Discriminant-part

        "(<>)" -> Unknown-discriminant-part

        "(" Discriminant-specification (";" Discriminant-specification)* ")" -> Known-discriminant-part

        Defining-identifier-list ":" Subtype-mark (":=" Default-expression)? -> Discriminant-specification
        Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Discriminant-specification

        Expression -> Default-expression

        "(" Discriminant-association ("," Discriminant-association)* ")" -> Discriminant-constraint

        (Discriminant-selector-name ("|" Discriminant-selector-name)* "=>")? Expression -> Discriminant-association

        ("abstract"? "tagged")? "limited"? Record-definition -> Record-type-definition

        "record" Component-list "end" "record" -> Record-definition
        "null" "record" -> Record-definition

        Component-item Component-item* -> Component-list
        Component-item* Variant-part -> Component-list
        "null" ";" -> Component-list

        Component-declaration -> Component-item
        Aspect-clause -> Component-item

        Defining-identifier-list ":" Component-definition (":=" Default-expression)? ";" -> Component-declaration

        "case" Discriminant-direct-name "is" Variant+ "end" "case" ";" -> Variant-part

        "when" Discrete-choice-list "=>" Component-list -> Variant

        Discrete-choice ("|" Discrete-choice)* -> Discrete-choice-list

        Expression -> Discrete-choice
        Discrete-range -> Discrete-choice
        "others" -> Discrete-choice

        "with" Record-definition -> Record-extension-part

        Access-to-object-definition -> Access-type-definition
        Access-to-subprogram-definition -> Access-type-definition

        "access" General-access-modifier? Subtype-indication -> Access-to-object-definition

        "all" -> General-access-modifier
        "constant" -> General-access-modifier

        "access" "protected"? "procedure" Parameter-profile -> Access-to-subprogram-definition
        "access" "protected"? "function" Parameter-and-result-profile -> Access-to-subprogram-definition

        "access" Subtype-mark -> Access-definition

        "type" Defining-identifier Discriminant-part? ";" -> Incomplete-type-declaration

        Declarative-item* -> Declarative-part

        Basic-declarative-item -> Declarative-item
        Body -> Declarative-item

        Basic-declaration -> Basic-declarative-item
        Aspect-clause -> Basic-declarative-item
        Use-clause -> Basic-declarative-item

        Proper-body -> Body
        Body-stub -> Body

        Subprogram-body -> Proper-body
        Package-body -> Proper-body
        Task-body -> Proper-body
        Protected-body -> Proper-body

        Direct-name -> Name
        Indexed-component -> Name
        Selected-component -> Name
        Type-conversion -> Name
        Character-literal -> Name
        Explicit-dereference -> Name
        Slice -> Name
        Attribute-reference -> Name
        Function-call -> Name

        Identifier -> Direct-name
        Operator-symbol -> Direct-name

        Name -> Prefix
        Implicit-dereference -> Prefix

        Name "." "all" -> Explicit-dereference

        Name -> Implicit-dereference

        Prefix "(" Expression ("," Expression)* ")" -> Indexed-component

        Prefix "(" Discrete-range ")" -> Slice

        Prefix "." Selector-name -> Selected-component

        Identifier -> Selector-name
        Character-literal -> Selector-name
        Operator-symbol -> Selector-name

        Prefix "'" Attribute-designator -> Attribute-reference

        Identifier ("(" Static-expression ")")? -> Attribute-designator
        "Access" -> Attribute-designator
        "Delta" -> Attribute-designator
        "Digits" -> Attribute-designator

        Prefix "'" Range-attribute-designator -> Range-attribute-reference

        "Range" ("(" Static-expression ")")? -> Range-attribute-designator

        Record-aggregate -> Aggregate
        Extension-aggregate -> Aggregate
        Array-aggregate -> Aggregate

        "(" Record-component-association-list ")" -> Record-aggregate

        Record-component-association ("," Record-component-association)* -> Record-component-association-list
        "null" "record" -> Record-component-association-list

        (Component-choice-list "=>")? Expression -> Record-component-association

        Component-selector-name ("|" Component-selector-name)* -> Component-choice-list
        "others" -> Component-choice-list

        "(" Ancestor-part "with" Record-component-association-list ")" -> Extension-aggregate

        Expression -> Ancestor-part
        Subtype-mark -> Ancestor-part

        Positional-array-aggregate -> Array-aggregate
        Named-array-aggregate -> Array-aggregate

        "(" Expression "," Expression ("," Expression)* ")" -> Positional-array-aggregate
        "(" Expression ("," Expression)* "," "others" "=>" Expression ")" -> Positional-array-aggregate

        "(" Array-component-association ("," Array-component-association)* ")" -> Named-array-aggregate

        Discrete-choice-list "=>" Expression -> Array-component-association

        Relation ("and" Relation)* -> Expression
        Relation ("or" Relation)* -> Expression
        Relation ("xor" Relation)* -> Expression
        Relation ("and" "then" Relation)* -> Expression
        Relation ("or" "else" Relation)* -> Expression

        Simple-expression (Relational-operator Simple-expression)? -> Relation
        Simple-expression "not"? "in" Range -> Relation
        Simple-expression "not"? "in" Subtype-mark -> Relation

        Unary-adding-operator? Term (Binary-adding-operator Term)* -> Simple-expression

        Factor (Multiplying-operator Factor)* -> Term

        Primary ("**" Primary)? -> Factor
        "abs" Primary -> Factor
        "not" Primary -> Factor

        Numeric-literal -> Primary
        "null" -> Primary
        String-literal -> Primary
        Aggregate -> Primary
        Name -> Primary
        Qualified-expression -> Primary
        Allocator -> Primary
        "(" Expression ")" -> Primary

        "and" -> Logical-operator
        "or" -> Logical-operator
        "xor" -> Logical-operator

        "=" -> Relational-operator
        "/=" -> Relational-operator
        "<" -> Relational-operator
        "<=" -> Relational-operator
        ">" -> Relational-operator
        ">=" -> Relational-operator

        "+" -> Binary-adding-operator
        "-" -> Binary-adding-operator
        "&" -> Binary-adding-operator

        "+" -> Unary-adding-operator
        "-" -> Unary-adding-operator

        "*" -> Multiplying-operator
        "/" -> Multiplying-operator
        "mod" -> Multiplying-operator
        "rem" -> Multiplying-operator

        "**" -> Highest-precedence-operator
        "abs" -> Highest-precedence-operator
        "not" -> Highest-precedence-operator

        Subtype-mark "(" Expression ")" -> Type-conversion
        Subtype-mark "(" Name ")" -> Type-conversion

        Subtype-mark "'(" Expression ")" -> Qualified-expression
        Subtype-mark "'" Aggregate -> Qualified-expression

        "new" Subtype-indication -> Allocator
        "new" Qualified-expression -> Allocator

        Statement Statement* -> Sequence-of-statements

        Label* Simple-statement -> Statement
        Label* Compound-statement -> Statement

        Null-statement -> Simple-statement
        Assignment-statement -> Simple-statement
        Goto-statement -> Simple-statement
        Return-statement -> Simple-statement
        Requeue-statement -> Simple-statement
        Abort-statement -> Simple-statement
        Code-statement -> Simple-statement
        Exit-statement -> Simple-statement
        Procedure-call-statement -> Simple-statement
        Entry-call-statement -> Simple-statement
        Delay-statement -> Simple-statement
        Raise-statement -> Simple-statement

        If-statement -> Compound-statement
        Loop-statement -> Compound-statement
        Accept-statement -> Compound-statement
        Case-statement -> Compound-statement
        Block-statement -> Compound-statement
        Select-statement -> Compound-statement

        "null" ";" -> Null-statement

        "<<" Label-statement-identifier ">>" -> Label

        Direct-name -> Statement-identifier

        Variable-name ":=" Expression ";" -> Assignment-statement

        "if" Condition "then" Sequence-of-statements ("elsif" Condition "then" Sequence-of-statements)* ("else" Sequence-of-statements)? "end" "if" ";" -> If-statement

        Boolean-expression -> Condition

        "case" Expression "is" Case-statement-alternative Case-statement-alternative* "end" "case" ";" -> Case-statement

        "when" Discrete-choice-list "=>" Sequence-of-statements -> Case-statement-alternative

        (Loop-statement-identifier ":")? Iteration-scheme? "loop" Sequence-of-statements "end" "loop" Loop-identifier? ";" -> Loop-statement

        "while" Condition -> Iteration-scheme
        "for" Loop-parameter-specification -> Iteration-scheme

        Defining-identifier "in" "reverse"? Discrete-subtype-definition -> Loop-parameter-specification

        (Block-statement-identifier ":")? ("declare" Declarative-part)? "begin" Handled-sequence-of-statements "end" Block-identifier? ";" -> Block-statement

        "exit" Loop-name? ("when" Condition)? ";" -> Exit-statement

        "goto" Label-name ";" -> Goto-statement

        Subprogram-specification ";" -> Subprogram-declaration

        Subprogram-specification "is" "abstract" ";" -> Abstract-subprogram-declaration

        "procedure" Defining-program-unit-name Parameter-profile -> Subprogram-specification
        "function" Defining-designator Parameter-and-result-profile -> Subprogram-specification

        (Parent-unit-name ".")? Identifier -> Designator
        Operator-symbol -> Designator

        Defining-program-unit-name -> Defining-designator
        Defining-operator-symbol -> Defining-designator

        (Parent-unit-name ".")? Defining-identifier -> Defining-program-unit-name

        String-literal -> Operator-symbol

        Operator-symbol -> Defining-operator-symbol

        Formal-part? -> Parameter-profile

        Formal-part? "return" Subtype-mark -> Parameter-and-result-profile

        "(" Parameter-specification (";" Parameter-specification)* ")" -> Formal-part

        Defining-identifier-list ":" Mode Subtype-mark (":=" Default-expression)? -> Parameter-specification
        Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Parameter-specification

        "in"? -> Mode
        "in" "out" -> Mode
        "out" -> Mode

        Subprogram-specification "is" Declarative-part "begin" Handled-sequence-of-statements "end" Designator? ";" -> Subprogram-body

        Procedure-name ";" -> Procedure-call-statement
        Procedure-prefix Actual-parameter-part ";" -> Procedure-call-statement

        Function-name -> Function-call
        Function-prefix Actual-parameter-part -> Function-call

        "(" Parameter-association ("," Parameter-association)* ")" -> Actual-parameter-part

        (Formal-parameter-selector-name "=>")? Explicit-actual-parameter -> Parameter-association

        Expression -> Explicit-actual-parameter
        Variable-name -> Explicit-actual-parameter

        "return" Expression? ";" -> Return-statement

        Package-specification ";" -> Package-declaration

        "package" Defining-program-unit-name "is" Basic-declarative-item* ("private" Basic-declarative-item*)? "end" ((Parent-unit-name ".")? Identifier)? -> Package-specification

        "package" "body" Defining-program-unit-name "is" Declarative-part ("begin" Handled-sequence-of-statements)? "end" ((Parent-unit-name ".")? Identifier)? ";" -> Package-body

        "type" Defining-identifier Discriminant-part? "is" ("abstract"? "tagged")? "limited"? "private" ";" -> Private-type-declaration

        "type" Defining-identifier Discriminant-part? "is" "abstract"? "new" Ancestor-subtype-indication "with" "private" ";" -> Private-extension-declaration

        Use-package-clause -> Use-clause
        Use-type-clause -> Use-clause

        "use" Package-name ("," Package-name)* ";" -> Use-package-clause

        "use" "type" Subtype-mark ("," Subtype-mark)* ";" -> Use-type-clause

        Object-renaming-declaration -> Renaming-declaration
        Exception-renaming-declaration -> Renaming-declaration
        Package-renaming-declaration -> Renaming-declaration
        Subprogram-renaming-declaration -> Renaming-declaration
        Generic-renaming-declaration -> Renaming-declaration

        Defining-identifier ":" Subtype-mark "renames" Object-name ";" -> Object-renaming-declaration

        Defining-identifier ":" "exception" "renames" Exception-name ";" -> Exception-renaming-declaration

        "package" Defining-program-unit-name "renames" Package-name ";" -> Package-renaming-declaration

        Subprogram-specification "renames" Callable-entity-name ";" -> Subprogram-renaming-declaration

        "generic" "package" Defining-program-unit-name "renames" Generic-package-name ";" -> Generic-renaming-declaration
        "generic" "procedure" Defining-program-unit-name "renames" Generic-procedure-name ";" -> Generic-renaming-declaration
        "generic" "function" Defining-program-unit-name "renames" Generic-function-name ";" -> Generic-renaming-declaration

        "task" "type" Defining-identifier Known-discriminant-part? ("is" Task-definition)? ";" -> Task-type-declaration

        "task" Defining-identifier ("is" Task-definition)? ";" -> Single-task-declaration

        Task-item* ("private" Task-item*)? "end" Task-identifier? -> Task-definition

        Entry-declaration -> Task-item
        Aspect-clause -> Task-item

        "task" "body" Defining-identifier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Task-identifier? ";" -> Task-body

        "protected" "type" Defining-identifier Known-discriminant-part? "is" Protected-definition ";" -> Protected-type-declaration

        "protected" Defining-identifier "is" Protected-definition ";" -> Single-protected-declaration

        Protected-operation-declaration* ("private" Protected-element-declaration*)? "end" Protected-identifier? -> Protected-definition

        Subprogram-declaration -> Protected-operation-declaration
        Entry-declaration -> Protected-operation-declaration
        Aspect-clause -> Protected-operation-declaration

        Protected-operation-declaration -> Protected-element-declaration
        Component-declaration -> Protected-element-declaration

        "protected" "body" Defining-identifier "is" Protected-operation-item* "end" Protected-identifier? ";" -> Protected-body

        Subprogram-declaration -> Protected-operation-item
        Subprogram-body -> Protected-operation-item
        Entry-body -> Protected-operation-item
        Aspect-clause -> Protected-operation-item

        "entry" Defining-identifier ("(" Discrete-subtype-definition ")")? Parameter-profile ";" -> Entry-declaration

        "accept" Entry-direct-name ("(" Entry-index ")")? Parameter-profile ("do" Handled-sequence-of-statements "end" Entry-identifier?)? ";" -> Accept-statement

        Expression -> Entry-index

        "entry" Defining-identifier Entry-body-formal-part Entry-barrier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Entry-identifier? ";" -> Entry-body

        ("(" Entry-index-specification ")")? Parameter-profile -> Entry-body-formal-part

        "when" Condition -> Entry-barrier

        "for" Defining-identifier "in" Discrete-subtype-definition -> Entry-index-specification

        Entry-name Actual-parameter-part? ";" -> Entry-call-statement

        "requeue" Entry-name ("with" "abort")? ";" -> Requeue-statement

        Delay-until-statement -> Delay-statement
        Delay-relative-statement -> Delay-statement

        "delay" "until" Delay-expression ";" -> Delay-until-statement

        "delay" Delay-expression ";" -> Delay-relative-statement

        Selective-accept -> Select-statement
        Timed-entry-call -> Select-statement
        Conditional-entry-call -> Select-statement
        Asynchronous-select -> Select-statement

        "select" Guard? Select-alternative ("or" Guard? Select-alternative)* ("else" Sequence-of-statements)? "end" "select" ";" -> Selective-accept

        "when" Condition "=>" -> Guard

        Accept-alternative -> Select-alternative
        Delay-alternative -> Select-alternative
        Terminate-alternative -> Select-alternative

        Accept-statement Sequence-of-statements? -> Accept-alternative

        Delay-statement Sequence-of-statements? -> Delay-alternative

        "terminate" ";" -> Terminate-alternative

        "select" Entry-call-alternative "or" Delay-alternative "end" "select" ";" -> Timed-entry-call

        Entry-call-statement Sequence-of-statements? -> Entry-call-alternative

        Triggering-statement Sequence-of-statements? -> Triggering-alternative

        Entry-call-statement -> Triggering-statement
        Delay-statement -> Triggering-statement

        Sequence-of-statements -> Abortable-part

        "abort" Task-name ("," Task-name)* ";" -> Abort-statement

        Compilation-unit* -> Compilation

        Context-clause Library-item -> Compilation-unit
        Context-clause Subunit -> Compilation-unit

        "private"? Library-unit-declaration -> Library-item
        Library-unit-body -> Library-item
        "private"? Library-unit-renaming-declaration -> Library-item

        Subprogram-declaration -> Library-unit-declaration
        Package-declaration -> Library-unit-declaration
        Generic-declaration -> Library-unit-declaration
        Generic-instantiation -> Library-unit-declaration

        Package-renaming-declaration -> Library-unit-renaming-declaration
        Generic-renaming-declaration -> Library-unit-renaming-declaration
        Subprogram-renaming-declaration -> Library-unit-renaming-declaration

        Subprogram-body -> Library-unit-body
        Package-body -> Library-unit-body

        Name -> Parent-unit-name

        Context-item* -> Context-clause

        With-clause -> Context-item
        Use-clause -> Context-item

        "with" Library-unit-name ("," Library-unit-name)* ";" -> With-clause

        Subprogram-body-stub -> Body-stub
        Package-body-stub -> Body-stub
        Task-body-stub -> Body-stub
        Protected-body-stub -> Body-stub

        Subprogram-specification "is" "separate" ";" -> Subprogram-body-stub

        "select" Entry-call-alternative "else" Sequence-of-statements "end" "select" ";" -> Conditional-entry-call

        "select" Triggering-alternative "then" "abort" Abortable-part "end" "select" ";" -> Asynchronous-select

        "package" "body" Defining-identifier "is" "separate" ";" -> Package-body-stub

        "task" "body" Defining-identifier "is" "separate" ";" -> Task-body-stub

        "protected" "body" Defining-identifier "is" "separate" ";" -> Protected-body-stub

        "separate" "(" Parent-unit-name ")" Proper-body -> Subunit

        Defining-identifier-list ":" "exception" ";" -> Exception-declaration

        Sequence-of-statements ("exception" Exception-handler Exception-handler*)? -> Handled-sequence-of-statements

        "when" (Choice-parameter-specification ":")? Exception-choice ("|" Exception-choice)* "=>" Sequence-of-statements -> Exception-handler

        Defining-identifier -> Choice-parameter-specification

        Exception-name -> Exception-choice
        "others" -> Exception-choice

        "raise" Exception-name? ";" -> Raise-statement

        Generic-subprogram-declaration -> Generic-declaration
        Generic-package-declaration -> Generic-declaration

        Generic-formal-part Subprogram-specification ";" -> Generic-subprogram-declaration

        Generic-formal-part Package-specification ";" -> Generic-package-declaration

        "generic" (Generic-formal-parameter-declaration | Use-clause)* -> Generic-formal-part

        Formal-object-declaration -> Generic-formal-parameter-declaration
        Formal-type-declaration -> Generic-formal-parameter-declaration
        Formal-subprogram-declaration -> Generic-formal-parameter-declaration
        Formal-package-declaration -> Generic-formal-parameter-declaration

        "package" Defining-program-unit-name "is" "new" Generic-package-name Generic-actual-part? ";" -> Generic-instantiation
        "procedure" Defining-program-unit-name "is" "new" Generic-procedure-name Generic-actual-part? ";" -> Generic-instantiation
        "function" Defining-designator "is" "new" Generic-function-name Generic-actual-part? ";" -> Generic-instantiation

        "(" Generic-association ("," Generic-association)* ")" -> Generic-actual-part

        (Generic-formal-parameter-selector-name "=>")? Explicit-generic-actual-parameter -> Generic-association

        Expression -> Explicit-generic-actual-parameter
        Variable-name -> Explicit-generic-actual-parameter
        Subprogram-name -> Explicit-generic-actual-parameter
        Entry-name -> Explicit-generic-actual-parameter
        Subtype-mark -> Explicit-generic-actual-parameter
        Package-instance-name -> Explicit-generic-actual-parameter

        Defining-identifier-list ":" Mode Subtype-mark (":=" Default-expression)? ";" -> Formal-object-declaration

        "type" Defining-identifier Discriminant-part? "is" Formal-type-definition ";" -> Formal-type-declaration

        Formal-private-type-definition -> Formal-type-definition
        Formal-derived-type-definition -> Formal-type-definition
        Formal-discrete-type-definition -> Formal-type-definition
        Formal-signed-integer-type-definition -> Formal-type-definition
        Formal-modular-type-definition -> Formal-type-definition
        Formal-floating-point-definition -> Formal-type-definition
        Formal-ordinary-fixed-point-definition -> Formal-type-definition
        Formal-decimal-fixed-point-definition -> Formal-type-definition
        Formal-array-type-definition -> Formal-type-definition
        Formal-access-type-definition -> Formal-type-definition

        ("abstract"? "tagged")? "limited"? "private" -> Formal-private-type-definition

        "abstract"? "new" Subtype-mark ("with" "private")? -> Formal-derived-type-definition

        "(<>)" -> Formal-discrete-type-definition

        "range" "<>" -> Formal-signed-integer-type-definition

        "mod" "<>" -> Formal-modular-type-definition

        "digits" "<>" -> Formal-floating-point-definition

        "delta" "<>" -> Formal-ordinary-fixed-point-definition

        "delta" "<>" "digits" "<>" -> Formal-decimal-fixed-point-definition

        Array-type-definition -> Formal-array-type-definition

        Access-type-definition -> Formal-access-type-definition

        "with" Subprogram-specification ("is" Subprogram-default)? ";" -> Formal-subprogram-declaration

        Default-name -> Subprogram-default
        "<>" -> Subprogram-default

        Name -> Default-name

        "with" "package" Defining-identifier "is" "new" Generic-package-name Formal-package-actual-part ";" -> Formal-package-declaration

        "(<>)" -> Formal-package-actual-part
        Generic-actual-part? -> Formal-package-actual-part

        Attribute-definition-clause -> Aspect-clause
        Enumeration-representation-clause -> Aspect-clause
        Record-representation-clause -> Aspect-clause
        At-clause -> Aspect-clause

        Direct-name -> Local-name
        Direct-name "'" Attribute-designator -> Local-name
        Library-unit-name -> Local-name

        "for" Local-name "'" Attribute-designator "use" Expression ";" -> Attribute-definition-clause
        "for" Local-name "'" Attribute-designator "use" Name ";" -> Attribute-definition-clause

        "for" First-subtype-local-name "use" Enumeration-aggregate ";" -> Enumeration-representation-clause

        Array-aggregate -> Enumeration-aggregate

        "for" First-subtype-local-name "use" "record" Mod-clause? Component-clause* "end" "record" ";" -> Record-representation-clause

        Component-local-name "at" Position "range" First-bit ".." Last-bit ";" -> Component-clause

        Static-expression -> Position

        Static-simple-expression -> First-bit

        Static-simple-expression -> Last-bit

        Qualified-expression ";" -> Code-statement

        Restriction-identifier -> Restriction
        Restriction-parameter-identifier "=>" Expression -> Restriction

        "delta" Static-expression Range-constraint? -> Delta-constraint

        "for" Direct-name "use" "at" Expression ";" -> At-clause

        "at" "mod" Static-expression ";" -> Mod-clause
