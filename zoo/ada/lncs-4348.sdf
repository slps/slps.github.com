module Main

exports
  sorts
        Identifier Identifier-start Identifier-extend Numeric-literal Decimal-literal Numeral Exponent Digit Based-literal Base Based-numeral Extended-digit Character-literal String-literal String-element Comment Pragma Pragma-argument-association Basic-declaration Defining-identifier Type-declaration Full-type-declaration Type-definition Subtype-declaration Subtype-indication Subtype-mark Constraint Scalar-constraint Composite-constraint Object-declaration Defining-identifier-list Number-declaration Derived-type-definition Range-constraint Range Enumeration-type-definition Enumeration-literal-specification Defining-character-literal Integer-type-definition Signed-integer-type-definition Modular-type-definition Real-type-definition Floating-point-definition Real-range-specification Fixed-point-definition Ordinary-fixed-point-definition Decimal-fixed-point-definition Digits-constraint Array-type-definition Unconstrained-array-definition Index-subtype-definition Constrained-array-definition Discrete-subtype-definition Component-definition Index-constraint Discrete-range Discriminant-part Unknown-discriminant-part Known-discriminant-part Discriminant-specification Default-expression Discriminant-constraint Discriminant-association Record-type-definition Record-definition Component-list Component-item Component-declaration Variant-part Variant Discrete-choice-list Discrete-choice Record-extension-part Abstract-subprogram-declaration Interface-type-definition Interface-list Access-type-definition Access-to-object-definition General-access-modifier Access-to-subprogram-definition Null-exclusion Access-definition Incomplete-type-declaration Declarative-part Declarative-item Basic-declarative-item Body Proper-body Name Direct-name Prefix Explicit-dereference Implicit-dereference Indexed-component Slice Selected-component Selector-name Attribute-reference Attribute-designator Range-attribute-reference Range-attribute-designator Aggregate Record-aggregate Record-component-association-list Record-component-association Component-choice-list Extension-aggregate Ancestor-part Array-aggregate Positional-array-aggregate Named-array-aggregate Array-component-association Expression Relation Simple-expression Term Factor Primary Logical-operator Relational-operator Binary-adding-operator Unary-adding-operator Multiplying-operator Highest-precedence-operator Type-conversion Qualified-expression Allocator Sequence-of-statements Statement Simple-statement Compound-statement Null-statement Label Statement-identifier Assignment-statement If-statement Condition Case-statement Case-statement-alternative Loop-statement Iteration-scheme Loop-parameter-specification Block-statement Exit-statement Goto-statement Subprogram-declaration Subprogram-specification Procedure-specification Function-specification Designator Defining-designator Defining-program-unit-name Operator-symbol Defining-operator-symbol Parameter-profile Parameter-and-result-profile Formal-part Parameter-specification Mode Subprogram-body Procedure-call-statement Function-call Actual-parameter-part Parameter-association Explicit-actual-parameter Simple-return-statement Extended-return-statement Return-subtype-indication Null-procedure-declaration Package-declaration Package-specification Package-body Private-type-declaration Private-extension-declaration Overriding-indicator Use-clause Use-package-clause Use-type-clause Renaming-declaration Object-renaming-declaration Exception-renaming-declaration Package-renaming-declaration Subprogram-renaming-declaration Generic-renaming-declaration Task-type-declaration Single-task-declaration Task-definition Task-item Task-body Protected-type-declaration Single-protected-declaration Protected-definition Protected-operation-declaration Protected-element-declaration Protected-body Protected-operation-item Entry-declaration Accept-statement Entry-index Entry-body Entry-body-formal-part Entry-barrier Entry-index-specification Entry-call-statement Requeue-statement Delay-statement Delay-until-statement Delay-relative-statement Select-statement Selective-accept Guard Select-alternative Accept-alternative Delay-alternative Terminate-alternative Timed-entry-call Entry-call-alternative Procedure-or-entry-call Conditional-entry-call Asynchronous-select Triggering-alternative Triggering-statement Abortable-part Abort-statement Compilation Compilation-unit Library-item Library-unit-declaration Library-unit-renaming-declaration Library-unit-body Parent-unit-name Context-clause Context-item With-clause Limited-with-clause Nonlimited-with-clause Body-stub Subprogram-body-stub Package-body-stub Task-body-stub Protected-body-stub Subunit Exception-declaration Handled-sequence-of-statements Exception-handler Choice-parameter-specification Exception-choice Raise-statement Generic-declaration Generic-subprogram-declaration Generic-package-declaration Generic-formal-part Generic-formal-parameter-declaration Generic-instantiation Generic-actual-part Generic-association Explicit-generic-actual-parameter Formal-object-declaration Formal-type-declaration Formal-type-definition Formal-private-type-definition Formal-derived-type-definition Formal-discrete-type-definition Formal-signed-integer-type-definition Formal-modular-type-definition Formal-floating-point-definition Formal-ordinary-fixed-point-definition Formal-decimal-fixed-point-definition Formal-array-type-definition Formal-access-type-definition Formal-interface-type-definition Formal-subprogram-declaration Formal-concrete-subprogram-declaration Formal-abstract-subprogram-declaration Subprogram-default Default-name Formal-package-declaration Formal-package-actual-part Formal-package-association Aspect-clause Local-name Attribute-definition-clause Enumeration-representation-clause Enumeration-aggregate Record-representation-clause Component-clause Position First-bit Last-bit Code-statement Restriction Restriction-parameter-argument Delta-constraint At-clause Mod-clause Non-quotation-mark-graphic-character Non-end-of-line-character Pragma-argument-identifier Subtype-name Static-expression Parent-subtype-indication Static-simple-expression Discrete-subtype-indication Discriminant-selector-name Discriminant-direct-name Interface-subtype-mark Component-selector-name Label-statement-identifier Variable-name Boolean-expression Loop-statement-identifier Loop-identifier Block-statement-identifier Block-identifier Loop-name Label-name Procedure-name Procedure-prefix Function-name Function-prefix Formal-parameter-selector-name Ancestor-subtype-indication Package-name Object-name Exception-name Callable-entity-name Generic-package-name Generic-procedure-name Generic-function-name Task-identifier Protected-identifier Entry-direct-name Entry-identifier Entry-name Delay-expression Task-name Library-unit-name String-expression Generic-formal-parameter-selector-name Subprogram-name Package-instance-name First-subtype-local-name Component-local-name Restriction-identifier Restriction-parameter-identifier 
  context-free syntax
        Identifier-start (Identifier-start | Identifier-extend)* -> Identifier

        Letter-uppercase -> Identifier-start
        Letter-lowercase -> Identifier-start
        Letter-titlecase -> Identifier-start
        Letter-modifier -> Identifier-start
        Letter-other -> Identifier-start
        Number-letter -> Identifier-start

        Mark-non-spacing -> Identifier-extend
        Mark-spacing-combining -> Identifier-extend
        Number-decimal -> Identifier-extend
        Punctuation-connector -> Identifier-extend
        Other-format -> Identifier-extend

        Decimal-literal -> Numeric-literal
        Based-literal -> Numeric-literal

        Numeral ("." Numeral)? Exponent? -> Decimal-literal

        Digit (Underline? Digit)* -> Numeral

        "E" "+"? Numeral -> Exponent
        "E" "-" Numeral -> Exponent

        "0" -> Digit
        "1" -> Digit
        "2" -> Digit
        "3" -> Digit
        "4" -> Digit
        "5" -> Digit
        "6" -> Digit
        "7" -> Digit
        "8" -> Digit
        "9" -> Digit

        Base "#" Based-numeral ("." Based-numeral)? "#" Exponent? -> Based-literal

        Numeral -> Base

        Extended-digit (Underline? Extended-digit)* -> Based-numeral

        Digit -> Extended-digit
        "A" -> Extended-digit
        "B" -> Extended-digit
        "C" -> Extended-digit
        "D" -> Extended-digit
        "E" -> Extended-digit
        "F" -> Extended-digit

        "'" Graphic-character "'" -> Character-literal

        """ String-element* """ -> String-literal

        """" -> String-element
        Non-quotation-mark-graphic-character -> String-element

        "-" "-" Non-end-of-line-character* -> Comment

        "pragma" Identifier ("(" Pragma-argument-association ("," Pragma-argument-association)* ")")? ";" -> Pragma

        (Pragma-argument-identifier "=>")? Name -> Pragma-argument-association
        (Pragma-argument-identifier "=>")? Expression -> Pragma-argument-association

        Type-declaration -> Basic-declaration
        Object-declaration -> Basic-declaration
        Subprogram-declaration -> Basic-declaration
        Null-procedure-declaration -> Basic-declaration
        Renaming-declaration -> Basic-declaration
        Generic-declaration -> Basic-declaration
        Subtype-declaration -> Basic-declaration
        Number-declaration -> Basic-declaration
        Abstract-subprogram-declaration -> Basic-declaration
        Package-declaration -> Basic-declaration
        Exception-declaration -> Basic-declaration
        Generic-instantiation -> Basic-declaration

        Identifier -> Defining-identifier

        Full-type-declaration -> Type-declaration
        Incomplete-type-declaration -> Type-declaration
        Private-type-declaration -> Type-declaration
        Private-extension-declaration -> Type-declaration

        "type" Defining-identifier Known-discriminant-part? "is" Type-definition ";" -> Full-type-declaration
        Task-type-declaration -> Full-type-declaration
        Protected-type-declaration -> Full-type-declaration

        Enumeration-type-definition -> Type-definition
        Real-type-definition -> Type-definition
        Record-type-definition -> Type-definition
        Derived-type-definition -> Type-definition
        Integer-type-definition -> Type-definition
        Array-type-definition -> Type-definition
        Access-type-definition -> Type-definition
        Interface-type-definition -> Type-definition

        "subtype" Defining-identifier "is" Subtype-indication ";" -> Subtype-declaration

        Null-exclusion? Subtype-mark Constraint? -> Subtype-indication

        Subtype-name -> Subtype-mark

        Scalar-constraint -> Constraint
        Composite-constraint -> Constraint

        Range-constraint -> Scalar-constraint
        Digits-constraint -> Scalar-constraint
        Delta-constraint -> Scalar-constraint

        Index-constraint -> Composite-constraint
        Discriminant-constraint -> Composite-constraint

        Defining-identifier-list ":" "aliased"? "constant"? Subtype-indication (":=" Expression)? ";" -> Object-declaration
        Defining-identifier-list ":" "aliased"? "constant"? Access-definition (":=" Expression)? ";" -> Object-declaration
        Defining-identifier-list ":" "aliased"? "constant"? Array-type-definition (":=" Expression)? ";" -> Object-declaration
        Single-task-declaration -> Object-declaration
        Single-protected-declaration -> Object-declaration

        Defining-identifier ("," Defining-identifier)* -> Defining-identifier-list

        Defining-identifier-list ":" "constant" ":=" Static-expression ";" -> Number-declaration

        "abstract"? "limited"? "new" Parent-subtype-indication (("and" Interface-list)? Record-extension-part)? -> Derived-type-definition

        "range" Range -> Range-constraint

        Range-attribute-reference -> Range
        Simple-expression ".." Simple-expression -> Range

        "(" Enumeration-literal-specification ("," Enumeration-literal-specification)* ")" -> Enumeration-type-definition

        Defining-identifier -> Enumeration-literal-specification
        Defining-character-literal -> Enumeration-literal-specification

        Character-literal -> Defining-character-literal

        Signed-integer-type-definition -> Integer-type-definition
        Modular-type-definition -> Integer-type-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Signed-integer-type-definition

        "mod" Static-expression -> Modular-type-definition

        Floating-point-definition -> Real-type-definition
        Fixed-point-definition -> Real-type-definition

        "digits" Static-expression Real-range-specification? -> Floating-point-definition

        "range" Static-simple-expression ".." Static-simple-expression -> Real-range-specification

        Ordinary-fixed-point-definition -> Fixed-point-definition
        Decimal-fixed-point-definition -> Fixed-point-definition

        "delta" Static-expression Real-range-specification -> Ordinary-fixed-point-definition

        "delta" Static-expression "digits" Static-expression Real-range-specification? -> Decimal-fixed-point-definition

        "digits" Static-expression Range-constraint? -> Digits-constraint

        Unconstrained-array-definition -> Array-type-definition
        Constrained-array-definition -> Array-type-definition

        "array" "(" Index-subtype-definition ("," Index-subtype-definition)* ")" "of" Component-definition -> Unconstrained-array-definition

        Subtype-mark "range" "<>" -> Index-subtype-definition

        "array" "(" Discrete-subtype-definition ("," Discrete-subtype-definition)* ")" "of" Component-definition -> Constrained-array-definition

        Discrete-subtype-indication -> Discrete-subtype-definition
        Range -> Discrete-subtype-definition

        "aliased"? Subtype-indication -> Component-definition
        "aliased"? Access-definition -> Component-definition

        "(" Discrete-range ("," Discrete-range)* ")" -> Index-constraint

        Discrete-subtype-indication -> Discrete-range
        Range -> Discrete-range

        Unknown-discriminant-part -> Discriminant-part
        Known-discriminant-part -> Discriminant-part

        "(<>)" -> Unknown-discriminant-part

        "(" Discriminant-specification (";" Discriminant-specification)* ")" -> Known-discriminant-part

        Defining-identifier-list ":" Null-exclusion? Subtype-mark (":=" Default-expression)? -> Discriminant-specification
        Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Discriminant-specification

        Expression -> Default-expression

        "(" Discriminant-association ("," Discriminant-association)* ")" -> Discriminant-constraint

        (Discriminant-selector-name ("|" Discriminant-selector-name)* "=>")? Expression -> Discriminant-association

        ("abstract"? "tagged")? "limited"? Record-definition -> Record-type-definition

        "record" Component-list "end" "record" -> Record-definition
        "null" "record" -> Record-definition

        Component-item Component-item* -> Component-list
        Component-item* Variant-part -> Component-list
        "null" ";" -> Component-list

        Component-declaration -> Component-item
        Aspect-clause -> Component-item

        Defining-identifier-list ":" Component-definition (":=" Default-expression)? ";" -> Component-declaration

        "case" Discriminant-direct-name "is" Variant+ "end" "case" ";" -> Variant-part

        "when" Discrete-choice-list "=>" Component-list -> Variant

        Discrete-choice ("|" Discrete-choice)* -> Discrete-choice-list

        Expression -> Discrete-choice
        Discrete-range -> Discrete-choice
        "others" -> Discrete-choice

        "with" Record-definition -> Record-extension-part

        Overriding-indicator? Subprogram-specification "is" "abstract" ";" -> Abstract-subprogram-declaration

        ("limited" | "task" | "protected" | "synchronized")? "interface" ("and" Interface-list)? -> Interface-type-definition

        Interface-subtype-mark ("and" Interface-subtype-mark)* -> Interface-list

        Null-exclusion? Access-to-object-definition -> Access-type-definition
        Null-exclusion? Access-to-subprogram-definition -> Access-type-definition

        "access" General-access-modifier? Subtype-indication -> Access-to-object-definition

        "all" -> General-access-modifier
        "constant" -> General-access-modifier

        "access" "protected"? "procedure" Parameter-profile -> Access-to-subprogram-definition
        "access" "protected"? "function" Parameter-and-result-profile -> Access-to-subprogram-definition

        "not" "null" -> Null-exclusion

        Null-exclusion? "access" "constant"? Subtype-mark -> Access-definition
        Null-exclusion? "access" "protected"? "procedure" Parameter-profile -> Access-definition
        Null-exclusion? "access" "protected"? "function" Parameter-and-result-profile -> Access-definition

        "type" Defining-identifier Discriminant-part? ("is" "tagged")? ";" -> Incomplete-type-declaration

        Declarative-item* -> Declarative-part

        Basic-declarative-item -> Declarative-item
        Body -> Declarative-item

        Basic-declaration -> Basic-declarative-item
        Aspect-clause -> Basic-declarative-item
        Use-clause -> Basic-declarative-item

        Proper-body -> Body
        Body-stub -> Body

        Subprogram-body -> Proper-body
        Package-body -> Proper-body
        Task-body -> Proper-body
        Protected-body -> Proper-body

        Direct-name -> Name
        Indexed-component -> Name
        Selected-component -> Name
        Type-conversion -> Name
        Character-literal -> Name
        Explicit-dereference -> Name
        Slice -> Name
        Attribute-reference -> Name
        Function-call -> Name

        Identifier -> Direct-name
        Operator-symbol -> Direct-name

        Name -> Prefix
        Implicit-dereference -> Prefix

        Name "." "all" -> Explicit-dereference

        Name -> Implicit-dereference

        Prefix "(" Expression ("," Expression)* ")" -> Indexed-component

        Prefix "(" Discrete-range ")" -> Slice

        Prefix "." Selector-name -> Selected-component

        Identifier -> Selector-name
        Character-literal -> Selector-name
        Operator-symbol -> Selector-name

        Prefix "'" Attribute-designator -> Attribute-reference

        Identifier ("(" Static-expression ")")? -> Attribute-designator
        "Access" -> Attribute-designator
        "Delta" -> Attribute-designator
        "Digits" -> Attribute-designator

        Prefix "'" Range-attribute-designator -> Range-attribute-reference

        "Range" ("(" Static-expression ")")? -> Range-attribute-designator

        Record-aggregate -> Aggregate
        Extension-aggregate -> Aggregate
        Array-aggregate -> Aggregate

        "(" Record-component-association-list ")" -> Record-aggregate

        Record-component-association ("," Record-component-association)* -> Record-component-association-list
        "null" "record" -> Record-component-association-list

        (Component-choice-list "=>")? Expression -> Record-component-association
        Component-choice-list "=><>" -> Record-component-association

        Component-selector-name ("|" Component-selector-name)* -> Component-choice-list
        "others" -> Component-choice-list

        "(" Ancestor-part "with" Record-component-association-list ")" -> Extension-aggregate

        Expression -> Ancestor-part
        Subtype-mark -> Ancestor-part

        Positional-array-aggregate -> Array-aggregate
        Named-array-aggregate -> Array-aggregate

        "(" Expression "," Expression ("," Expression)* ")" -> Positional-array-aggregate
        "(" Expression ("," Expression)* "," "others" "=>" Expression ")" -> Positional-array-aggregate
        "(" Expression ("," Expression)* "," "others" "=><>)" -> Positional-array-aggregate

        "(" Array-component-association ("," Array-component-association)* ")" -> Named-array-aggregate

        Discrete-choice-list "=>" Expression -> Array-component-association
        Discrete-choice-list "=><>" -> Array-component-association

        Relation ("and" Relation)* -> Expression
        Relation ("or" Relation)* -> Expression
        Relation ("xor" Relation)* -> Expression
        Relation ("and" "then" Relation)* -> Expression
        Relation ("or" "else" Relation)* -> Expression

        Simple-expression (Relational-operator Simple-expression)? -> Relation
        Simple-expression "not"? "in" Range -> Relation
        Simple-expression "not"? "in" Subtype-mark -> Relation

        Unary-adding-operator? Term (Binary-adding-operator Term)* -> Simple-expression

        Factor (Multiplying-operator Factor)* -> Term

        Primary ("**" Primary)? -> Factor
        "abs" Primary -> Factor
        "not" Primary -> Factor

        Numeric-literal -> Primary
        "null" -> Primary
        String-literal -> Primary
        Aggregate -> Primary
        Name -> Primary
        Qualified-expression -> Primary
        Allocator -> Primary
        "(" Expression ")" -> Primary

        "and" -> Logical-operator
        "or" -> Logical-operator
        "xor" -> Logical-operator

        "=" -> Relational-operator
        "/=" -> Relational-operator
        "<" -> Relational-operator
        "<=" -> Relational-operator
        ">" -> Relational-operator
        ">=" -> Relational-operator

        "+" -> Binary-adding-operator
        "-" -> Binary-adding-operator
        "&" -> Binary-adding-operator

        "+" -> Unary-adding-operator
        "-" -> Unary-adding-operator

        "*" -> Multiplying-operator
        "/" -> Multiplying-operator
        "mod" -> Multiplying-operator
        "rem" -> Multiplying-operator

        "**" -> Highest-precedence-operator
        "abs" -> Highest-precedence-operator
        "not" -> Highest-precedence-operator

        Subtype-mark "(" Expression ")" -> Type-conversion
        Subtype-mark "(" Name ")" -> Type-conversion

        Subtype-mark "'(" Expression ")" -> Qualified-expression
        Subtype-mark "'" Aggregate -> Qualified-expression

        "new" Subtype-indication -> Allocator
        "new" Qualified-expression -> Allocator

        Statement Statement* -> Sequence-of-statements

        Label* Simple-statement -> Statement
        Label* Compound-statement -> Statement

        Null-statement -> Simple-statement
        Assignment-statement -> Simple-statement
        Goto-statement -> Simple-statement
        Simple-return-statement -> Simple-statement
        Requeue-statement -> Simple-statement
        Abort-statement -> Simple-statement
        Code-statement -> Simple-statement
        Exit-statement -> Simple-statement
        Procedure-call-statement -> Simple-statement
        Entry-call-statement -> Simple-statement
        Delay-statement -> Simple-statement
        Raise-statement -> Simple-statement

        If-statement -> Compound-statement
        Loop-statement -> Compound-statement
        Extended-return-statement -> Compound-statement
        Accept-statement -> Compound-statement
        Case-statement -> Compound-statement
        Block-statement -> Compound-statement
        Select-statement -> Compound-statement

        "null" ";" -> Null-statement

        "<<" Label-statement-identifier ">>" -> Label

        Direct-name -> Statement-identifier

        Variable-name ":=" Expression ";" -> Assignment-statement

        "if" Condition "then" Sequence-of-statements ("elsif" Condition "then" Sequence-of-statements)* ("else" Sequence-of-statements)? "end" "if" ";" -> If-statement

        Boolean-expression -> Condition

        "case" Expression "is" Case-statement-alternative Case-statement-alternative* "end" "case" ";" -> Case-statement

        "when" Discrete-choice-list "=>" Sequence-of-statements -> Case-statement-alternative

        (Loop-statement-identifier ":")? Iteration-scheme? "loop" Sequence-of-statements "end" "loop" Loop-identifier? ";" -> Loop-statement

        "while" Condition -> Iteration-scheme
        "for" Loop-parameter-specification -> Iteration-scheme

        Defining-identifier "in" "reverse"? Discrete-subtype-definition -> Loop-parameter-specification

        (Block-statement-identifier ":")? ("declare" Declarative-part)? "begin" Handled-sequence-of-statements "end" Block-identifier? ";" -> Block-statement

        "exit" Loop-name? ("when" Condition)? ";" -> Exit-statement

        "goto" Label-name ";" -> Goto-statement

        Overriding-indicator? Subprogram-specification ";" -> Subprogram-declaration

        Procedure-specification -> Subprogram-specification
        Function-specification -> Subprogram-specification

        "procedure" Defining-program-unit-name Parameter-profile -> Procedure-specification

        "function" Defining-designator Parameter-and-result-profile -> Function-specification

        (Parent-unit-name ".")? Identifier -> Designator
        Operator-symbol -> Designator

        Defining-program-unit-name -> Defining-designator
        Defining-operator-symbol -> Defining-designator

        (Parent-unit-name ".")? Defining-identifier -> Defining-program-unit-name

        String-literal -> Operator-symbol

        Operator-symbol -> Defining-operator-symbol

        Formal-part? -> Parameter-profile

        Formal-part? "return" Null-exclusion? Subtype-mark -> Parameter-and-result-profile
        Formal-part? "return" Access-definition -> Parameter-and-result-profile

        "(" Parameter-specification (";" Parameter-specification)* ")" -> Formal-part

        Defining-identifier-list ":" Mode Null-exclusion? Subtype-mark (":=" Default-expression)? -> Parameter-specification
        Defining-identifier-list ":" Access-definition (":=" Default-expression)? -> Parameter-specification

        "in"? -> Mode
        "in" "out" -> Mode
        "out" -> Mode

        Overriding-indicator? Subprogram-specification "is" Declarative-part "begin" Handled-sequence-of-statements "end" Designator? ";" -> Subprogram-body

        Procedure-name ";" -> Procedure-call-statement
        Procedure-prefix Actual-parameter-part ";" -> Procedure-call-statement

        Function-name -> Function-call
        Function-prefix Actual-parameter-part -> Function-call

        "(" Parameter-association ("," Parameter-association)* ")" -> Actual-parameter-part

        (Formal-parameter-selector-name "=>")? Explicit-actual-parameter -> Parameter-association

        Expression -> Explicit-actual-parameter
        Variable-name -> Explicit-actual-parameter

        "return" Expression? ";" -> Simple-return-statement

        "return" Defining-identifier ":" "aliased"? Return-subtype-indication (":=" Expression)? ("do" Handled-sequence-of-statements "end" "return")? ";" -> Extended-return-statement

        Subtype-indication -> Return-subtype-indication
        Access-definition -> Return-subtype-indication

        Overriding-indicator? Procedure-specification "is" "null" ";" -> Null-procedure-declaration

        Package-specification ";" -> Package-declaration

        "package" Defining-program-unit-name "is" Basic-declarative-item* ("private" Basic-declarative-item*)? "end" ((Parent-unit-name ".")? Identifier)? -> Package-specification

        "package" "body" Defining-program-unit-name "is" Declarative-part ("begin" Handled-sequence-of-statements)? "end" ((Parent-unit-name ".")? Identifier)? ";" -> Package-body

        "type" Defining-identifier Discriminant-part? "is" ("abstract"? "tagged")? "limited"? "private" ";" -> Private-type-declaration

        "type" Defining-identifier Discriminant-part? "is" "abstract"? ("limited" | "synchronized")? "new" Ancestor-subtype-indication ("and" Interface-list)? "with" "private" ";" -> Private-extension-declaration

        "not"? "overriding" -> Overriding-indicator

        Use-package-clause -> Use-clause
        Use-type-clause -> Use-clause

        "use" Package-name ("," Package-name)* ";" -> Use-package-clause

        "use" "type" Subtype-mark ("," Subtype-mark)* ";" -> Use-type-clause

        Object-renaming-declaration -> Renaming-declaration
        Exception-renaming-declaration -> Renaming-declaration
        Package-renaming-declaration -> Renaming-declaration
        Subprogram-renaming-declaration -> Renaming-declaration
        Generic-renaming-declaration -> Renaming-declaration

        Defining-identifier ":" Null-exclusion? Subtype-mark "renames" Object-name ";" -> Object-renaming-declaration
        Defining-identifier ":" Access-definition "renames" Object-name ";" -> Object-renaming-declaration

        Defining-identifier ":" "exception" "renames" Exception-name ";" -> Exception-renaming-declaration

        "package" Defining-program-unit-name "renames" Package-name ";" -> Package-renaming-declaration

        Overriding-indicator? Subprogram-specification "renames" Callable-entity-name ";" -> Subprogram-renaming-declaration

        "generic" "package" Defining-program-unit-name "renames" Generic-package-name ";" -> Generic-renaming-declaration
        "generic" "procedure" Defining-program-unit-name "renames" Generic-procedure-name ";" -> Generic-renaming-declaration
        "generic" "function" Defining-program-unit-name "renames" Generic-function-name ";" -> Generic-renaming-declaration

        "task" "type" Defining-identifier Known-discriminant-part? ("is" ("new" Interface-list "with")? Task-definition)? ";" -> Task-type-declaration

        "task" Defining-identifier ("is" ("new" Interface-list "with")? Task-definition)? ";" -> Single-task-declaration

        Task-item* ("private" Task-item*)? "end" Task-identifier? -> Task-definition

        Entry-declaration -> Task-item
        Aspect-clause -> Task-item

        "task" "body" Defining-identifier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Task-identifier? ";" -> Task-body

        "protected" "type" Defining-identifier Known-discriminant-part? "is" ("new" Interface-list "with")? Protected-definition ";" -> Protected-type-declaration

        "protected" Defining-identifier "is" ("new" Interface-list "with")? Protected-definition ";" -> Single-protected-declaration

        Protected-operation-declaration* ("private" Protected-element-declaration*)? "end" Protected-identifier? -> Protected-definition

        Subprogram-declaration -> Protected-operation-declaration
        Entry-declaration -> Protected-operation-declaration
        Aspect-clause -> Protected-operation-declaration

        Protected-operation-declaration -> Protected-element-declaration
        Component-declaration -> Protected-element-declaration

        "protected" "body" Defining-identifier "is" Protected-operation-item* "end" Protected-identifier? ";" -> Protected-body

        Subprogram-declaration -> Protected-operation-item
        Subprogram-body -> Protected-operation-item
        Entry-body -> Protected-operation-item
        Aspect-clause -> Protected-operation-item

        Overriding-indicator? "entry" Defining-identifier ("(" Discrete-subtype-definition ")")? Parameter-profile ";" -> Entry-declaration

        "accept" Entry-direct-name ("(" Entry-index ")")? Parameter-profile ("do" Handled-sequence-of-statements "end" Entry-identifier?)? ";" -> Accept-statement

        Expression -> Entry-index

        "entry" Defining-identifier Entry-body-formal-part Entry-barrier "is" Declarative-part "begin" Handled-sequence-of-statements "end" Entry-identifier? ";" -> Entry-body

        ("(" Entry-index-specification ")")? Parameter-profile -> Entry-body-formal-part

        "when" Condition -> Entry-barrier

        "for" Defining-identifier "in" Discrete-subtype-definition -> Entry-index-specification

        Entry-name Actual-parameter-part? ";" -> Entry-call-statement

        "requeue" Entry-name ("with" "abort")? ";" -> Requeue-statement

        Delay-until-statement -> Delay-statement
        Delay-relative-statement -> Delay-statement

        "delay" "until" Delay-expression ";" -> Delay-until-statement

        "delay" Delay-expression ";" -> Delay-relative-statement

        Selective-accept -> Select-statement
        Timed-entry-call -> Select-statement
        Conditional-entry-call -> Select-statement
        Asynchronous-select -> Select-statement

        "select" Guard? Select-alternative ("or" Guard? Select-alternative)* ("else" Sequence-of-statements)? "end" "select" ";" -> Selective-accept

        "when" Condition "=>" -> Guard

        Accept-alternative -> Select-alternative
        Delay-alternative -> Select-alternative
        Terminate-alternative -> Select-alternative

        Accept-statement Sequence-of-statements? -> Accept-alternative

        Delay-statement Sequence-of-statements? -> Delay-alternative

        "terminate" ";" -> Terminate-alternative

        "select" Entry-call-alternative "or" Delay-alternative "end" "select" ";" -> Timed-entry-call

        Procedure-or-entry-call Sequence-of-statements? -> Entry-call-alternative

        Procedure-call-statement -> Procedure-or-entry-call
        Entry-call-statement -> Procedure-or-entry-call

        "select" Entry-call-alternative "else" Sequence-of-statements "end" "select" ";" -> Conditional-entry-call

        "select" Triggering-alternative "then" "abort" Abortable-part "end" "select" ";" -> Asynchronous-select

        Triggering-statement Sequence-of-statements? -> Triggering-alternative

        Procedure-or-entry-call -> Triggering-statement
        Delay-statement -> Triggering-statement

        Sequence-of-statements -> Abortable-part

        "abort" Task-name ("," Task-name)* ";" -> Abort-statement

        Compilation-unit* -> Compilation

        Context-clause Library-item -> Compilation-unit
        Context-clause Subunit -> Compilation-unit

        "private"? Library-unit-declaration -> Library-item
        Library-unit-body -> Library-item
        "private"? Library-unit-renaming-declaration -> Library-item

        Subprogram-declaration -> Library-unit-declaration
        Package-declaration -> Library-unit-declaration
        Generic-declaration -> Library-unit-declaration
        Generic-instantiation -> Library-unit-declaration

        Package-renaming-declaration -> Library-unit-renaming-declaration
        Generic-renaming-declaration -> Library-unit-renaming-declaration
        Subprogram-renaming-declaration -> Library-unit-renaming-declaration

        Subprogram-body -> Library-unit-body
        Package-body -> Library-unit-body

        Name -> Parent-unit-name

        Context-item* -> Context-clause

        With-clause -> Context-item
        Use-clause -> Context-item

        Limited-with-clause -> With-clause
        Nonlimited-with-clause -> With-clause

        "limited" "private"? "with" Library-unit-name ("," Library-unit-name)* ";" -> Limited-with-clause

        "private"? "with" Library-unit-name ("," Library-unit-name)* ";" -> Nonlimited-with-clause

        Subprogram-body-stub -> Body-stub
        Package-body-stub -> Body-stub
        Task-body-stub -> Body-stub
        Protected-body-stub -> Body-stub

        Overriding-indicator? Subprogram-specification "is" "separate" ";" -> Subprogram-body-stub

        "package" "body" Defining-identifier "is" "separate" ";" -> Package-body-stub

        "task" "body" Defining-identifier "is" "separate" ";" -> Task-body-stub

        "protected" "body" Defining-identifier "is" "separate" ";" -> Protected-body-stub

        "separate" "(" Parent-unit-name ")" Proper-body -> Subunit

        Defining-identifier-list ":" "exception" ";" -> Exception-declaration

        Sequence-of-statements ("exception" Exception-handler Exception-handler*)? -> Handled-sequence-of-statements

        "when" (Choice-parameter-specification ":")? Exception-choice ("|" Exception-choice)* "=>" Sequence-of-statements -> Exception-handler

        Defining-identifier -> Choice-parameter-specification

        Exception-name -> Exception-choice
        "others" -> Exception-choice

        "raise" ";" -> Raise-statement
        "raise" Exception-name ("with" String-expression)? ";" -> Raise-statement

        Generic-subprogram-declaration -> Generic-declaration
        Generic-package-declaration -> Generic-declaration

        Generic-formal-part Subprogram-specification ";" -> Generic-subprogram-declaration

        Generic-formal-part Package-specification ";" -> Generic-package-declaration

        "generic" (Generic-formal-parameter-declaration | Use-clause)* -> Generic-formal-part

        Formal-object-declaration -> Generic-formal-parameter-declaration
        Formal-type-declaration -> Generic-formal-parameter-declaration
        Formal-subprogram-declaration -> Generic-formal-parameter-declaration
        Formal-package-declaration -> Generic-formal-parameter-declaration

        "package" Defining-program-unit-name "is" "new" Generic-package-name Generic-actual-part? ";" -> Generic-instantiation
        Overriding-indicator? "procedure" Defining-program-unit-name "is" "new" Generic-procedure-name Generic-actual-part? ";" -> Generic-instantiation
        Overriding-indicator? "function" Defining-designator "is" "new" Generic-function-name Generic-actual-part? ";" -> Generic-instantiation

        "(" Generic-association ("," Generic-association)* ")" -> Generic-actual-part

        (Generic-formal-parameter-selector-name "=>")? Explicit-generic-actual-parameter -> Generic-association

        Expression -> Explicit-generic-actual-parameter
        Variable-name -> Explicit-generic-actual-parameter
        Subprogram-name -> Explicit-generic-actual-parameter
        Entry-name -> Explicit-generic-actual-parameter
        Subtype-mark -> Explicit-generic-actual-parameter
        Package-instance-name -> Explicit-generic-actual-parameter

        Defining-identifier-list ":" Mode Null-exclusion? Subtype-mark (":=" Default-expression)? ";" Defining-identifier-list ":" Mode Access-definition (":=" Default-expression)? ";" -> Formal-object-declaration

        "type" Defining-identifier Discriminant-part? "is" Formal-type-definition ";" -> Formal-type-declaration

        Formal-private-type-definition -> Formal-type-definition
        Formal-derived-type-definition -> Formal-type-definition
        Formal-discrete-type-definition -> Formal-type-definition
        Formal-signed-integer-type-definition -> Formal-type-definition
        Formal-modular-type-definition -> Formal-type-definition
        Formal-floating-point-definition -> Formal-type-definition
        Formal-ordinary-fixed-point-definition -> Formal-type-definition
        Formal-decimal-fixed-point-definition -> Formal-type-definition
        Formal-array-type-definition -> Formal-type-definition
        Formal-access-type-definition -> Formal-type-definition
        Formal-interface-type-definition -> Formal-type-definition

        ("abstract"? "tagged")? "limited"? "private" -> Formal-private-type-definition

        "abstract"? ("limited" | "synchronized")? "new" Subtype-mark (("and" Interface-list)? "with" "private")? -> Formal-derived-type-definition

        "(<>)" -> Formal-discrete-type-definition

        "range" "<>" -> Formal-signed-integer-type-definition

        "mod" "<>" -> Formal-modular-type-definition

        "digits" "<>" -> Formal-floating-point-definition

        "delta" "<>" -> Formal-ordinary-fixed-point-definition

        "delta" "<>" "digits" "<>" -> Formal-decimal-fixed-point-definition

        Array-type-definition -> Formal-array-type-definition

        Access-type-definition -> Formal-access-type-definition

        Interface-type-definition -> Formal-interface-type-definition

        Formal-concrete-subprogram-declaration -> Formal-subprogram-declaration
        Formal-abstract-subprogram-declaration -> Formal-subprogram-declaration

        "with" Subprogram-specification ("is" Subprogram-default)? ";" -> Formal-concrete-subprogram-declaration

        "with" Subprogram-specification "is" "abstract" Subprogram-default? ";" -> Formal-abstract-subprogram-declaration

        Default-name -> Subprogram-default
        "<>" -> Subprogram-default
        "null" -> Subprogram-default

        Name -> Default-name

        "with" "package" Defining-identifier "is" "new" Generic-package-name Formal-package-actual-part ";" -> Formal-package-declaration

        "(" ("others" "=>")? "<>)" -> Formal-package-actual-part
        Generic-actual-part? -> Formal-package-actual-part
        "(" Formal-package-association ("," Formal-package-association)* ("," "others" "=><>")? ")" -> Formal-package-actual-part

        Generic-association -> Formal-package-association
        Generic-formal-parameter-selector-name "=><>" -> Formal-package-association

        Attribute-definition-clause -> Aspect-clause
        Enumeration-representation-clause -> Aspect-clause
        Record-representation-clause -> Aspect-clause
        At-clause -> Aspect-clause

        Direct-name -> Local-name
        Direct-name "'" Attribute-designator -> Local-name
        Library-unit-name -> Local-name

        "for" Local-name "'" Attribute-designator "use" Expression ";" -> Attribute-definition-clause
        "for" Local-name "'" Attribute-designator "use" Name ";" -> Attribute-definition-clause

        "for" First-subtype-local-name "use" Enumeration-aggregate ";" -> Enumeration-representation-clause

        Array-aggregate -> Enumeration-aggregate

        "for" First-subtype-local-name "use" "record" Mod-clause? Component-clause* "end" "record" ";" -> Record-representation-clause

        Component-local-name "at" Position "range" First-bit ".." Last-bit ";" -> Component-clause

        Static-expression -> Position

        Static-simple-expression -> First-bit

        Static-simple-expression -> Last-bit

        Qualified-expression ";" -> Code-statement

        Restriction-identifier -> Restriction
        Restriction-parameter-identifier "=>" Restriction-parameter-argument -> Restriction

        Name -> Restriction-parameter-argument
        Expression -> Restriction-parameter-argument

        "delta" Static-expression Range-constraint? -> Delta-constraint

        "for" Direct-name "use" "at" Expression ";" -> At-clause

        "at" "mod" Static-expression ";" -> Mod-clause

        Graphic-character -> Non-quotation-mark-graphic-character

        "character" -> Non-end-of-line-character

        Identifier -> Pragma-argument-identifier

        Name -> Subtype-name

        Expression -> Static-expression

        Subtype-indication -> Parent-subtype-indication

        Simple-expression -> Static-simple-expression

        Subtype-indication -> Discrete-subtype-indication

        Selector-name -> Discriminant-selector-name

        Direct-name -> Discriminant-direct-name

        Subtype-mark -> Interface-subtype-mark

        Selector-name -> Component-selector-name

        Statement-identifier -> Label-statement-identifier

        Name -> Variable-name

        Expression -> Boolean-expression

        Statement-identifier -> Loop-statement-identifier

        Identifier -> Loop-identifier

        Statement-identifier -> Block-statement-identifier

        Identifier -> Block-identifier

        Name -> Loop-name

        Name -> Label-name

        Name -> Procedure-name

        Prefix -> Procedure-prefix

        Name -> Function-name

        Prefix -> Function-prefix

        Selector-name -> Formal-parameter-selector-name

        Subtype-indication -> Ancestor-subtype-indication

        Name -> Package-name

        Name -> Object-name

        Name -> Exception-name

        Name -> Callable-entity-name

        Name -> Generic-package-name

        Name -> Generic-procedure-name

        Name -> Generic-function-name

        Identifier -> Task-identifier

        Identifier -> Protected-identifier

        Direct-name -> Entry-direct-name

        Identifier -> Entry-identifier

        Name -> Entry-name

        Expression -> Delay-expression

        Name -> Task-name

        Name -> Library-unit-name

        Expression -> String-expression

        Selector-name -> Generic-formal-parameter-selector-name

        Name -> Subprogram-name

        Name -> Package-instance-name

        Local-name -> First-subtype-local-name

        Local-name -> Component-local-name

        Identifier -> Restriction-identifier

        Identifier -> Restriction-parameter-identifier
