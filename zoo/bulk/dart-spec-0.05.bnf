variableDeclaration:
        declaredIdentifier ("," identifier)*
initializedVariableDeclaration:
        declaredIdentifier ("=" expression)? ("," initializedIdentifier)*
initializedIdentifier:
        identifier ("=" expression)?
declaredIdentifier:
        finalVarOrType identifier
finalVarOrType:
        "final" type?
        "var"
        type
functionSignature:
        returnType? identifier formalParameterList
returnType:
        "void"
        type
functionBody:
        "=>" expression ";"
        block
block:
        "{" statements "}"
formalParameterList:
        "(" ")"
        "(" normalFormalParameters ("," namedFormalParameters)? ")"
        "(" namedFormalParameters ")"
normalFormalParameters:
        normalFormalParameter ("," normalFormalParameter)*
namedFormalParameters:
        "[" defaultFormalParameter ("," defaultFormalParameter)* "]"
normalFormalParameter:
        functionSignature
        fieldFormalParameter
        simpleFormalParameter
simpleFormalParameter:
        declaredIdentifier
        identifier
fieldFormalParameter:
        finalVarOrType? "this" "." identifier
defaultFormalParameter:
        normalFormalParameter ("=" constantExpression)?
classDefinition:
        "class" identifier typeParameters? superclass? interfaces? "{" classMemberDefinition* "}"
classMemberDefinition:
        declaration ";"
        methodSignature functionBody
methodSignature:
        factoryConstructorSignature
        "static" functionSignature
        getterSignature
        setterSignature
        operatorSignature
        functionSignature initializers?
        namedConstructorSignature initializers?
declaration:
        constantConstructorSignature (redirection | initializers)?
        functionSignature redirection
        namedConstructorSignature redirection
        "abstract" getterSignature
        "abstract" setterSignature
        "abstract" operatorSignature
        "abstract" functionSignature
        "static" "final" type? staticFinalDeclarationList
        "static"? initializedVariableDeclaration
staticFinalDeclarationList:
        staticFinalDeclaration ("," staticFinalDeclaration)*
operatorSignature:
        returnType? operator operator formalParameterList
operator:
        unaryOperator
        binaryOperator
        "[" "]"
        "[" "]" "="
        "negate"
unaryOperator:
        negateOperator
binaryOperator:
        multiplicativeOperator
        additiveOperator
        shiftOperator
        relationalOperator
        equalityOperator
        bitwiseOperator
prefixOperator:
        "-"
        negateOperator
negateOperator:
        "!"
        "~"
getterSignature:
        "static"? returnType? "get" identifier formalParameterList
setterSignature:
        "static"? returnType? "set" identifier formalParameterList
constructorSignature:
        identifier formalParameterList
        namedConstructorSignature
namedConstructorSignature:
        identifier "." identifier formalParameterList
redirection:
        ":" "this" ("." identifier)? arguments
initializers:
        ":" superCallOrFieldInitializer ("," superCallOrFieldInitializer)*
superCallOrFieldInitializer:
        "super" arguments
        "super" "." identifier arguments
        fieldInitializer
fieldInitializer:
        ("this" ".")? identifier "=" conditionalExpression
factoryConstructorSignature:
        "factory" qualified typeParameters? ("." identifier)? formalParameterList
constantConstructorSignature:
        "const" qualified formalParameterList
superclass:
        "extends" type
interfaces:
        "implements" typeList
interfaceDefinition:
        "interface" identifier typeParameters? superinterfaces? factorySpecification? "{" interfaceMemberDefinition* "}"
interfaceMemberDefinition:
        "static" "final" type? initializedIdentifierList ";"
        functionSignature ";"
        constantConstructorSignature ";"
        namedConstructorSignature ";"
        getterSignature ";"
        setterSignature ";"
        operatorSignature ";"
        variableDeclaration ";"
factorySpecification:
        "factory" qualified typeParameters?
superinterfaces:
        "extends" typeList
typeParameter:
        identifier ("extends" type)?
typeParameters:
        "<" typeParameter ("," typeParameter)* ">"
expression:
        assignableExpression assignmentOperator expression
        conditionalExpression
expressionList:
        expression ("," expression)*
primary:
        thisExpression
        "super" assignableSelector
        functionExpression
        literal
        identifier
        newExpression
        constantObjectExpression
        "(" expression ")"
literal:
        nullLiteral
        booleanLiteral
        numericLiteral
        stringLiteral
        mapLiteral
        listLiteral
nullLiteral:
        "null"
numericLiteral:
        NUMBER
        HEX_NUMBER
NUMBER:
        "+"? DIGIT+ ("." DIGIT+)? EXPONENT?
        "+"? "." DIGIT+ EXPONENT?
EXPONENT:
        ("e" | "E") ("+" | "-")? DIGIT+
HEX_NUMBER:
        "0x" HEX_DIGIT+
        "0X" HEX_DIGIT+
HEX_DIGIT:
        "a" "." "." "f"
        "A" "." "." "F"
        DIGIT
booleanLiteral:
        "true"
        "false"
stringLiteral:
        "@"? MULTI_LINE_STRING
        SINGLE_LINE_STRING
SINGLE_LINE_STRING:
        """ STRING_CONTENT_DQ* """
        "'" STRING_CONTENT_SQ* "'"
        "@' ' ' " ("~" ("'" | NEWLINE))* "'"
        "@" """ ("~" (""" | NEWLINE))* """
MULTI_LINE_STRING:
        """"" ("~" """"")* """""
        "'''" ("~" "'''")* "'''"
ESCAPE_SEQUENCE:
        "\n"
        "\r"
        "\f"
        "\b"
        "\t"
        "\v"
        "\x" HEX_DIGIT HEX_DIGIT
        "\u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
        "\u{" HEX_DIGIT_SEQUENCE "}"
HEX_DIGIT_SEQUENCE:
        HEX_DIGIT HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT?
STRING_CONTENT_DQ:
        "~" ("\\" | "  "  " | "$" | NEWLINE)
        "\\" "~" NEWLINE
        STRING_INTERPOLATION
STRING_CONTENT_SQ:
        "~" ("\\" | "\'" | "$" | NEWLINE)
        "\\" "~" NEWLINE
        STRING_INTERPOLATION
NEWLINE:
        "\n"
        "\r"
STRING_INTERPOLATION:
        "$" IDENTIFIER_NO_DOLLAR
        "$" "{" "Expression" "}"
listLiteral:
        "const"? typeArguments? "[" (expressionList ","?)? "]"
mapLiteral:
        "const"? typeArguments? "{" (mapLiteralEntry ("," mapLiteralEntry)* ","?)? "}"
mapLiteralEntry:
        identifier ":" expression
        stringLiteral ":" expression
functionExpression:
        (returnType? identifier)? formalParameterList functionExpressionBody
functionExpressionBody:
        "=>" expression
        block
thisExpression:
        "this"
newExpression:
        "new" type ("." identifier)? arguments
constObjectExpression:
        "const" type ("." identifier)? arguments
arguments:
        "(" argumentList? ")"
argumentList:
        namedArgument ("," namedArgument)*
        expressionList ("," namedArgument)*
namedArgument:
        label expression
assignmentOperator:
        "="
        compoundAssignmentOperator
compoundAssignmentOperator:
        "*="
        "/="
        "~/="
        "%="
        "+="
        "-="
        "<<="
        ">>>="
        ">>="
        "&="
        "^="
        "|="
conditionalExpression:
        logicalOrExpression ("?" expression ":" expression)?
logicalOrExpression:
        logicalAndExpression ("||" logicalAndExpression)*
logicalAndExpression:
        bitwiseOrExpression ("&&" bitwiseOrExpression)*
bitwiseOrExpression:
        bitwiseXorExpression ("|" bitwiseXorExpression)*
        "super" ("|" bitwiseXorExpression)+
bitwiseXorExpression:
        bitwiseAndExpression ("^" bitwiseAndExpression)*
        "super" ("^" bitwiseAndExpression)+
bitwiseAndExpression:
        equalityExpression ("&" equalityExpression)*
        "super" ("&" equalityExpression)+
bitwiseOperator:
        "&"
        "^"
        "|"
equalityExpression:
        relationalExpression (equalityOperator relationalExpression)?
        "super" equalityOperator relationalExpression
equalityOperator:
        "=="
        "!="
        "==="
        "!=="
relationalExpression:
        shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?
        "super" relationalOperator shiftExpression
relationalOperator:
        ">="
        ">"
        "<="
        "<"
shiftExpression:
        additiveExpression (shiftOperator additiveExpression)*
        "super" (shiftOperator additiveExpression)+
shiftOperator:
        "<<"
        ">>>"
        ">>"
additiveExpression:
        multiplicativeExpression (additiveOperator multiplicativeExpression)*
        "super" (additiveOperator multiplicativeExpression)+
additiveOperator:
        "+"
        "-"
multiplicativeExpression:
        unaryExpression (multiplicativeOperator unaryExpression)*
        "super" (multiplicativeOperator unaryExpression)+
multiplicativeOperator:
        "*"
        "/"
        "%"
        "~/"
unaryExpression:
        prefixOperator unaryExpression
        postfixExpression
        unaryOperator "super"
        "-" "super"
        incrementOperator assignableExpression
postfixExpression:
        assignableExpression postfixOperator
        primary selector*
postfixOperator:
        incrementOperator
incrementOperator:
        "++"
        "--"
assignableExpression:
        primary (arguments* assignableSelector)+
        "super" assignableSelector
        identifier
selector:
        assignableSelector
        arguments
assignableSelector:
        "[" expression "]"
        "." identifier
identifier:
        IDENTIFIER_NO_DOLLAR
        IDENTIFIER
        BUILT_IN_IDENTIFIER
IDENTIFIER_NO_DOLLAR:
        IDENTIFIER_START_NO_DOLLAR IDENTIFIER_PART_NO_DOLLAR*
IDENTIFIER:
        IDENTIFIER_START IDENTIFIER_PART*
BUILT_IN_IDENTIFIER:
        "abstract"
        "assert"
        "Dynamic"
        "factory"
        "get"
        "implements"
        import
        "interface"
        "library"
        "negate"
        operator
        "set"
        "source"
        "static"
        "typedef"
IDENTIFIER_START:
        IDENTIFIER_START_NO_DOLLAR
        "$"
IDENTIFIER_START_NO_DOLLAR:
        "LETTER"
        "_"
IDENTIFIER_PART_NO_DOLLAR:
        IDENTIFIER_START_NO_DOLLAR
        DIGIT
IDENTIFIER_PART:
        IDENTIFIER_START
        DIGIT
qualified:
        identifier ("." identifier)?
isOperator:
        "is" "!"?
statements:
        statement*
statement:
        label* nonLabelledStatement
nonLabelledStatement:
        block
        initializedVariableDeclaration ";"
        forStatement
        whileStatement
        doStatement
        switchStatement
        ifStatement
        tryStatement
        breakStatement
        continueStatement
        returnStatement
        throwStatement
        expressionStatement
        assertStatement
        functionSignature functionBody
expressionStatement:
        expression? ";"
ifStatement:
        "if" "(" expression ")" statement ("else" statement)?
forStatement:
        "for" "(" forLoopParts ")" statement
forLoopParts:
        forInitializerStatement expression? ";" expressionList?
        declaredIdentifier "in" expression
        identifier "in" expression
forInitializerStatement:
        initializedVariableDeclaration ";"
        expression? ";"
whileStatement:
        "while" "(" expression ")" statement
doStatement:
        "do" statement "while" "(" expression ")" ";"
switchStatement:
        "switch" "(" expression ")" "{" switchCase* defaultCase? "}"
switchCase:
        label? ("case" expression ":")+ statements
defaultCase:
        label? ("case" expression ":")* "default" ":" statements
tryStatement:
        "try" block ((catchPart+ finallyPart?) | finallyPart)
catchPart:
        "catch" "(" simpleFormalParameter ("," simpleFormalParameter)? ")" block
finallyPart:
        "finally" block
returnStatement:
        "return" expression? ";"
label:
        identifier ":"
breakStatement:
        "break" identifier? ";"
continueStatement:
        "continue" identifier? ";"
throwStatement:
        "throw" expression? ";"
assertStatement:
        "assert" "(" conditionalExpression ")" ";"
topLevelDefinition:
        classDefinition
        interfaceDefinition
        functionTypeAlias
        functionSignature functionBody
        returnType? getOrSet identifier formalParameterList functionBody
        "final" type? staticFinalDeclarationList ";"
        variableDeclaration ";"
getOrSet:
        "get"
        "set"
libraryDefinition:
        scriptTag? libraryName import* include* resource* topLevelDefinition*
scriptTag:
        "#!" ("~" NEWLINE)* NEWLINE
libraryName:
        "#" "library" "(" stringLiteral ")" ";"
resource:
        "#" "resource" "(" stringLiteral ")" ";"
import:
        "#" "import" "(" stringLiteral ("," "prefix:" stringLiteral)? ")" ";"
include:
        "#" "source" "(" stringLiteral ")" ";"
compilationUnit:
        topLevelDefinition* EOF
scriptDefinition:
        scriptTag? libraryName? import* include* resource* topLevelDefinition*
type:
        qualified typeArguments?
typeArguments:
        "<" typeList ">"
typeList:
        type ("," type)*
functionTypeAlias:
        "typedef" functionPrefix typeParameters? formalParameterList ";"
functionPrefix:
        returnType? identifier
DIGIT:
        "0"
        "1"
        "2"
        "3"
        "4"
        "5"
        "6"
        "7"
        "8"
        "9"
WHITESPACE:
        ("\t" | " " | NEWLINE)+
SINGLE_LINE_COMMENT:
        "//" "~" NEWLINE* NEWLINE?
MULTI_LINE_COMMENT:
        "/*" (MULTI_LINE_COMMENT | ("~" "*/"))* "*/"
