LocalVarDec:
        localVarDec(Type {VarDec ","}+)
TypeParams:
        typeParams("<" {TypeParam ","}+ ">")
Literal:
        CharLiteral
Literal:
        BoolLiteral
Literal:
        ClassLiteral
Literal:
        FloatLiteral
Literal:
        StringLiteral
Literal:
        NullLiteral
Literal:
        IntLiteral
ClassMod:
        "abstract"
ClassMod:
        "static"
ClassMod:
        "public"
ClassMod:
        "strictfp"
ClassMod:
        "final"
ClassMod:
        "private"
ClassMod:
        "protected"
ClassDecHead:
        classDecHead("class" Id TypeParams? Super? Interfaces?)
ClassDec:
        EnumDec
ClassDec:
        classDec(ClassDecHead ClassBody)
SwitchGroup:
        switchGroup(SwitchLabel+ BlockStm+)
ClassBodyDec:
        ClassMemberDec
ClassBodyDec:
        StaticInit
ClassBodyDec:
        ConstrDec
ClassBodyDec:
        InstanceInit
FloatType:
        double"double"
FloatType:
        float"float"
ClassMemberDec:
        ClassDec
ClassMemberDec:
        MethodDec
ClassMemberDec:
        FieldDec
ClassMemberDec:
        semicolon";"
ClassMemberDec:
        InterfaceDec
ConstantMod:
        "static"
ConstantMod:
        "public"
ConstantMod:
        "final"
ConstantDec:
        constantDec(Type {VarDec ","}+ ";")
SwitchBlock:
        switchBlock("{" SwitchGroup* SwitchLabel* "}")
CondMid:
        "?" Expr ":"
WildcardBound:
        wildcardUpperBound("extends" RefType)
WildcardBound:
        wildcardLowerBound("super" RefType)
EnumDecHead:
        enumDecHead("enum" Id Interfaces?)
PackageOrTypeName:
        packageOrTypeNameId
PackageOrTypeName:
        packageOrTypeName(PackageOrTypeName "." Id)
InterfaceDecHead:
        interfaceDecHead("interface" Id TypeParams? ExtendsInterfaces?)
IntType:
        int"int"
IntType:
        byte"byte"
IntType:
        long"long"
IntType:
        short"short"
IntType:
        char"char"
VarInit:
        Expr
VarInit:
        ArrayInit
EnumBodyDecs:
        enumBodyDecs(";" ClassBodyDec*)
ClassType:
        classType(TypeDecSpec TypeArgs?)
ExtendsInterfaces:
        extendsInterfaces("extends" {InterfaceType ","}+)
StaticInit:
        staticInit("static" Block)
FormalParam:
        varArityParam(Type "..." VarDecId)
FormalParam:
        param(Type VarDecId)
EnumConstArgs:
        "(" {Expr ","}* ")"
LocalVarDecStm:
        localVarDecStm(LocalVarDec ";")
CompilationUnit:
        compilationUnit(PackageDec? ImportDec* TypeDec*)
EnumConst:
        enumConst(Id EnumConstArgs? ClassBody?)
NumType:
        FloatType
NumType:
        IntType
MethodDecHead:
        deprMethodDecHead(TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws?)
MethodDecHead:
        methodDecHead(TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?)
Anno:
        singleElemAnno("@" TypeName "(" ")")
Anno:
        anno("@" TypeName "(" {ElemValPair ","}* ")")
Anno:
        markerAnno("@" TypeName)
FieldDec:
        fieldDec(Type {VarDec ","}+ ";")
FieldMod:
        "public"
FieldMod:
        "static"
FieldMod:
        "transient"
FieldMod:
        "final"
FieldMod:
        "volatile"
FieldMod:
        "private"
FieldMod:
        "protected"
ArraySubscript:
        "[" Expr "]"
FloatLiteral:
        floatEPSILON
ConstrBody:
        constrBody("{" ConstrInv? BlockStm* "}")
PackageName:
        packageName{Id "."}+
FieldAccess:
        qSuperField(TypeName "." "super" "." Id)
FieldAccess:
        field("." Id)
FieldAccess:
        superField("super" "." Id)
ConstrInv:
        qSuperConstrInv(Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";")
ConstrInv:
        superConstrInv(TypeArgs? "super" "(" {Expr ","}* ")" ";")
ConstrInv:
        altConstrInv(TypeArgs? "this" "(" {Expr ","}* ")" ";")
IntLiteral:
        octaEPSILON
IntLiteral:
        hexaEPSILON
IntLiteral:
        deciEPSILON
InterfaceMemberDec:
        semicolon";"
InterfaceMemberDec:
        InterfaceDec
InterfaceMemberDec:
        AbstractMethodDec
InterfaceMemberDec:
        ClassDec
InterfaceMemberDec:
        ConstantDec
ElemValPair:
        elemValPair(Id "=")
CatchClause:
        catch("catch" "(" FormalParam ")" Block)
ArrayInit:
        arrayInit("{" {VarInit ","}* "," "}")
ArrayInit:
        arrayInit("{" {VarInit ","}* "}")
VarDecId:
        Id
VarDecId:
        arrayVarDecId(Id Dim+)
Modifier:
        "protected"
Modifier:
        "private"
Modifier:
        "volatile"
Modifier:
        "synchronized"
Modifier:
        "final"
Modifier:
        "strictfp"
Modifier:
        "transient"
Modifier:
        "abstract"
Modifier:
        "native"
Modifier:
        "static"
Modifier:
        "public"
ElemVal:
        elemValArrayInit("{" {ElemVal ","}* "}")
ElemVal:
        Expr
ElemVal:
        Anno
ElemVal:
        elemValArrayInit("{" {ElemVal ","}* "," "}")
ConstrDec:
        constrDec(ConstrHead ConstrBody)
ConstrMod:
        "protected"
ConstrMod:
        "private"
ConstrMod:
        "public"
InterfaceType:
        interfaceType(TypeDecSpec TypeArgs?)
PackageDec:
        packageDec(Anno* "package" PackageName ";")
ArrayAccess:
        arrayAccessArraySubscript
ImportDec:
        typeImportOnDemandDec("import" PackageName "." "*" ";")
ImportDec:
        typeImportDec("import" TypeName ";")
ImportDec:
        staticImportDec("import" "static" TypeName "." Id ";")
ImportDec:
        staticImportOnDemandDec("import" "static" TypeName "." "*" ";")
ArrayBaseType:
        TypeName
ArrayBaseType:
        PrimType
ArrayBaseType:
        unboundWld(TypeName "<" "?" ">")
TypeName:
        typeName(PackageOrTypeName "." Id)
TypeName:
        typeNameId
SwitchLabel:
        case("case" Expr ":")
SwitchLabel:
        default("default" ":")
ConstrHead:
        constrDecHead(TypeParams? Id "(" {FormalParam ","}* ")" Throws?)
Stm:
        synchronized("synchronized" "(" Expr ")" Block)
Stm:
        exprStm(Expr ";")
Stm:
        for("for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm)
Stm:
        for("for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm)
Stm:
        Block
Stm:
        continue("continue" Id? ";")
Stm:
        try("try" Block CatchClause+)
Stm:
        throw("throw" Expr ";")
Stm:
        switch("switch" "(" Expr ")" SwitchBlock)
Stm:
        if("if" "(" Expr ")" Stm)
Stm:
        break("break" Id? ";")
Stm:
        empty";"
Stm:
        labeled(Id ":" Stm)
Stm:
        assertStm("assert" Expr ":" Expr ";")
Stm:
        forEach("for" "(" FormalParam ":" Expr ")" Stm)
Stm:
        assertStm("assert" Expr ";")
Stm:
        try("try" Block CatchClause* "finally" Block)
Stm:
        return("return" Expr? ";")
Stm:
        doWhile("do" Stm "while" "(" Expr ")" ";")
Stm:
        while("while" "(" Expr ")" Stm)
Stm:
        if("if" "(" Expr ")" Stm "else" Stm)
NullLiteral:
        null"null"
ExceptionType:
        ClassType
ResultType:
        Type
ResultType:
        void"void"
Expr:
        postDecr(Expr "--")
Expr:
        postIncr(Expr "++")
Expr:
        castPrim("(" PrimType ")" Expr)
Expr:
        castRef("(" RefType ")" Expr)
Expr:
        minusExpr
Expr:
        preIncr("++" Expr)
Expr:
        plusExpr
Expr:
        preDecr("--" Expr)
Expr:
        this"this"
Expr:
        mul(Expr "*" Expr)
Expr:
        div(Expr Expr)
Expr:
        remain(Expr "%" Expr)
Expr:
        qThis(TypeName "." "this")
Expr:
        complement("~" Expr)
Expr:
        not("!" Expr)
Expr:
        plus(Expr Expr)
Expr:
        minus(Expr Expr)
Expr:
        uRightShift(Expr ">>>" Expr)
Expr:
        rightShift(Expr ">>" Expr)
Expr:
        leftShift(Expr "<<" Expr)
Expr:
        ltEq(Expr "<=" Expr)
Expr:
        lt(Expr "<" Expr)
Expr:
        gtEq(Expr ">=" Expr)
Expr:
        instanceOf(Expr "instanceof" RefType)
Expr:
        gt(Expr ">" Expr)
Expr:
        eq(Expr "==" Expr)
Expr:
        notEq(Expr "!=" Expr)
Expr:
        and(Expr "&" Expr)
Expr:
        excOr(Expr "^" Expr)
Expr:
        or(Expr "|" Expr)
Expr:
        lazyAnd(Expr "&&" Expr)
Expr:
        lazyOr(Expr "||" Expr)
Expr:
        cond(Expr CondMid Expr)
Expr:
        assignMinus(LHS "-=" Expr)
Expr:
        assignExcOr(LHS "^=" Expr)
Expr:
        assignPlus(LHS "+=" Expr)
Expr:
        assignURightShift(LHS ">>>=" Expr)
Expr:
        assignAnd(LHS "&=" Expr)
Expr:
        assignDiv(LHS "/=" Expr)
Expr:
        assignMul(LHS "*=" Expr)
Expr:
        assignRemain(LHS "%=" Expr)
Expr:
        assignLeftShift(LHS "<<=" Expr)
Expr:
        assignRightShift(LHS ">>=" Expr)
Expr:
        assignOr(LHS "|=" Expr)
Expr:
        assign(LHS "=" Expr)
Expr:
        qNewInstance(Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody?)
Expr:
        litLiteral
Expr:
        newInstance("new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody?)
Expr:
        exprNameExprName
Expr:
        ArrayCreationExpr
Expr:
        "(" Expr ")"
Expr:
        EPSILON
Expr:
        invoke(MethodSpec "(" {Expr ","}* ")")
ArrayType:
        arrayType(Type "[" "]")
ClassBody:
        classBody("{" ClassBodyDec* "}")
TypeDecSpec:
        TypeName
TypeDecSpec:
        member(TypeDecSpec TypeArgs "." Id)
PrimType:
        NumType
PrimType:
        boolean"boolean"
EnumDec:
        enumDec(EnumDecHead EnumBody)
ActualTypeArg:
        Type
ActualTypeArg:
        wildcard("?" WildcardBound?)
MethodName:
        methodName(AmbName "." Id)
MethodName:
        methodNameId
InterfaceDec:
        InterfaceDecHead "{" InterfaceMemberDec* "}"
InterfaceDec:
        AnnoDecHead "{" AnnoElemDec* "}"
InterfaceMod:
        "public"
InterfaceMod:
        "static"
InterfaceMod:
        "abstract"
InterfaceMod:
        "strictfp"
InterfaceMod:
        "protected"
InterfaceMod:
        "private"
ClassLiteral:
        voidClass("void" "." "class")
ClassLiteral:
        class(Type "." "class")
StringLiteral:
        EPSILON
AbstractMethodMod:
        "abstract"
AbstractMethodMod:
        "public"
AbstractMethodDec:
        abstractMethodDec(TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";")
AbstractMethodDec:
        deprAbstractMethodDec(TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";")
Id:
        idEPSILON
TypeBound:
        typeBound("extends" {ClassOrInterfaceType "&"}+)
AnnoElemDec:
        EnumDec
AnnoElemDec:
        semicolon";"
AnnoElemDec:
        ClassDec
AnnoElemDec:
        ConstantDec
AnnoElemDec:
        InterfaceDec
AnnoElemDec:
        annoMethodDec(AbstractMethodMod* Type Id "(" ")" DefaultVal? ";")
BoolLiteral:
        false"false"
BoolLiteral:
        true"true"
MethodBody:
        noMethodBody";"
MethodBody:
        Block
ExprName:
        exprNameId
ExprName:
        exprName(AmbName "." Id)
DefaultVal:
        defaultVal"default"
MethodDec:
        methodDec(MethodDecHead MethodBody)
AmbName:
        ambName(AmbName "." Id)
AmbName:
        ambNameId
MethodMod:
        "final"
MethodMod:
        "strictfp"
MethodMod:
        "synchronized"
MethodMod:
        "protected"
MethodMod:
        "private"
MethodMod:
        "static"
MethodMod:
        "public"
MethodMod:
        "abstract"
MethodMod:
        "native"
ArrayCreationExpr:
        newArray("new" ArrayBaseType DimExpr+)
ArrayCreationExpr:
        newArray("new" ArrayBaseType ArrayInit)
RefType:
        ClassOrInterfaceType
RefType:
        ArrayType
TypeDec:
        InterfaceDec
TypeDec:
        ClassDec
TypeDec:
        semicolon";"
TypeArgs:
        typeArgs("<" {ActualTypeArg ","}+ ">")
LHS:
        ExprName
LHS:
        EPSILON
AnnoDecHead:
        annoDecHead("@" "interface" Id)
TypeParam:
        typeParam(TypeVarId TypeBound?)
MethodSpec:
        methodMethodName
MethodSpec:
        superMethod("super" "." TypeArgs? Id)
MethodSpec:
        genericMethod(AmbName "." TypeArgs Id)
MethodSpec:
        qSuperMethod(TypeName "." "super" "." TypeArgs? Id)
MethodSpec:
        method("." TypeArgs? Id)
Type:
        RefType
Type:
        PrimType
Super:
        superDec("extends" ClassType)
CharLiteral:
        EPSILON
InstanceInit:
        instanceInitBlock
EnumBody:
        enumBody("{" {EnumConst ","}* EnumBodyDecs? "}")
EnumBody:
        enumBody("{" {EnumConst ","}* "," EnumBodyDecs? "}")
Throws:
        throwsDec("throws" {ExceptionType ","}+)
Block:
        block("{" BlockStm* "}")
TypeVar:
        typeVarTypeVarId
TypeVarId:
        Id
Dim:
        dim("[" "]")
BlockStm:
        Stm
BlockStm:
        classDecStmClassDec
BlockStm:
        LocalVarDecStm
DimExpr:
        dim("[" Expr "]")
Interfaces:
        implementsDec("implements" {InterfaceType ","}+)
VarMod:
        "final"
VarDec:
        varDec(VarDecId "=" VarInit)
VarDec:
        varDecVarDecId
ClassOrInterfaceType:
        classOrInterfaceType(TypeDecSpec TypeArgs?)
