program:
        statement*
statement:
        includeStatement
        keysStatement
        compoundsStatement
        commentsStatement
        tokensStatement
        defineStatement
        redefineStatement
        ruleStatement
        functionStatement
        externalStatement
        comment NL
includeStatement:
        "include" stringlit NL
keysStatement:
        "keys" NL IN keyword* EX NL "end" "keys" NL NL
keyword:
        literal SP
        key SP
compoundsStatement:
        "compounds" NL IN compound* EX NL "end" "compounds" NL NL
compound:
        literal SP
commentsStatement:
        "comments" NL IN commentConvention* EX "end" "comments" NL NL
commentConvention:
        literal SP literal NL
        literal NL
tokensStatement:
        "tokens" NL IN tokenPattern* EX "end" "tokens" NL NL
tokenPattern:
        typeid TAB_24 stringlit NL
        TAB_16 "|" TAB_24 stringlit NL
        typeid TAB_16 "..."? "|" TAB_24 stringlit NL
        typeid TAB_16 "+" TAB_24 stringlit NL
        comment NL
defineStatement:
        "define" typeid NL IN IN literalOrType* NL barLiteralsAndTypes* EX EX "end" "define" NL NL RESET
redefineStatement:
        "redefine" typeid NL IN IN dotDotDotBar? literalOrType* NL barLiteralsAndTypes* barDotDotDot? EX EX "end" redefineOrDefine NL NL RESET
redefineOrDefine:
        "redefine"
        "define"
RESET:
        EX EX EX EX EX EX EX EX EX
dotDotDotBar:
        "..." EX NL "|" TAB IN
barDotDotDot:
        EX "|" TAB IN "..." NL
barLiteralsAndTypes:
        EX "|" TAB IN literalOrType* NL
literalOrType:
        type SP
        literal SP
type:
        formatCues
        "[" typeSpec "]"
formatCues:
        IN IN formatCue+ EX EX optNL?
optNL:
        NL
formatCue:
        "[" formatId "]"
formatId:
        "NL"
        "IN" IN
        "EX" EX
typeSpec:
        typeModifier? typeid typeRepeater?
        "!"
typeModifier:
        "opt"
        "repeat"
        "list"
        "attr"
        "see"
        "not"
        "push"
        "pop"
        ":"
        "~"
        ">"
        "<"
typeRepeater:
        "+"
        "*"
        "?"
        ","
        ",+"
typeidOrQuotedLiteral:
        typeid
        quotedLiteral
ruleStatement:
        "rule" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "replace" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX "by" NL IN replacement EX EX "end" "rule" NL NL
        "rule" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "match" dollarStar? SP type NL IN pattern EX EX constructDeconstructImportExportOrCondition* "end" "rule" NL NL
functionStatement:
        "function" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "replace" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX "by" NL IN replacement EX EX "end" "function" NL NL
        "function" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "match" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX EX "end" "function" NL NL
dollarStar:
        SP "$"
        SP "*"
externalStatement:
        "external" "rule" ruleid formalArgument* NL NL
        "external" "function" ruleid formalArgument* NL NL
formalArgument:
        varid SP type commentNL*
constructDeconstructImportExportOrCondition:
        constructor
        deconstructor
        condition
        importer
        exporter
        EX comment NL IN
constructor:
        EX "construct" varid SP type NL IN replacement
deconstructor:
        EX skippingType? "deconstruct" "not"? "*"? type? varid NL IN pattern
condition:
        EX "where" "not"? "all"? NL IN commentNL* expression NL
        EX "assert" "not"? "all"? NL IN commentNL* expression NL
importer:
        EX "import" varid type? NL IN pattern?
exporter:
        EX "export" varid type? NL IN replacement?
skippingType:
        "skipping" SP type commentNL*
pattern:
        literalOrVariable* NL
literalOrVariable:
        literal SP
        varid SP type SP
        varid SP
replacement:
        literalOrExpression* NL
literalOrExpression:
        literal SP
        expression SP
expression:
        varid ruleApplications?
ruleApplications:
        IN IN commentNL* ruleApplication+ EX EX ruleoptNL?
ruleoptNL:
        NL
ruleApplication:
        SP "[" ruleid varidOrLiteral* eachArgs? "]" commentNL*
        SP lengthrule varidOrLiteral* eachArgs? "]" commentNL*
commentNL:
        SP SP comment NEWoptNL?
NEWoptNL:
        NL
eachArgs:
        SP "each" varidOrLiteral*
varidOrLiteral:
        SP varid
        SP literal
literal:
        quotedLiteral
        unquotedLiteral
        SP comment NEWoptNL?
quotedLiteral:
        "'" unquotedLiteral
        "'" key
unquotedLiteral:
        SP "'"
        token
varid:
        id
typeid:
        id
        SP literal
ruleid:
        id
        special
        "#"
        key
