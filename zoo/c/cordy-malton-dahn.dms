program = compilation_unit ;
compilation_unit = function_definition_or_declaration* ;
function_definition_or_declaration = function_definition ;
function_definition_or_declaration = declaration ;
function_definition_or_declaration = preprocessor ;
function_definition_or_declaration = compound_statement NL ;
function_definition_or_declaration = macro_declaration_or_statement ;
function_definition_or_declaration = unknown_declaration_or_statement ;
function_definition = NL function_header preprocessor_function_header* KR_parameter_decls? compound_statement NL ;
function_header = decl_specifiers? declarator function_declarator_extension attribute_spec* ;
function_header = 'YY_DECL' NL ;
preprocessor_function_header = NL preprocessor function_header ;
preprocessor_function_header = NL function_header ;
preprocessor = TAB_1 preprocessor_line NL ;
KR_parameter_decls = (NL IN) KR_simple_declaration+ EX ;
KR_simple_declaration = decl_specifiers? KR_simple_type_name decl_specifiers? declarator+ semi ;
KR_simple_type_name = simple_type_name ;
KR_simple_type_name = struct_or_union id ;
KR_simple_type_name = enum_specifier ;
KR_simple_type_name = bit_qualifier ;
declaration = decl_specifiers init_declarator',' semi ;
declaration = decl_specifiers declarator '=' compound_initializer NL ;
declaration = extern_langauge_declaration ;
declaration = null_declaration ;
declaration = local_label declarator+ ;
declaration = asm_spec ;
declaration = machinestart_declaration ;
declaration = preprocessor ;
extern_langauge_declaration = 'extern' stringlit '{' (IN NL) declaration* EX '}' ';'? NL ;
null_declaration = semi ;
semi = ';' NL ;
local_label = '__label__' ;
decl_specifiers = decl_qualifier_or_type_specifier+ ;
decl_qualifier_or_type_specifier = decl_qualifier ;
decl_qualifier_or_type_specifier = type_specifier ;
decl_qualifier_or_type_specifier = macro_specifier nosemiNL? ;
nosemiNL = NL ;
struct_or_union_specifier = struct_or_union attribute_spec* reference_id? struct_or_union_body attribute_spec* ;
struct_or_union_specifier = struct_or_union attribute_spec* reference_id attribute_spec* ;
struct_or_union_body = '{' (IN NL) member_declaration* EX '}' ;
member_declaration = decl_specifiers member_declarator',' semi ;
member_declaration = null_declaration ;
member_declaration = preprocessor ;
member_declarator = declarator bitfieldsize? sub_member_declarators? attributes_or_asm* ;
member_declarator = bitfieldsize ;
sub_member_declarators = '(' member_declarator',' ')' ;
attributes_or_asm = attribute_spec ;
attributes_or_asm = asm_spec ;
attribute_spec = attribute_specifier '('(' attribute_extension',' ')')' ;
attribute_spec = (IN NL) acquires_releases '(' expression ')' EX ;
attribute_spec = upper_macro_name ;
acquires_releases = '__acquires' ;
acquires_releases = '__releases' ;
attribute_specifier = '__attribute__' ;
attribute_specifier = '__attribute' ;
attribute_extension = attribute_name attribute_arguments? ;
attribute_name = id ;
attribute_name = cv_qualifier ;
attribute_arguments = '(' attribute_argument+ ')' ;
attribute_argument = '(' attribute_argument* ')' ;
attribute_argument = token_or_key ;
bitfieldsize = ':' constant_expression ;
decl_qualifier = sc_specifier ;
decl_qualifier = type_qualifier ;
decl_qualifier = extension_specifier ;
decl_qualifier = weak_specifier ;
decl_qualifier = declspec_specifier ;
macro_specifier = macro_call ;
sc_specifier = 'auto' ;
sc_specifier = 'register' ;
sc_specifier = 'static' ;
sc_specifier = 'extern' ;
sc_specifier = 'far' ;
sc_specifier = 'near' ;
sc_specifier = 'typedef' ;
sc_specifier = 'local' ;
sc_specifier = 'vector' ;
sc_specifier = 'const_debug' ;
sc_specifier = 'INIT' ;
sc_specifier = 'STATIC' ;
sc_specifier = 'NEAR' ;
sc_specifier = 'FAR' ;
type_specifier = simple_type_name ;
type_specifier = enum_specifier ;
type_specifier = struct_or_union_specifier ;
type_specifier = typeof_expression ;
type_specifier = complex_specifier ;
typeof_expression = typeof_specifier '(' expression_or_type_name ')' ;
expression_or_type_name = type_name ;
expression_or_type_name = expression ;
typeof_specifier = '__typeof' ;
typeof_specifier = 'typeof' ;
typeof_specifier = '__typeof__' ;
typeof_specifier = 'typeof__' ;
complex_specifier = complex simple_type_or_qualifier* ;
complex = '__complex' ;
complex = '__complex__' ;
complex = '__Complex' ;
simple_type_or_qualifier = simple_type_name ;
simple_type_or_qualifier = type_qualifier ;
type_qualifier = bit_qualifier ;
type_qualifier = cv_qualifier ;
type_qualifier = inline_qualifier ;
type_qualifier = restrict_qualifier ;
type_qualifier = init_qualifier ;
type_qualifier = exit_qualifier ;
type_qualifier = user_qualifier ;
type_qualifier = force_qualifier ;
type_qualifier = asmlinkage_qualifier ;
type_qualifier = zexport_qualifier ;
type_qualifier = attribute_spec ;
bit_qualifier = 'long' ;
bit_qualifier = 'short' ;
bit_qualifier = 'signed' ;
bit_qualifier = 'unsigned' ;
bit_qualifier = '__signed__' ;
bit_qualifier = '__signed' ;
inline_qualifier = '__inline' ;
inline_qualifier = '__inline__' ;
inline_qualifier = 'inline__' ;
inline_qualifier = 'inline' ;
inline_qualifier = 'SBA_INLINE' ;
init_qualifier = '__init' ;
init_qualifier = 'init__' ;
init_qualifier = 'init' ;
init_qualifier = '__init__' ;
exit_qualifier = '__exit' ;
exit_qualifier = 'exit__' ;
exit_qualifier = 'exit' ;
exit_qualifier = '__exit__' ;
user_qualifier = '__user' ;
user_qualifier = 'user__' ;
user_qualifier = 'user' ;
user_qualifier = '__user__' ;
force_qualifier = '__force' ;
force_qualifier = 'force__' ;
force_qualifier = 'force' ;
force_qualifier = '__force__' ;
asmlinkage_qualifier = 'asmlinkage' ;
zexport_qualifier = 'ZEXPORT' ;
simple_type_name = 'char' ;
simple_type_name = 'int' ;
simple_type_name = 'void' ;
simple_type_name = 'float' ;
simple_type_name = 'double' ;
simple_type_name = type_id ;
type_id = reference_id ;
macro_type_arguments = '(' macro_type_argument',' ')' ;
macro_type_argument = argument_expression ;
struct_or_union = 'struct' ;
struct_or_union = 'union' ;
enum_specifier = 'enum' reference_id ;
enum_specifier = 'enum' reference_id? '{' enumerator',' ','? preprocessor* '}' ;
enumerator = preprocessor* reference_id enumerator_value? ;
enumerator_value = '=' constant_expression ;
extension_specifier = '__extension__' ;
extension_specifier = '__extension' ;
weak_specifier = '__weak__' ;
weak_specifier = '__weak' ;
declspec_specifier = '__declspec' '(' decl_specifiers ')' ;
init_declarator = declarator attributes_or_asm* initialization? ;
declarator = attribute_spec* ptr_operator* base_declarator SPON declarator_extension* attribute_spec* ;
base_declarator = reference_id ;
base_declarator = SPON '(' decl_specifiers? declarator ')' ;
declarator_extension = function_declarator_extension ;
declarator_extension = array_declarator_extension ;
function_declarator_extension = '(' argument_declaration_list ')' cv_qualifier* ;
array_declarator_extension = '[' constant_expression? ']' ;
ptr_operator = nf_qualifier? '*' SPOFF ptr_qualifier* ;
ptr_operator = nf_qualifier? '(' '*' ')' SPOFF ptr_qualifier* ;
nf_qualifier = 'near' ;
nf_qualifier = 'far' ;
nf_qualifier = 'NEAR' ;
nf_qualifier = 'FAR' ;
ptr_qualifier = SPON cv_qualifier ;
ptr_qualifier = SPON inline_qualifier ;
ptr_qualifier = SPON restrict_qualifier ;
ptr_qualifier = SPON init_qualifier ;
ptr_qualifier = SPON exit_qualifier ;
ptr_qualifier = SPON user_qualifier ;
ptr_qualifier = SPON zexport_qualifier ;
cv_qualifier = 'const' ;
cv_qualifier = 'volatile' ;
cv_qualifier = 'CONST' ;
cv_qualifier = '__const' ;
cv_qualifier = '__const__' ;
cv_qualifier = 'const__' ;
cv_qualifier = '__volatile__' ;
cv_qualifier = '__volatile' ;
cv_qualifier = 'volatile__' ;
cv_qualifier = '__iomem' ;
cv_qualifier = initdata ;
cv_qualifier = 'internal_function' ;
cv_qualifier = 'yyconst' ;
cv_qualifier = 'pascal' ;
cv_qualifier = upper_macro_name ;
restrict_qualifier = '__restrict' ;
restrict_qualifier = 'restrict__' ;
restrict_qualifier = 'restrict' ;
restrict_qualifier = '__restrict__' ;
type_name = type_specifiers abstract_declarator* ;
type_specifiers = type_qualifier* type_specifier type_qualifier* ;
type_specifiers = type_qualifier+ ;
abstract_declarator = ptr_operator+ declarator_extension* SPON ;
abstract_declarator = array_declarator_extension ;
abstract_declarator = '(' abstract_declarator+ ')' declarator_extension* ;
abstract_declarator = '(' type_name+ ')' ;
abstract_declarator = 'static' ;
argument_declaration_list = argument_declaration',' comma_dotdotdot? ;
argument_declaration = decl_specifiers argument_declarator? ;
argument_declaration = '(' argument_declaration ')' ;
comma_dotdotdot = ',' SP '...' SP ;
argument_declarator = declarator attributes_or_asm* ;
argument_declarator = abstract_declarator attributes_or_asm* ;
initialization = initdata? '=' initializer ;
initialization = '(' constant_expression ')' ;
initialization = macro_call ;
initdata = '__initdata' ;
initdata = '__devinitdata' ;
initdata = '__cpuinitdata' ;
initdata = '__read_mostly' ;
initdata = '__initmv' ;
initdata = '__initdata_or_module' ;
initdata = '__pminitdata' ;
initdata = '__cpuinit' ;
initdata = '__devinit' ;
initdata = 'BDATA' ;
initdata = 'compat_init_data' ;
initdata = 'in2000__INITDATA' ;
initializer = preprocessor* initializer_unit+ ;
initializer =  initializer_unit ;
initializer_unit = assignment_expression ;
initializer_unit = compound_initializer ;
initializer_unit = NL element_label colon_equals_or_equals? initializer ';'? ;
initializer_unit = NL '[' constant_expression dotdotdot? constant_expression? ']' '='? initializer ';'? ;
initializer_unit = macro_call ;
colon_equals_or_equals = ':' ;
colon_equals_or_equals = '=' ;
colon_equals_or_equals = '|=' ;
compound_initializer = '{' '}' ;
compound_initializer = '{' IN initializer',' ','? ';'? preprocessor_list_initializer* (EX NL) '}' ;
dotdotdot = SP '...' SP ;
element_label = '.'? element_name element_name_extension* ;
element_name_extension = '.' element_name ;
element_name_extension = '[' constant_expression ']' ;
element_name = id ;
preprocessor_list_initializer = preprocessor initializer',' ','? ;
statement = preprocessor* label* unlabeled_statement ;
statement = label ;
statement = preprocessor ;
label = EX label_id ':' (IN NL) ;
label = EX SP SP 'case' constant_expression ':' (IN NL) ;
label = EX SP SP 'default' ':' (IN NL) ;
label = EX SP SP 'case' constant_expression SP '...' SP constant_expression ':' (IN NL) ;
label_id = id ;
unlabeled_statement = c_unlabeled_statement ;
unlabeled_statement = gnu_statement ;
gnu_statement = error_statement ;
gnu_statement = else_statement ;
error_statement = 'error' ':'? id+ '+'? id* semi? ;
c_unlabeled_statement = simple_statement semi ;
c_unlabeled_statement = structured_statement ;
simple_statement_opt_semi = simple_statement semi? ;
structured_statement = if_statement ;
structured_statement = for_statement ;
structured_statement = while_statement ;
structured_statement = switch_statement ;
structured_statement = do_statement ;
structured_statement = compound_statement ;
structured_statement = asm_statement ;
simple_statement = jump_statement ;
simple_statement = null_statement ;
simple_statement = expression_statement ;
null_statement = ;
compound_statement = '{' (IN NL) compound_statement_body EX '}' ';'? NL preprocessor* ;
compound_statement_body = declaration_or_statement* ;
declaration_or_statement = declaration ;
declaration_or_statement = statement ;
declaration_or_statement = preprocessor ;
declaration_or_statement = function_definition ;
declaration_or_statement = macro_declaration_or_statement ;
declaration_or_statement = unknown_declaration_or_statement ;
expression_statement = pre_increment_operator* assignment_expression assign_assignment_expression* comma_expression_statement? ;
assign_assignment_expression = assignment_operator assignment_expression ;
comma_expression_statement = ',' expression_statement ;
if_statement = 'if' '(' expression_list preprocessor* ')' sub_statement else_statement? ;
if_statement = 'if' postfix_expression sub_statement else_statement? ;
sub_statement = compound_statement ;
sub_statement = (IN NL) statement EX ;
sub_statement = (IN NL) macro_declaration_or_statement EX ;
switch_statement = 'switch' '(' expression_list ')' sub_statement ;
switch_statement = 'switch' macro_call sub_statement ;
else_statement = preprocessor* 'else' else_sub_statement ;
else_sub_statement = if_statement ;
else_sub_statement = sub_statement ;
while_statement = 'while' '(' expression_list ')' sub_statement else_statement? ;
while_statement = whileeachid '(' expression_list ')' sub_statement else_statement? ;
do_statement = 'do' sub_statement 'while' '(' expression_list ')' semi ;
do_statement = 'do' sub_statement 'while' macro_call semi ;
do_statement = 'do' sub_statement whileeachid '(' expression_list ')' semi ;
for_statement = 'for' '(' expression_list? ';' expression_list? ';' expression_list? ')' sub_statement ;
for_statement = 'for' '(' decl_specifiers init_declarator+ ';' expression_list? ';' expression_list? ')' sub_statement ;
for_statement = 'for' '(' expression_list? ';' expression_list? ')' sub_statement ;
for_statement = foreachid '(' expression_list ')' sub_statement ;
jump_statement = 'goto' label_id ;
jump_statement = 'continue' ;
jump_statement = 'break' ;
jump_statement = 'return' expression? ;
jump_statement = 'goto' ptr_operator expression ;
jump_statement = 'return' expression attribute_spec? ;
asm_statement = asm_spec ;
asm_spec = asm cv_qualifier* '(' IN asm_template asm_output_operands? asm_input_operands? asm_clobbered_registers? EX ')' ;
asm_spec = asm cv_qualifier* '{' IN asm_instruction_semi* asm_instruction semi? EX '}' ;
asm_instruction_semi = asm_unit+ ';' NL ;
asm_instruction = asm_unit+ NL ;
asm_unit = token_or_key ;
token_or_key = token ;
token_or_key = key ;
asm = '__asm__' ;
asm = 'asm' ;
asm = 'asm__' ;
asm = '__asm' ;
asm_template = string_unit_NL+ ;
string_unit_NL = string_unit NL ;
asm_output_operands = ':' asm_operand',' NL ;
asm_input_operands = ':' asm_operand',' NL ;
asm_operand = bracketed_id? string '(' expression ')' ;
asm_operand = pseudo_string '(' expression ')' ;
bracketed_id = '[' id ']' ;
asm_clobbered_registers = ':' asm_register',' NL ;
asm_register = string ;
asm_register = pseudo_string ;
expression_list = expression+ ;
expression = assignment_expression ;
constant_expression = conditional_expression ;
assignment_expression = conditional_expression ;
assignment_expression = unary_expression_assign assignment_expression ;
unary_expression_assign = unary_expression assignment_operator ;
assignment_operator = '=' ;
assignment_operator = '*=' ;
assignment_operator = '/=' ;
assignment_operator = '%=' ;
assignment_operator = '+=' ;
assignment_operator = '-=' ;
assignment_operator = '>>=' ;
assignment_operator = '<<=' ;
assignment_operator = '&=' ;
assignment_operator = '^=' ;
assignment_operator = '|=' ;
conditional_expression = logical_OR_expression conditional_operation? ;
conditional_operation = '?' expression? ':' conditional_expression ;
logical_OR_expression = logical_AND_expression OR_logical_AND_expression* ;
OR_logical_AND_expression = logical_OR_operator logical_AND_expression ;
logical_OR_operator = '||' ;
logical_OR_operator = 'OR' ;
logical_OR_operator = 'or' ;
logical_AND_expression = inclusive_OR_expression AND_inclusive_OR_expression* ;
AND_inclusive_OR_expression = preprocessor* logical_AND_operator inclusive_OR_expression ;
logical_AND_operator = '&&' ;
logical_AND_operator = 'AND' ;
logical_AND_operator = 'and' ;
logical_AND_operator = 'ANDP' ;
inclusive_OR_expression = exclusive_OR_expression OR_exclusive_OR_expression* ;
OR_exclusive_OR_expression = bit_OR_operator exclusive_OR_expression ;
bit_OR_operator = '|' ;
bit_OR_operator = 'BIT_OR' ;
bit_OR_operator = 'bit_or' ;
exclusive_OR_expression = AND_expression exclusive_OR_AND_expression* ;
exclusive_OR_AND_expression = bit_XOR_operator AND_expression ;
bit_XOR_operator = '^' ;
bit_XOR_operator = 'BIT_XOR' ;
bit_XOR_operator = 'bit_xor' ;
AND_expression = equality_expression AND_equality_expression* ;
AND_equality_expression = bit_AND_operator equality_expression ;
bit_AND_operator = '&' ;
bit_AND_operator = 'BIT_AND' ;
bit_AND_operator = 'bit_and' ;
equality_expression = relational_expression equality_relational_expression* ;
equality_relational_expression = equality_operator relational_expression ;
equality_operator = '==' ;
equality_operator = '!=' ;
relational_expression = shift_expression relational_shift_expression* ;
relational_shift_expression = relational_operator shift_expression ;
relational_operator = '<' ;
relational_operator = '>' ;
relational_operator = '<=' ;
relational_operator = '>=' ;
shift_expression = additive_expression shift_additive_expression* ;
shift_additive_expression = shift_operator additive_expression ;
shift_operator = '<<' ;
shift_operator = '>>' ;
additive_expression = multiplicative_expression add_subtract_multiplicative_expression* ;
add_subtract_multiplicative_expression = additive_operator multiplicative_expression ;
additive_operator = '+' ;
additive_operator = '-' ;
multiplicative_expression = cast_expression multipy_divide_cast_expression* ;
multipy_divide_cast_expression = multiplicative_operator cast_expression ;
multiplicative_operator = '*' ;
multiplicative_operator = '/' ;
multiplicative_operator = '%' ;
multiplicative_operator = 'DIV' ;
multiplicative_operator = 'MOD' ;
cast_expression = cast_operator* unary_expression ;
cast_operator = '(' type_name ')' ;
unary_expression = pre_increment_operator* sub_unary_expression SPON ;
pre_increment_operator = '++' SPOFF ;
pre_increment_operator = '--' SPOFF ;
sub_unary_expression = postfix_expression ;
sub_unary_expression = unary_operator SPOFF cast_expression SPON ;
sub_unary_expression = SPON sizeof_expression ;
sub_unary_expression = SPON alignof_expression ;
unary_operator = '&' ;
unary_operator = '*' ;
unary_operator = '+' ;
unary_operator = '-' ;
unary_operator = '~' ;
unary_operator = '!' ;
unary_operator = '&&' ;
unary_operator = 'NOT' ;
unary_operator = 'not' ;
sizeof_expression = 'sizeof' '(' type_name ')' ;
sizeof_expression = 'sizeof' unary_expression ;
alignof_expression = alignof_specifier '(' expression_or_type_name ')' ;
alignof_specifier = '__alignof__' ;
alignof_specifier = '__alignof' ;
postfix_expression = primary SPOFF postfix_extension* SPON ;
primary = reference_id ;
primary = constant ;
primary = string ;
primary = '(' SPON expression_list ','? ')' ;
primary = '{' SPON expression_list ','? '}' ;
primary = SPON extension_specifier '(' expression_list ')' ;
primary = SPON constructor_expression ;
primary = SPON asm_spec ;
reference_id = id ;
reference_id = foreachid ;
reference_id = whileeachid ;
compound_statement_expression = '(' compound_statement ')' ;
constructor_expression = '(' constructor_type ')' '{' initializer',' ','? '}' ;
constructor_expression = '(' constructor_expression ')' ;
constructor_type = struct_or_union_specifier ;
constructor_type = type_specifiers ptr_operator* array_declarator_extension* ;
postfix_extension = '[' SPON assignment_expression SPOFF ']' ;
postfix_extension = SP '(' SPON argument_expression',' dotdot? SPOFF ')' ;
postfix_extension = '.' id ;
postfix_extension = '->' id macro_call? ;
postfix_extension = '++' ;
postfix_extension = '--' ;
dotdot = SP '..' SP ;
argument_expression = preprocessor* id? assignment_expression id? colon_number? preprocessor* ;
argument_expression = type_name ;
argument_expression = structured_statement ;
argument_expression = equality_operator ;
argument_expression = relational_operator ;
argument_expression = assignment_operator assignment_expression ;
argument_expression = 'do' ;
argument_expression = 'extern' ;
argument_expression = 'continue' ;
argument_expression =  ;
colon_number = ':' number ;
constant = number ;
constant = float ;
constant = hex ;
constant = long ;
constant = SP dotfloat ;
constant = charlit ;
constant = string ;
constant = gnu_long_int ;
constant = gnu_long_int_string ;
constant = hexfloat ;
gnu_long_int = gnu_long_int_string ;
gnu_long_int = gnu_long_int_charlit ;
gnu_long_int_string = 'L' SPOFF string SPON ;
gnu_long_int_charlit = 'L' SPOFF charlit SPON ;
hexfloat = extension_specifier hex ;
string = stringlit string_unit* ;
string = pseudo_string stringlit string_unit* ;
string_unit = stringlit ;
string_unit = pseudo_string ;
string_unit = register_spec ;
string_unit = preprocessor ;
pseudo_string = ps_name ps_arguments? ;
ps_name = id ;
ps_arguments = '(' ps_argument_list ')' ;
ps_argument_list = ps_argument',' ;
ps_argument = constant_expression ;
ps_argument = register_spec ;
register_spec = '%' SPOFF '%'? id SPON ;
register_spec = '%' SPOFF '%'? integernumber id? SPON ;
machinestart_declaration = 'MACHINE_START' '(' expression_list ')' IN initializer',' ','? (EX NL) 'MACHINE_END' ';'? NL ;
device_attr = 'DEVICE_ATTR' ;
device_attr = 'SYSDEV_ATTR' ;
device_attr = 'DEFINE_TIMER' ;
device_attr = 'DECLARE_TASKLET' ;
macro_declaration_or_statement = reference_id_equals? macro_call equals_initializer? ';'? NL ;
macro_declaration_or_statement = upper_macro_name ';'? NL ;
reference_id_equals = reference_id '=' ;
statement_declaration_or_end = declaration_or_statement ;
statement_declaration_or_end = '}' ;
macro_call = macro_name '(' macro_arguments ')' ;
macro_arguments = macro_argument* ;
macro_argument = '(' macro_arguments ')' ;
macro_argument = token ;
macro_argument = key ;
equals_initializer = '=' initializer ;
equals_initializer = initializer ;
macro_name = id ;
upper_macro_name = upperlowerid ;
unknown_declaration_or_statement = unknown_item+ ';' NL ;
unknown_declaration_or_statement = unknown_item+ NL ;
unknown_item = '{' unknown_item* '}' ;
unknown_item = token ;
unknown_item = key ;
