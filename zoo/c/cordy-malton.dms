C_compilation_unit = declaration_or_function_definition* ;
constant = number ;
constant = float ;
constant = hex ;
constant = long ;
constant = SP dotfloat ;
constant = charlit ;
constant = string ;
string = stringlit+ ;
expression = assignment_expression+ ;
constant_expression = conditional_expression ;
assignment_expression = conditional_expression assignment_operation? ;
assignment_operation = assignment_operator assignment_expression ;
assignment_operator = '=' ;
assignment_operator = '*=' ;
assignment_operator = '/=' ;
assignment_operator = '%=' ;
assignment_operator = '+=' ;
assignment_operator = '-=' ;
assignment_operator = '>>=' ;
assignment_operator = '<<=' ;
assignment_operator = '&=' ;
assignment_operator = '^=' ;
assignment_operator = '|=' ;
conditional_expression = binary_expression conditional_operation? ;
conditional_operation = '?' expression ':' conditional_expression ;
binary_expression = unary_expression ;
binary_expression = binary_expression binary_operator unary_expression ;
binary_operator = '+' ;
binary_operator = '-' ;
binary_operator = '*' ;
binary_operator = '/' ;
binary_operator = '%' ;
binary_operator = '==' ;
binary_operator = '!=' ;
binary_operator = '<' ;
binary_operator = '>' ;
binary_operator = '<=' ;
binary_operator = '>=' ;
binary_operator = '||' ;
binary_operator = '&&' ;
binary_operator = '|' ;
binary_operator = '^' ;
binary_operator = '&' ;
binary_operator = '<<' ;
binary_operator = '>>' ;
unary_expression = postfix_expression ;
unary_expression = unary_operator SPOFF unary_expression SPON ;
unary_expression = '(' type_name ')' unary_expression ;
unary_expression = sizeof_expression ;
sizeof_expression = 'sizeof' '(' type_name ')' ;
sizeof_expression = 'sizeof' unary_expression ;
unary_operator = '*' ;
unary_operator = '&' ;
unary_operator = '+' ;
unary_operator = '-' ;
unary_operator = '!' ;
unary_operator = '~' ;
unary_operator = '++' ;
unary_operator = '--' ;
postfix_expression = reference ;
postfix_expression = nonreference ;
reference = reference_id ;
reference = reference_expression ;
reference_id = id ;
reference_expression = unannotated_reference_base postfix_extension* ;
unannotated_reference_base = reference_id ;
unannotated_reference_base = nonreferential_primary ;
nonreference = nonreferential_primary postfix_extension* ;
nonreferential_primary = constant ;
nonreferential_primary = string ;
nonreferential_primary = '(' expression ')' ;
postfix_extension = '[' expression ']' ;
postfix_extension = '(' expression? ')' ;
postfix_extension = '.' id ;
postfix_extension = '->' id ;
postfix_extension = '++' ;
postfix_extension = '--' ;
declaration = declaration_body semi ;
declaration = preprocessor ;
declaration_body = decl_specifiers init_declarator+ ;
declaration_body = enum_specifier ;
declaration_body = struct_or_union_specifier ;
decl_specifiers = decl_qualifier* type_specifier? decl_qualifier* ;
struct_or_union_specifier = struct_or_union tagged_reference_id? '{' (IN NL) member_declaration* EX '}' ;
struct_or_union_specifier = struct_or_union tagged_reference_id ;
tagged_reference_id = reference_id ;
member_declaration = decl_specifiers member_declarator+ semi ;
member_declaration = preprocessor ;
member_declarator = declarator bitfieldsize? ;
member_declarator = bitfieldsize ;
bitfieldsize = ':' constant_expression ;
decl_qualifier = sc_specifier ;
decl_qualifier = cv_qualifier ;
decl_qualifier = type_qualifier ;
sc_specifier = 'auto' ;
sc_specifier = 'register' ;
sc_specifier = 'static' ;
sc_specifier = 'extern' ;
sc_specifier = 'typedef' ;
type_specifier = simple_type_name ;
type_specifier = enum_specifier ;
type_specifier = struct_or_union_specifier ;
type_qualifier = 'long' ;
type_qualifier = 'short' ;
type_qualifier = 'signed' ;
type_qualifier = 'unsigned' ;
simple_type_name = 'char' ;
simple_type_name = 'int' ;
simple_type_name = 'void' ;
simple_type_name = 'float' ;
simple_type_name = 'double' ;
simple_type_name = type_id ;
type_id = reference_id ;
struct_or_union = 'struct' ;
struct_or_union = 'union' ;
enum_specifier = 'enum' tagged_reference_id? '{' enumerator',' '}' ;
enum_specifier = 'enum' tagged_reference_id ;
enumerator = reference_id enumerator_value? ;
enumerator_value = '=' constant_expression ;
init_declarator = declarator initialization? ;
declarator = ptr_operator* base_declarator SPON declarator_extension* ;
base_declarator = reference_id ;
base_declarator = '(' declarator ')' ;
declarator_extension = function_declarator_extension ;
declarator_extension = array_declarator_extension ;
function_declarator_extension = '(' argument_declaration_list ')' cv_qualifier* ;
array_declarator_extension = '[' constant_expression? ']' ;
ptr_operator = '*' cv_qualifier* SPOFF ;
cv_qualifier = 'const' ;
cv_qualifier = 'volatile' ;
type_name = type_specifiers abstract_declarator? ;
type_specifiers = type_qualifier+ type_specifier? type_qualifier* ;
type_specifiers = type_specifier type_qualifier* ;
abstract_declarator = ptr_operator+ declarator_extension* ;
abstract_declarator = '(' abstract_declarator ')' declarator_extension* ;
argument_declaration_list = argument_declaration',' ;
argument_declaration = decl_specifiers argument_declarator? ;
argument_declaration = '...' ;
argument_declarator = declarator ;
argument_declarator = abstract_declarator ;
initialization = '=' initializer ;
initialization = '(' constant_expression ')' ;
initializer = expression ;
initializer = NL '{' IN initializer',' ','? EX '}' ;
statement = label* unlabeled_statement ;
statement = preprocessor ;
label = label_id ':' ;
label = EX SP SP 'case' constant_expression ':' (IN NL) ;
label = EX SP SP 'default' ':' (IN NL) ;
label_id = id ;
unlabeled_statement = expression_statement ;
unlabeled_statement = if_statement ;
unlabeled_statement = for_statement ;
unlabeled_statement = while_statement ;
unlabeled_statement = switch_statement ;
unlabeled_statement = do_statement ;
unlabeled_statement = null_statement ;
unlabeled_statement = jump_statement ;
unlabeled_statement = compound_statement ;
null_statement = semi ;
compound_statement = '{' (IN NL) compound_statement_body '}' ';'? NL ;
compound_statement_body = statement* EX ;
compound_statement_body = declaration compound_statement_body ;
expression_statement = expression semi ;
if_statement = 'if' '(' expression ')' statement else_statement? ;
switch_statement = 'switch' '(' expression ')' statement ;
else_statement = 'else' statement ;
while_statement = 'while' '(' expression ')' statement ;
do_statement = 'do' statement 'while' '(' expression ')' semi ;
for_statement = 'for' '(' expression? ';' expression? ';' expression? ')' statement ;
jump_statement = 'goto' label_id semi ;
jump_statement = 'continue' semi ;
jump_statement = 'break' semi ;
jump_statement = 'return' expression? semi ;
declaration_or_function_definition = declaration ;
declaration_or_function_definition = function_definition ;
function_definition = NL decl_specifiers declarator KR_parameter_decls? compound_statement NL ;
KR_parameter_decls = (NL IN) declaration+ EX ;
semi = ';' NL ;
program = C_compilation_unit ;
preprocessor = '#define' id '(' id+ ')' expression NL ;
preprocessor = '#define' id expression NL ;
preprocessor = EX '#else' (IN NL) ;
preprocessor = EX '#endif' (NL NL) ;
preprocessor = NL '#if' expression (IN NL) ;
preprocessor = NL '#ifdef' id (IN NL) ;
preprocessor = NL '#ifndef' id (IN NL) ;
preprocessor = '#ident' stringlit NL ;
preprocessor = '#include' stringlit NL ;
preprocessor = '#include' '<' SPOFF filepath '>' SPON NL ;
preprocessor = '#line' integernumber stringlit? NL ;
preprocessor = '#undef' id NL ;
preprocessor = '#LINK' stringlit NL ;
filepath = file_id slash_fileid* ;
file_id = id ;
file_id = key ;
slash_fileid = slash file_id ;
slash = '/' ;
slash = '\' ;
slash = '.' ;
slash = ':' ;
