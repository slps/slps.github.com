StructDeclarator:
        Declarator
StructDeclarator:
        Declarator? ":" Expression
PrototypeParameter:
        Specifier* AbstractDeclarator
TypeSpecifier:
        StructDecl("struct" Identifier "{" StructDeclaration* "}")
TypeSpecifier:
        Union("union" Identifier)
TypeSpecifier:
        Int"int"
TypeSpecifier:
        Void"void"
TypeSpecifier:
        StructAnonDecl("struct" "{" StructDeclaration* "}")
TypeSpecifier:
        Short"short"
TypeSpecifier:
        IdentifierIdentifier
TypeSpecifier:
        EnumDecl("enum" Identifier "{" {Enumerator ","}+ "}")
TypeSpecifier:
        "signed"
TypeSpecifier:
        UnionDecl("union" Identifier "{" StructDeclaration* "}")
TypeSpecifier:
        UnionAnonDecl("union" "{" StructDeclaration* "}")
TypeSpecifier:
        Enum("enum" Identifier)
TypeSpecifier:
        Struct("struct" Identifier)
TypeSpecifier:
        "unsigned"
TypeSpecifier:
        Long"long"
TypeSpecifier:
        Double"double"
TypeSpecifier:
        Float"float"
TypeSpecifier:
        EnumAnonDecl("enum" "{" {Enumerator ","}+ "}")
TypeSpecifier:
        Char"char"
StructDeclaration:
        StructDeclWithoutDecl(specs::(Specifier+) ";")
StructDeclaration:
        StructDeclWithDecl(specs::(Specifier+) {StructDeclarator ","}+ ";")
TypeName:
        Specifier+ AbstractDeclarator
Initializer:
        "{" {Initializer ","}+ ","? "}"
Initializer:
        NonCommaExpression
InitDeclarator:
        decl::Declarator "=" Initializer
InitDeclarator:
        declDeclarator
Statement:
        "default" ":" Statement
Statement:
        "switch" "(" Expression ")" Statement
Statement:
        "return" ";"
Statement:
        "for" "(" Expression? ";" Expression? ";" Expression? ")" Statement
Statement:
        "case" Expression ":" Statement
Statement:
        "continue" ";"
Statement:
        ";"
Statement:
        "goto" Identifier ";"
Statement:
        "do" Statement "while" "(" Expression ")" ";"
Statement:
        "{" Declaration* Statement* "}"
Statement:
        "while" "(" Expression ")" Statement
Statement:
        "break" ";"
Statement:
        "if" "(" Expression ")" Statement
Statement:
        Identifier ":" Statement
Statement:
        Expression ";"
Statement:
        "if" "(" Expression ")" Statement "else" Statement
Statement:
        "return" Expression ";"
ExternalDeclaration:
        FunctionPrototype
ExternalDeclaration:
        FunctionDefinition
ExternalDeclaration:
        GlobalDeclaration
PrototypeParameters:
        "void"
PrototypeParameters:
        {PrototypeParameter ","}+ MoreParameters?
Parameters:
        {Parameter ","}+ MoreParameters?
Parameters:
        "void"
FunctionPrototype:
        DefaultFunctionPrototype(specs::(Specifier*) decl::PrototypeDeclarator ";")
Parameter:
        Specifier* Declarator
AnonymousIdentifier:
        EPSILON
PrototypeDeclarator:
        FunctionDeclarator(decl::PrototypeDeclarator "(" params::(PrototypeParameters?) ")")
PrototypeDeclarator:
        IdentifierIdentifier
PrototypeDeclarator:
        Bracket("(" decl::AbstractDeclarator ")")
PrototypeDeclarator:
        ArrayDeclarator(decl::PrototypeDeclarator "[" exp::(Expression?) "]")
PrototypeDeclarator:
        PointerDeclarator("*" qualifiers::(TypeQualifier*) decl::PrototypeDeclarator)
AbstractDeclarator:
        IdentifierAnonymousIdentifier
AbstractDeclarator:
        ArrayDeclarator(decl::AbstractDeclarator "[" exp::(Expression?) "]")
AbstractDeclarator:
        Bracket("(" decl::AbstractDeclarator ")")
AbstractDeclarator:
        FunctionDeclarator(decl::AbstractDeclarator "(" params::(Parameters?) ")")
AbstractDeclarator:
        PointerDeclarator("*" qualifiers::(TypeQualifier*) decl::AbstractDeclarator)
Declarator:
        ArrayDeclarator(decl::Declarator "[" exp::(Expression?) "]")
Declarator:
        IdentifierIdentifier
Declarator:
        FunctionDeclarator(decl::Declarator "(" params::(Parameters?) ")")
Declarator:
        Bracket("(" decl::Declarator ")")
Declarator:
        PointerDeclarator("*" qualifiers::(TypeQualifier*) decl::Declarator)
Specifier:
        StorageClassStorageClass
Specifier:
        TypeQualifierTypeQualifier
Specifier:
        TypeSpecifierTypeSpecifier
StorageClass:
        "register"
StorageClass:
        "static"
StorageClass:
        "extern"
StorageClass:
        "auto"
StorageClass:
        TypeDef"typedef"
Declaration:
        DeclarationWithoutInitDecls(specs::(Specifier+) ";")
Declaration:
        DeclarationWithInitDecls(specs::(Specifier+) initDeclarators::{InitDeclarator ","}+ ";")
Enumerator:
        Identifier
Enumerator:
        Identifier "=" NonCommaExpression
NonCommaExpression:
        NonCommaExpressionexpr::Expression
FunctionDefinition:
        DefaultFunctionDefinition(specs::(Specifier*) Declarator Declaration* "{" Declaration* Statement* "}")
GlobalDeclaration:
        GlobalDeclarationWithoutInitDecls(specs::(Specifier+) ";")
GlobalDeclaration:
        GlobalDeclarationWithInitDecls(specs::(Specifier*) initDeclarators::{InitDeclarator ","}+ ";")
TranslationUnit:
        ExternalDeclaration+
TypeQualifier:
        "const"
TypeQualifier:
        "volatile"
MoreParameters:
        "," "..."
Expression:
        CharacterConstant
Expression:
        Expression "--"
Expression:
        VariableIdentifier
Expression:
        Expression "[" Expression "]"
Expression:
        Bracket("(" Expression ")")
Expression:
        "sizeof" "(" TypeName ")"
Expression:
        Expression "++"
Expression:
        FloatingPointConstant
Expression:
        Expression "." Identifier
Expression:
        StringConstant
Expression:
        IntegerConstant
Expression:
        HexadecimalConstant
Expression:
        Expression "->" Identifier
Expression:
        Expression "(" {NonCommaExpression ","}* ")"
Expression:
        Expression
Expression:
        SizeOfExpression("sizeof" exp::Expression)
Expression:
        "&" Expression
Expression:
        "!" Expression
Expression:
        "(" TypeName ")" Expression
Expression:
        "*" Expression
Expression:
        "+" Expression
Expression:
        "-" Expression
Expression:
        "~" Expression
Expression:
        MultiplicationExpression(lexp::Expression "*" rexp::Expression)
Expression:
        Expression "/" Expression
Expression:
        Expression "%" Expression
Expression:
        Expression "+" Expression
Expression:
        Expression "-" Expression
Expression:
        Expression ">>" Expression
Expression:
        Expression "<<" Expression
Expression:
        Expression "<=" Expression
Expression:
        Expression ">=" Expression
Expression:
        Expression ">" Expression
Expression:
        Expression "<" Expression
Expression:
        Expression "==" Expression
Expression:
        Expression "!=" Expression
Expression:
        Expression "&" Expression
Expression:
        Expression "^" Expression
Expression:
        Expression "|" Expression
Expression:
        Expression "&&" Expression
Expression:
        Expression "||" Expression
Expression:
        Expression "?" Expression ":" Expression
Expression:
        Expression "|=" Expression
Expression:
        Expression "&=" Expression
Expression:
        Expression "*=" Expression
Expression:
        Expression "/=" Expression
Expression:
        Expression "+=" Expression
Expression:
        Expression ">>=" Expression
Expression:
        Expression "^=" Expression
Expression:
        Expression "-=" Expression
Expression:
        Expression "<<=" Expression
Expression:
        Expression "%=" Expression
Expression:
        Expression "=" Expression
Expression:
        CommaExpression(Expression "," Expression)
