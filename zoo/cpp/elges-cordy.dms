program = declaration_list ;
declaration_list = declaration* ;
declaration = asm_declaration ;
declaration = class_definition ;
declaration = function_definition ;
declaration = namespace_definition ;
declaration = template_declaration ;
declaration = linkage_specification ;
declaration = exception_specification ;
declaration = using_declaration ;
declaration = decl_specifiers? declarator_list ';' NL ;
declaration = decl_specifiers ';' NL ;
declaration = ';' NL ;
declaration = preprocessor NL ;
asm_declaration = 'asm' '(' string_constant ')' ';' NL ;
class_definition = NL storage_class_specifier* class_specifier declarator_list? ';' (NL NL) ;
storage_class_specifier = 'auto' ;
storage_class_specifier = 'register' ;
storage_class_specifier = 'static' ;
storage_class_specifier = 'extern' ;
class_specifier = class_head '{' (NL IN) member* EX '}' ;
class_head = class_key id? base_spec? ;
class_head = class_key nested_name_spec id base_spec? ;
class_head = class_key class_name base_spec? ;
class_key = 'class' ;
class_key = 'struct' ;
class_key = 'union' ;
base_spec = ':' base_list ;
base_list = base_specifier ','? base_specifier',' ;
base_specifier = '::'? nested_name_spec? class_name ;
base_specifier = 'virtual' access_specifier? '::'? nested_name_spec? class_name ;
base_specifier = access_specifier 'virtual'? '::'? nested_name_spec? class_name ;
access_specifier = 'private' ;
access_specifier = 'protected' ;
access_specifier = 'public' ;
member = access_specifier_colon? member_declaration ;
access_specifier_colon = EX_2 NL access_specifier SPOFF ':' SPON IN_2 NL ;
member_declaration = function_definition ';'? ;
member_declaration = qualified_name ';' NL ;
member_declaration = using_declaration ;
member_declaration = decl_specifiers? member_declarator_list ';' NL ;
member_declaration = decl_specifiers ';' NL ;
member_declaration = ';' NL ;
member_declaration = preprocessor NL ;
member_declarator_list = member_declarator+ ;
member_declarator = declarator initializer? ;
member_declarator = id? SPOFF ':' SPON constant_expression ;
function_definition = NL decl_specifiers? function_declarator ctor_initializer? exception_specification? function_body ;
function_declarator = pointer_operator* declared_item declarator_extension+ ;
function_body = NL compound_statement ';'? NL ;
function_body = 'try' ctor_initializer? NL compound_statement ';'? NL handler_list ;
ctor_initializer = SPOFF ':' SPON mem_initializer_list ;
mem_initializer_list = mem_initializer+ ;
mem_initializer = '::'? nested_name_spec? class_name '(' expression_list? ')' ;
namespace_definition = 'namespace' id? '{' (NL IN) declaration_list? EX '}' (NL NL) ;
namespace_definition = 'namespace' id '=' qualified_namespace_spec ;
qualified_namespace_spec = '::'? nested_name_spec? class_or_namespace_name ;
nested_name_spec = class_or_namespace_name '::' nested_name_spec? ;
class_or_namespace_name = class_name ;
class_or_namespace_name = namespace_name ;
namespace_name = id ;
template_declaration = 'template' '<' template_parameter_list '>' declaration ;
template_parameter_list = template_parameter ;
template_parameter_list = template_parameter_list ',' template_parameter ;
template_parameter = type_parameter ;
template_parameter = parameter_declaration ;
type_parameter = 'class' id ;
linkage_specification = NL 'extern' stringlit '{' (NL IN) declaration_list EX '}' ';'? (NL NL) ;
linkage_specification = 'extern' stringlit declaration ;
exception_specification = 'throw' '(' type_list? ')' ;
type_list = type_name ;
type_list = type_list ',' type_name ;
using_declaration = 'using' '::'? nested_name_spec? name ';' ;
using_declaration = 'using' 'namespace' '::'? nested_name_spec? id ';' ;
declarator_list = init_declarator+ ;
init_declarator = declarator initializer? ;
declarator = pointer_operator* declared_item declarator_extension* ;
declared_item = declared_name ;
declared_item = '(' declarator ')' ;
declarator_extension = parenthesized_parameter_declaration_list const_volatile_qualifier_list? ;
declarator_extension = '[' constant_expression? ']' ;
parenthesized_parameter_declaration_list = '(' parameter_declaration_list ')' ;
parenthesized_parameter_declaration_list = '(' parenthesized_parameter_declaration_list ')' ;
pointer_operator = stars const_volatile_qualifier_list? ;
pointer_operator = '&' const_volatile_qualifier_list? ;
pointer_operator = id '::' stars const_volatile_qualifier_list? ;
pointer_operator = '::'? nested_name_spec '*' const_volatile_qualifier_list ;
stars = '*' ;
stars = '**' ;
const_volatile_qualifier_list = const_volatile_qualifier+ ;
const_volatile_qualifier = 'const' ;
const_volatile_qualifier = 'volatile' ;
declared_name = nested_name_spec? name ;
declared_name = '~' SPOFF id SPON ;
type_name = type_specifiers abstract_declarator? ;
abstract_declarator = abstract_extension+ ;
abstract_declarator = '(' abstract_declarator ')' abstract_extension* ;
abstract_extension = '(' parameter_declaration_list ')' const_volatile_qualifier_list? ;
abstract_extension = '[' constant_expression? ']' ;
abstract_extension = pointer_operator ;
abstract_extension = '(' abstract_declarator ')' ;
parameter_declaration_list = parameter_declaration',' comma_dotdotdot? ;
comma_dotdotdot = ','? '...' ;
parameter_declaration = decl_specifiers parameter_declarator equal_expression? ;
parameter_declarator = declarator ;
parameter_declarator = abstract_declarator? ;
equal_expression = '=' expression ;
initializer = '=' initial_value ;
initializer = '(' expression_list? ')' ;
initial_value = assignment_expression ;
initial_value = '{' IN initializer_list ','? EX '}' ;
initializer_list = initializer_element+ ;
initializer_element = assignment_expression ;
initializer_element = NL '{' IN initializer_list ','? EX '}' ;
decl_specifier = storage_class_specifier ;
decl_specifier = type_specifier ;
decl_specifier = function_specifier ;
decl_specifier = 'friend' ;
decl_specifier = 'typedef' ;
decl_specifiers = decl_specifier+ ;
function_specifier = 'inline' ;
function_specifier = 'virtual' ;
type_specifier = simple_type_name ;
type_specifier = class_specifier ;
type_specifier = enum_specifier ;
type_specifier = elaborated_type_specifier ;
type_specifier = const_volatile_qualifier ;
type_specifiers = type_specifier+ ;
simple_type_name = 'char' ;
simple_type_name = 'bool' ;
simple_type_name = 'short' ;
simple_type_name = 'int' ;
simple_type_name = 'long' ;
simple_type_name = 'signed' ;
simple_type_name = 'unsigned' ;
simple_type_name = 'float' ;
simple_type_name = 'double' ;
simple_type_name = 'void' ;
simple_type_name = '::'? nested_name_spec? id ;
simple_type_name = '::'? nested_name_spec? template_class_name ;
template_class_name = id template_arguments ;
template_arguments = '<' template_argument_list '>' ;
template_argument_list = template_argument ;
template_argument_list = template_argument_list ',' template_argument ;
template_argument = type_name ;
template_argument = non_gt_binary_expression ;
non_gt_binary_expression = cast_expression non_gt_binary_operation* ;
non_gt_binary_operation = non_gt_binary_operator cast_expression ;
non_gt_binary_operator = '||' ;
non_gt_binary_operator = '&&' ;
non_gt_binary_operator = '|' ;
non_gt_binary_operator = '^' ;
non_gt_binary_operator = '&' ;
non_gt_binary_operator = '==' ;
non_gt_binary_operator = '!=' ;
non_gt_binary_operator = '<' ;
non_gt_binary_operator = '<=' ;
non_gt_binary_operator = '>=' ;
non_gt_binary_operator = '<<' ;
non_gt_binary_operator = '>>' ;
non_gt_binary_operator = '+' ;
non_gt_binary_operator = '-' ;
non_gt_binary_operator = '*' ;
non_gt_binary_operator = '/' ;
non_gt_binary_operator = '%' ;
non_gt_binary_operator = '.*' ;
non_gt_binary_operator = '->*' ;
elaborated_type_specifier = class_key '::'? nested_name_spec? class_name ;
elaborated_type_specifier = 'enum' '::'? nested_name_spec? id ;
enum_specifier = 'enum' id? '{' enum_list? '}' ;
enum_list = enumerator+ ','? ;
enumerator = id equal_constant_expression? ;
equal_constant_expression = '=' constant_expression ;
constant_expression = conditional_expression ;
conversion_function_name = 'operator' conversion_type_name ;
conversion_type_name = type_specifiers pointer_operator? ;
operator_function_name = 'operator' operator ;
operator = 'new' ;
operator = 'delete' ;
operator = '+' ;
operator = '-' ;
operator = '*' ;
operator = '/' ;
operator = '%' ;
operator = '^' ;
operator = '&' ;
operator = '|' ;
operator = '~' ;
operator = '!' ;
operator = '=' ;
operator = '<' ;
operator = '>' ;
operator = '+=' ;
operator = '-=' ;
operator = '-+' ;
operator = '*=' ;
operator = '/=' ;
operator = '%=' ;
operator = '^=' ;
operator = '&=' ;
operator = '|=' ;
operator = '<<' ;
operator = '>>' ;
operator = '>>=' ;
operator = '<<=' ;
operator = '==' ;
operator = '!=' ;
operator = '<=' ;
operator = '>=' ;
operator = '&&' ;
operator = '||' ;
operator = '++' ;
operator = '--' ;
operator = ',' ;
operator = '->*' ;
operator = '->' ;
operator = '(' type_specifier? ')' ;
operator = '[' ']' ;
statement = label* unlabeled_statement ;
unlabeled_statement = null_statement ;
unlabeled_statement = expression_statement ;
unlabeled_statement = compound_statement ;
unlabeled_statement = selection_statement ;
unlabeled_statement = iteration_statement ;
unlabeled_statement = jump_statement ;
unlabeled_statement = declaration_statement ;
unlabeled_statement = try_block ;
try_block = 'try' compound_statement handler_list ;
handler_list = handler handler_list? ;
handler = 'catch' '(' exception_declaration ')' compound_statement ;
exception_declaration = type_specifiers exception_declarator? ;
exception_declaration = '...' ;
exception_declarator = declarator ;
exception_declarator = abstract_declarator ;
label = id SPOFF ':' SPON ;
label = EX 'case' constant_expression SPOFF ':' SPON (NL IN) ;
label = EX 'default' SPOFF ':' SPON (NL IN) ;
expression_statement = expression ';' NL ;
null_statement = ';' NL ;
compound_statement = '{' (NL IN) statement_list? EX '}' NL ;
statement_list = statement+ ;
selection_statement = 'if' '(' expression ')' statement else_statement? ;
selection_statement = 'switch' '(' expression ')' statement ;
else_statement = 'else' statement ;
iteration_statement = 'while' '(' expression ')' statement ;
iteration_statement = 'do' statement 'while' '(' expression ')' ';' NL ;
iteration_statement = 'for' '(' for_init_statement expression? ';' expression? ')' for_body ;
for_init_statement = expression ';' ;
for_init_statement = decl_specifiers? declarator_list ';' ;
for_init_statement = decl_specifiers ';' ;
for_init_statement = ';' ;
for_body = compound_statement ;
for_body = (IN NL) statement EX ;
jump_statement = 'break' ';' NL ;
jump_statement = 'continue' ';' NL ;
jump_statement = 'return' expression? ';' NL ;
jump_statement = 'goto' id ';' NL ;
declaration_statement = declaration ;
preprocessor = '#define' id '(' id+ ')' expression ;
preprocessor = '#define' id expression ;
preprocessor = EX '#else' IN ;
preprocessor = EX '#endif' NL ;
preprocessor = NL '#if' expression IN ;
preprocessor = NL '#ifdef' id IN ;
preprocessor = NL '#ifndef' id IN ;
preprocessor = '#ident' stringlit ;
preprocessor = '#include' stringlit ;
preprocessor = '#include' '<' SPOFF filename '>' SPON ;
preprocessor = '#line' integernumber stringlit? ;
preprocessor = '#undef' id ;
preprocessor = '#LINK' stringlit ;
file_identifier = id ;
file_identifier = key ;
filename = file_identifier dot_slash_identifier* ;
dot_slash_identifier = '.'? '/'? file_identifier ;
expression = assignment_expression ;
expression = expression ',' assignment_expression ;
assignment_expression = conditional_expression ;
assignment_expression = unary_expression assignment_operator assignment_expression ;
assignment_operator = '=' ;
assignment_operator = '*=' ;
assignment_operator = '/=' ;
assignment_operator = '%=' ;
assignment_operator = '+=' ;
assignment_operator = '-=' ;
assignment_operator = '>>=' ;
assignment_operator = '<<=' ;
assignment_operator = '&=' ;
assignment_operator = '^=' ;
assignment_operator = '|=' ;
conditional_expression = binary_expression conditional_operation? ;
conditional_operation = '?' expression ':' conditional_expression ;
binary_expression = cast_expression binary_operation* ;
binary_operation = binary_operator cast_expression ;
binary_operator = '||' ;
binary_operator = '&&' ;
binary_operator = '|' ;
binary_operator = '^' ;
binary_operator = '&' ;
binary_operator = '==' ;
binary_operator = '!=' ;
binary_operator = '<' ;
binary_operator = '>' ;
binary_operator = '<=' ;
binary_operator = '>=' ;
binary_operator = '<<' ;
binary_operator = '>>' ;
binary_operator = '+' ;
binary_operator = '-' ;
binary_operator = '*' ;
binary_operator = '/' ;
binary_operator = '%' ;
binary_operator = '.*' ;
binary_operator = '->*' ;
cast_expression = unary_expression ;
cast_expression = '(' type_name ')' cast_expression ;
unary_expression = postfix_expression ;
unary_expression = '++' unary_expression ;
unary_expression = '--' unary_expression ;
unary_expression = unary_operator cast_expression ;
unary_expression = 'sizeof' unary_expression ;
unary_expression = 'sizeof' '(' type_name ')' ;
unary_expression = allocation_expression ;
unary_expression = deallocation_expression ;
unary_expression = throw_expression ;
throw_expression = 'throw' assignment_expression? ;
unary_operator = '**' ;
unary_operator = '*' ;
unary_operator = '&' ;
unary_operator = '+' ;
unary_operator = '-' ;
unary_operator = '!' ;
unary_operator = '~' ;
allocation_expression = '::'? 'new' placement? allocation_type_name initializer? ;
placement = '(' expression_list ')' ;
allocation_type_name = type_specifiers allocation_declarator? ;
allocation_type_name = '(' type_name ')' allocation_declarator? ;
allocation_declarator = allocation_array_declarator ;
allocation_declarator = '*' const_volatile_qualifier_list? allocation_declarator? ;
allocation_declarator = '::'? nested_name_spec '*' const_volatile_qualifier_list? allocation_declarator? ;
allocation_declarator = qualified_name '::' '*' const_volatile_qualifier_list? allocation_declarator? ;
allocation_array_declarator = '[' expression? ']' ;
allocation_array_declarator = allocation_array_declarator '[' expression? ']' ;
deallocation_expression = '::'? 'delete' cast_expression ;
deallocation_expression = '::'? 'delete' '[' expression? ']' cast_expression ;
postfix_expression = primary_expression postfix_extension* ;
postfix_expression = simple_type_name '(' expression_list? ')' postfix_extension* ;
postfix_extension = '[' expression? ']' ;
postfix_extension = '(' expression_list? ')' ;
postfix_extension = '.' name ;
postfix_extension = '->' name ;
postfix_extension = '++' ;
postfix_extension = '--' ;
expression_list = assignment_expression+ ;
primary_expression = literal ;
primary_expression = 'this' ;
primary_expression = '::' id ;
primary_expression = '::' operator_function_name ;
primary_expression = '(' expression ')' ;
primary_expression = name ;
name = id ;
name = template_class_name ;
name = qualified_name ;
name = operator_function_name ;
name = conversion_function_name ;
class_name = id template_arguments? ;
qualified_name = class_name '::' class_component ;
class_component = class_name ;
class_component = '~' SPOFF class_name SPON ;
class_component = operator_function_name ;
class_component = conversion_function_name ;
class_component = qualified_name ;
literal = number_constant ;
literal = character_constant ;
literal = string_constant ;
string_constant = stringlit IN NL_stringlit* EX ;
NL_stringlit = NL stringlit ;
character_constant = charlit ;
number_constant = '-'? number ;
number_constant = hexnumber ;
