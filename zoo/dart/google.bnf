compilationUnit:
        HASHBANG? directive* topLevelDefinition* EOF
HASHBANG:
        "#!" ANY* NEWLINE?
NEWLINE:
        "\n"
        "\r"
directive:
        "#" identifier arguments ";"
identifier:
        IDENTIFIER_NO_DOLLAR
        IDENTIFIER
        ABSTRACT
        ASSERT
        CLASS
        EXTENDS
        FACTORY
        GET
        IMPLEMENTS
        IMPORT
        INTERFACE
        IS
        LIBRARY
        NATIVE
        NEGATE
        OPERATOR
        SET
        SOURCE
        STATIC
        TYPEDEF
IDENTIFIER_NO_DOLLAR:
        IDENTIFIER_START_NO_DOLLAR IDENTIFIER_PART_NO_DOLLAR*
IDENTIFIER_START_NO_DOLLAR:
        LETTER
        "_"
LETTER:
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "g"
        "h"
        "i"
        "j"
        "k"
        "l"
        "m"
        "n"
        "o"
        "p"
        "q"
        "r"
        "s"
        "t"
        "u"
        "v"
        "w"
        "x"
        "y"
        "z"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
        "G"
        "H"
        "I"
        "J"
        "K"
        "L"
        "M"
        "N"
        "O"
        "P"
        "Q"
        "R"
        "S"
        "T"
        "U"
        "V"
        "W"
        "X"
        "Y"
        "Z"
IDENTIFIER_PART_NO_DOLLAR:
        IDENTIFIER_START_NO_DOLLAR
        DIGIT
DIGIT:
        "0"
        "1"
        "2"
        "3"
        "4"
        "5"
        "6"
        "7"
        "8"
        "9"
IDENTIFIER:
        IDENTIFIER_START IDENTIFIER_PART*
IDENTIFIER_START:
        IDENTIFIER_START_NO_DOLLAR
        "$"
IDENTIFIER_PART:
        IDENTIFIER_START
        DIGIT
ABSTRACT:
        "abstract"
ASSERT:
        "assert"
CLASS:
        "class"
EXTENDS:
        "extends"
FACTORY:
        "factory"
GET:
        "get"
IMPLEMENTS:
        "implements"
IMPORT:
        "import"
INTERFACE:
        "interface"
IS:
        "is"
LIBRARY:
        "library"
NATIVE:
        "native"
NEGATE:
        "negate"
OPERATOR:
        "operator"
SET:
        "set"
SOURCE:
        "source"
STATIC:
        "static"
TYPEDEF:
        "typedef"
arguments:
        "(" argumentList? ")"
argumentList:
        namedArgument ("," namedArgument)*
        expressionList ("," namedArgument)*
namedArgument:
        label expression
label:
        identifier ":"
expression:
        assignableExpression assignmentOperator expression
        conditionalExpression
assignableExpression:
        primary (arguments* assignableSelector)+
        SUPER assignableSelector
        identifier
primary:
        primaryNoFE
        primaryFE
primaryNoFE:
        THIS
        SUPER assignableSelector
        literal
        identifier
        CONST? typeArguments? compoundLiteral
        (NEW | CONST) type ("." identifier)? arguments
        expressionInParentheses
THIS:
        "this"
SUPER:
        "super"
assignableSelector:
        "[" expression "]"
        "." identifier
literal:
        NULL
        TRUE
        FALSE
        HEX_NUMBER
        NUMBER
        STRING
NULL:
        "null"
TRUE:
        "true"
FALSE:
        "false"
HEX_NUMBER:
        "0x" HEX_DIGIT+
        "0X" HEX_DIGIT+
HEX_DIGIT:
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
        DIGIT
NUMBER:
        DIGIT+ NUMBER_OPT_FRACTIONAL_PART EXPONENT? NUMBER_OPT_ILLEGAL_END
        "." DIGIT+ EXPONENT? NUMBER_OPT_ILLEGAL_END
NUMBER_OPT_FRACTIONAL_PART:
        "." DIGIT+
        EPSILON
EXPONENT:
        ("e" | "E") ("+" | "-")? DIGIT+
NUMBER_OPT_ILLEGAL_END:
        EPSILON
STRING:
        "@"? MULTI_LINE_STRING
        SINGLE_LINE_STRING
MULTI_LINE_STRING:
        """"" ANY* """""
        "\'\'\'" ANY* "\'\'\'"
SINGLE_LINE_STRING:
        """ STRING_CONTENT_DQ* """
        "\'" STRING_CONTENT_SQ* "\'"
        "@" "\'" ANY* "\'"
        "@" """ ANY* """
STRING_CONTENT_DQ:
        ANY
        "\\" ANY
STRING_CONTENT_SQ:
        ANY
        "\\" ANY
CONST:
        "const"
typeArguments:
        "<" typeList ">"
typeList:
        type ("," type)*
type:
        qualified typeArguments?
qualified:
        identifier ("." identifier)?
compoundLiteral:
        listLiteral
        mapLiteral
listLiteral:
        "[" (expressionList ","?)? "]"
expressionList:
        expression ("," expression)*
mapLiteral:
        "{" (mapLiteralEntry ("," mapLiteralEntry)* ","?)? "}"
mapLiteralEntry:
        STRING ":" expression
NEW:
        "new"
expressionInParentheses:
        "(" expression ")"
primaryFE:
        functionExpression
        primaryNoFE
functionExpression:
        (returnType? identifier)? formalParameterList functionExpressionBody
returnType:
        VOID
        type
VOID:
        "void"
formalParameterList:
        "(" namedFormalParameters? ")"
        "(" normalFormalParameter normalFormalParameterTail? ")"
namedFormalParameters:
        "[" defaultFormalParameter ("," defaultFormalParameter)* "]"
defaultFormalParameter:
        normalFormalParameter ("=" constantExpression)?
normalFormalParameter:
        functionDeclaration
        fieldFormalParameter
        simpleFormalParameter
functionDeclaration:
        returnType? identifier formalParameterList
fieldFormalParameter:
        finalVarOrType? THIS "." identifier
finalVarOrType:
        FINAL type?
        VAR
        type
FINAL:
        "final"
VAR:
        "var"
simpleFormalParameter:
        declaredIdentifier
        identifier
declaredIdentifier:
        FINAL type? identifier
        VAR identifier
        type identifier
constantExpression:
        expression
normalFormalParameterTail:
        "," namedFormalParameters
        "," normalFormalParameter normalFormalParameterTail?
functionExpressionBody:
        "=>" expression
        block
block:
        "{" statements "}"
statements:
        statement*
statement:
        label* nonLabelledStatement
nonLabelledStatement:
        block
        initializedVariableDeclaration ";"
        iterationStatement
        selectionStatement
        tryStatement
        BREAK identifier? ";"
        CONTINUE identifier? ";"
        RETURN expression? ";"
        THROW expression? ";"
        expression? ";"
        ASSERT "(" conditionalExpression ")" ";"
        functionDeclaration functionBody
initializedVariableDeclaration:
        declaredIdentifier ("=" expression)? ("," initializedIdentifier)*
initializedIdentifier:
        identifier ("=" expression)?
iterationStatement:
        WHILE "(" expression ")" statement
        DO statement WHILE "(" expression ")" ";"
        FOR "(" forLoopParts ")" statement
WHILE:
        "while"
DO:
        "do"
FOR:
        "for"
forLoopParts:
        forInitializerStatement expression? ";" expressionList?
        declaredIdentifier IN expression
        identifier IN expression
forInitializerStatement:
        initializedVariableDeclaration ";"
        expression? ";"
IN:
        "in"
selectionStatement:
        IF "(" expression ")" statement (ELSE statement)?
        SWITCH "(" expression ")" "{" switchCase* defaultCase? "}"
IF:
        "if"
ELSE:
        "else"
SWITCH:
        "switch"
switchCase:
        label? (CASE expression ":")+ statements
CASE:
        "case"
defaultCase:
        label? (CASE expression ":")* DEFAULT ":" statements
DEFAULT:
        "default"
tryStatement:
        TRY block ((catchPart+ finallyPart?) | finallyPart)
TRY:
        "try"
catchPart:
        CATCH "(" declaredIdentifier ("," declaredIdentifier)? ")" block
CATCH:
        "catch"
finallyPart:
        FINALLY block
FINALLY:
        "finally"
BREAK:
        "break"
CONTINUE:
        "continue"
RETURN:
        "return"
THROW:
        "throw"
conditionalExpression:
        logicalOrExpression ("?" expression ":" expression)?
logicalOrExpression:
        logicalAndExpression ("||" logicalAndExpression)*
logicalAndExpression:
        bitwiseOrExpression ("&&" bitwiseOrExpression)*
bitwiseOrExpression:
        bitwiseXorExpression ("|" bitwiseXorExpression)*
        SUPER ("|" bitwiseXorExpression)+
bitwiseXorExpression:
        bitwiseAndExpression ("^" bitwiseAndExpression)*
        SUPER ("^" bitwiseAndExpression)+
bitwiseAndExpression:
        equalityExpression ("&" equalityExpression)*
        SUPER ("&" equalityExpression)+
equalityExpression:
        relationalExpression (equalityOperator relationalExpression)?
        SUPER equalityOperator relationalExpression
relationalExpression:
        shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?
        SUPER relationalOperator shiftExpression
shiftExpression:
        additiveExpression (shiftOperator additiveExpression)*
        SUPER (shiftOperator additiveExpression)+
additiveExpression:
        multiplicativeExpression (additiveOperator multiplicativeExpression)*
        SUPER (additiveOperator multiplicativeExpression)+
multiplicativeExpression:
        unaryExpression (multiplicativeOperator unaryExpression)*
        SUPER (multiplicativeOperator unaryExpression)+
unaryExpression:
        postfixExpression
        prefixOperator unaryExpression
        negateOperator SUPER
        "-" SUPER
        incrementOperator assignableExpression
postfixExpression:
        assignableExpression postfixOperator
        primary selector*
postfixOperator:
        incrementOperator
incrementOperator:
        "++"
        "--"
selector:
        assignableSelector
        arguments
prefixOperator:
        additiveOperator
        negateOperator
additiveOperator:
        "+"
        "-"
negateOperator:
        "!"
        "~"
multiplicativeOperator:
        "*"
        "/"
        "%"
        "~/"
shiftOperator:
        "<<"
        ">>>"
        ">>"
isOperator:
        IS "!"?
relationalOperator:
        ">="
        ">"
        "<="
        "<"
equalityOperator:
        "=="
        "!="
        "==="
        "!=="
functionBody:
        "=>" expression ";"
        block
assignmentOperator:
        "="
        "*="
        "/="
        "~/="
        "%="
        "+="
        "-="
        "<<="
        ">>>="
        ">>="
        "&="
        "^="
        "|="
topLevelDefinition:
        classDefinition
        interfaceDefinition
        functionTypeAlias
        functionDeclaration functionBodyOrNative
        returnType? getOrSet identifier formalParameterList functionBodyOrNative
        FINAL type? staticFinalDeclarationList ";"
        constInitializedVariableDeclaration ";"
classDefinition:
        CLASS identifier typeParameters? superclass? interfaces? "{" classMemberDefinition* "}"
        CLASS identifier typeParameters? interfaces? NATIVE STRING "{" classMemberDefinition* "}"
typeParameters:
        "<" typeParameter ("," typeParameter)* ">"
typeParameter:
        identifier (EXTENDS type)?
superclass:
        EXTENDS type
interfaces:
        IMPLEMENTS typeList
classMemberDefinition:
        declaration ";"
        constructorDeclaration ";"
        methodDeclaration functionBodyOrNative
        CONST factoryConstructorDeclaration functionNative
declaration:
        constantConstructorDeclaration (redirection | initializers)?
        functionDeclaration redirection
        namedConstructorDeclaration redirection
        ABSTRACT specialSignatureDefinition
        ABSTRACT functionDeclaration
        STATIC FINAL type? staticFinalDeclarationList
        STATIC? constInitializedVariableDeclaration
constantConstructorDeclaration:
        CONST qualified formalParameterList
redirection:
        ":" THIS ("." identifier)? arguments
initializers:
        ":" superCallOrFieldInitializer ("," superCallOrFieldInitializer)*
superCallOrFieldInitializer:
        SUPER arguments
        SUPER "." identifier arguments
        fieldInitializer
fieldInitializer:
        (THIS ".")? identifier "=" conditionalExpression
namedConstructorDeclaration:
        identifier "." identifier formalParameterList
specialSignatureDefinition:
        STATIC? returnType? getOrSet identifier formalParameterList
        returnType? OPERATOR userDefinableOperator formalParameterList
getOrSet:
        GET
        SET
userDefinableOperator:
        multiplicativeOperator
        additiveOperator
        shiftOperator
        relationalOperator
        bitwiseOperator
        "=="
        "~"
        NEGATE
        "[" "]"
        "[" "]" "="
bitwiseOperator:
        "&"
        "^"
        "|"
staticFinalDeclarationList:
        staticFinalDeclaration ("," staticFinalDeclaration)*
staticFinalDeclaration:
        identifier "=" constantExpression
constInitializedVariableDeclaration:
        declaredIdentifier ("=" constantExpression)? ("," constInitializedIdentifier)*
constInitializedIdentifier:
        identifier ("=" constantExpression)?
constructorDeclaration:
        identifier formalParameterList (redirection | initializers)?
        namedConstructorDeclaration (redirection | initializers)?
methodDeclaration:
        factoryConstructorDeclaration
        STATIC functionDeclaration
        specialSignatureDefinition
        functionDeclaration initializers?
        namedConstructorDeclaration initializers?
factoryConstructorDeclaration:
        FACTORY qualified typeParameters? ("." identifier)? formalParameterList
functionBodyOrNative:
        NATIVE functionBody
        functionNative
        functionBody
functionNative:
        NATIVE STRING? ";"
interfaceDefinition:
        INTERFACE identifier typeParameters? superinterfaces? factorySpecification? "{" interfaceMemberDefinition* "}"
superinterfaces:
        EXTENDS typeList
factorySpecification:
        FACTORY type
interfaceMemberDefinition:
        STATIC FINAL type? initializedIdentifierList ";"
        functionDeclaration ";"
        constantConstructorDeclaration ";"
        namedConstructorDeclaration ";"
        specialSignatureDefinition ";"
        variableDeclaration ";"
initializedIdentifierList:
        initializedIdentifier ("," initializedIdentifier)*
variableDeclaration:
        declaredIdentifier ("," identifier)*
functionTypeAlias:
        TYPEDEF functionPrefix typeParameters? formalParameterList ";"
functionPrefix:
        returnType? identifier
libraryUnit:
        libraryDefinition EOF
libraryDefinition:
        LIBRARY "{" libraryBody "}"
libraryBody:
        libraryImport? librarySource?
libraryImport:
        IMPORT "=" "[" importReferences? "]"
importReferences:
        importReference ("," importReference)* ","?
importReference:
        (IDENTIFIER ":")? STRING
librarySource:
        SOURCE "=" "[" sourceUrls? "]"
sourceUrls:
        STRING ("," STRING)* ","?
