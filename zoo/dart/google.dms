compilationUnit = HASHBANG? directive* topLevelDefinition* EOF ;
HASHBANG = '#!' ANY* NEWLINE? ;
NEWLINE = '\n' ;
NEWLINE = '\r' ;
directive = '#' IDENTIFIER arguments ';' ;
identifier = IDENTIFIER_NO_DOLLAR ;
identifier = IDENTIFIER ;
identifier = ABSTRACT ;
identifier = ASSERT ;
identifier = CLASS ;
identifier = EXTENDS ;
identifier = FACTORY ;
identifier = GET ;
identifier = IMPLEMENTS ;
identifier = IMPORT ;
identifier = INTERFACE ;
identifier = IS ;
identifier = LIBRARY ;
identifier = NATIVE ;
identifier = NEGATE ;
identifier = OPERATOR ;
identifier = SET ;
identifier = SOURCE ;
identifier = STATIC ;
identifier = TYPEDEF ;
IDENTIFIER_NO_DOLLAR = IDENTIFIER_START_NO_DOLLAR IDENTIFIER_PART_NO_DOLLAR* ;
IDENTIFIER_START_NO_DOLLAR = LETTER ;
IDENTIFIER_START_NO_DOLLAR = '_' ;
LETTER = 'a' ;
LETTER = 'b' ;
LETTER = 'c' ;
LETTER = 'd' ;
LETTER = 'e' ;
LETTER = 'f' ;
LETTER = 'g' ;
LETTER = 'h' ;
LETTER = 'i' ;
LETTER = 'j' ;
LETTER = 'k' ;
LETTER = 'l' ;
LETTER = 'm' ;
LETTER = 'n' ;
LETTER = 'o' ;
LETTER = 'p' ;
LETTER = 'q' ;
LETTER = 'r' ;
LETTER = 's' ;
LETTER = 't' ;
LETTER = 'u' ;
LETTER = 'v' ;
LETTER = 'w' ;
LETTER = 'x' ;
LETTER = 'y' ;
LETTER = 'z' ;
LETTER = 'A' ;
LETTER = 'B' ;
LETTER = 'C' ;
LETTER = 'D' ;
LETTER = 'E' ;
LETTER = 'F' ;
LETTER = 'G' ;
LETTER = 'H' ;
LETTER = 'I' ;
LETTER = 'J' ;
LETTER = 'K' ;
LETTER = 'L' ;
LETTER = 'M' ;
LETTER = 'N' ;
LETTER = 'O' ;
LETTER = 'P' ;
LETTER = 'Q' ;
LETTER = 'R' ;
LETTER = 'S' ;
LETTER = 'T' ;
LETTER = 'U' ;
LETTER = 'V' ;
LETTER = 'W' ;
LETTER = 'X' ;
LETTER = 'Y' ;
LETTER = 'Z' ;
IDENTIFIER_PART_NO_DOLLAR = IDENTIFIER_START_NO_DOLLAR ;
IDENTIFIER_PART_NO_DOLLAR = DIGIT ;
DIGIT = '0' ;
DIGIT = '1' ;
DIGIT = '2' ;
DIGIT = '3' ;
DIGIT = '4' ;
DIGIT = '5' ;
DIGIT = '6' ;
DIGIT = '7' ;
DIGIT = '8' ;
DIGIT = '9' ;
IDENTIFIER = IDENTIFIER_START IDENTIFIER_PART* ;
IDENTIFIER_START = IDENTIFIER_START_NO_DOLLAR ;
IDENTIFIER_START = '$' ;
IDENTIFIER_PART = IDENTIFIER_START ;
IDENTIFIER_PART = DIGIT ;
ABSTRACT = 'abstract' ;
ASSERT = 'assert' ;
CLASS = 'class' ;
EXTENDS = 'extends' ;
FACTORY = 'factory' ;
GET = 'get' ;
IMPLEMENTS = 'implements' ;
IMPORT = 'import' ;
INTERFACE = 'interface' ;
IS = 'is' ;
LIBRARY = 'library' ;
NATIVE = 'native' ;
NEGATE = 'negate' ;
OPERATOR = 'operator' ;
SET = 'set' ;
SOURCE = 'source' ;
STATIC = 'static' ;
TYPEDEF = 'typedef' ;
arguments = '(' argumentList? ')' ;
argumentList = namedArgument (',' namedArgument)* ;
argumentList = expressionList (',' namedArgument)* ;
namedArgument = label expression ;
label = IDENTIFIER ':' ;
expression = assignableExpression assignmentOperator expression ;
expression = conditionalExpression ;
assignableExpression = primary (arguments* assignableSelector)+ ;
assignableExpression = SUPER assignableSelector ;
assignableExpression = IDENTIFIER ;
primary = primaryNoFE ;
primary = primaryFE ;
primaryNoFE = THIS ;
primaryNoFE = SUPER assignableSelector ;
primaryNoFE = literal ;
primaryNoFE = IDENTIFIER ;
primaryNoFE = CONST? typeArguments? compoundLiteral ;
primaryNoFE = (NEW | CONST) type ('.' IDENTIFIER)? arguments ;
primaryNoFE = expressionInParentheses ;
THIS = 'this' ;
SUPER = 'super' ;
assignableSelector = '[' expression ']' ;
assignableSelector = '.' IDENTIFIER ;
literal = NULL ;
literal = TRUE ;
literal = FALSE ;
literal = HEX_NUMBER ;
literal = NUMBER ;
literal = STRING ;
NULL = 'null' ;
TRUE = 'true' ;
FALSE = 'false' ;
HEX_NUMBER = '0x' HEX_DIGIT+ ;
HEX_NUMBER = '0X' HEX_DIGIT+ ;
HEX_DIGIT = 'a' ;
HEX_DIGIT = 'b' ;
HEX_DIGIT = 'c' ;
HEX_DIGIT = 'd' ;
HEX_DIGIT = 'e' ;
HEX_DIGIT = 'f' ;
HEX_DIGIT = 'A' ;
HEX_DIGIT = 'B' ;
HEX_DIGIT = 'C' ;
HEX_DIGIT = 'D' ;
HEX_DIGIT = 'E' ;
HEX_DIGIT = 'F' ;
HEX_DIGIT = DIGIT ;
NUMBER = DIGIT+ NUMBER_OPT_FRACTIONAL_PART EXPONENT? NUMBER_OPT_ILLEGAL_END ;
NUMBER = '.' DIGIT+ EXPONENT? NUMBER_OPT_ILLEGAL_END ;
NUMBER_OPT_FRACTIONAL_PART = '.' DIGIT+ ;
NUMBER_OPT_FRACTIONAL_PART =  ;
EXPONENT = ('e' | 'E') ('+' | '-')? DIGIT+ ;
NUMBER_OPT_ILLEGAL_END = ;
STRING = '@'? MULTI_LINE_STRING ;
STRING = SINGLE_LINE_STRING ;
MULTI_LINE_STRING = '"""' ANY* '"""' ;
MULTI_LINE_STRING = '\'\'\'' ANY* '\'\'\'' ;
SINGLE_LINE_STRING = '"' STRING_CONTENT_DQ* '"' ;
SINGLE_LINE_STRING = '\'' STRING_CONTENT_SQ* '\'' ;
SINGLE_LINE_STRING = '@' '\'' ANY* '\'' ;
SINGLE_LINE_STRING = '@' '"' ANY* '"' ;
STRING_CONTENT_DQ = ANY ;
STRING_CONTENT_DQ = '\\' ANY ;
STRING_CONTENT_SQ = ANY ;
STRING_CONTENT_SQ = '\\' ANY ;
CONST = 'const' ;
typeArguments = '<' typeList '>' ;
typeList = type (',' type)* ;
type = qualified typeArguments? ;
qualified = IDENTIFIER ('.' IDENTIFIER)? ;
compoundLiteral = listLiteral ;
compoundLiteral = mapLiteral ;
listLiteral = '[' (expressionList ','?)? ']' ;
expressionList = expression (',' expression)* ;
mapLiteral = '{' (mapLiteralEntry (',' mapLiteralEntry)* ','?)? '}' ;
mapLiteralEntry = STRING ':' expression ;
NEW = 'new' ;
expressionInParentheses = '(' expression ')' ;
primaryFE = functionExpression ;
primaryFE = primaryNoFE ;
functionExpression = (returnType? IDENTIFIER)? formalParameterList functionExpressionBody ;
returnType = VOID ;
returnType = type ;
VOID = 'void' ;
formalParameterList = '(' namedFormalParameters? ')' ;
formalParameterList = '(' normalFormalParameter normalFormalParameterTail? ')' ;
namedFormalParameters = '[' defaultFormalParameter (',' defaultFormalParameter)* ']' ;
defaultFormalParameter = normalFormalParameter ('=' constantExpression)? ;
normalFormalParameter = functionDeclaration ;
normalFormalParameter = fieldFormalParameter ;
normalFormalParameter = simpleFormalParameter ;
functionDeclaration = returnType? IDENTIFIER formalParameterList ;
fieldFormalParameter = finalVarOrType? THIS '.' IDENTIFIER ;
finalVarOrType = FINAL type? ;
finalVarOrType = VAR ;
finalVarOrType = type ;
FINAL = 'final' ;
VAR = 'var' ;
simpleFormalParameter = declaredIdentifier ;
simpleFormalParameter = IDENTIFIER ;
declaredIdentifier = FINAL type? IDENTIFIER ;
declaredIdentifier = VAR IDENTIFIER ;
declaredIdentifier = type IDENTIFIER ;
constantExpression = expression ;
normalFormalParameterTail = ',' namedFormalParameters ;
normalFormalParameterTail = ',' normalFormalParameter normalFormalParameterTail? ;
functionExpressionBody = '=>' expression ;
functionExpressionBody = block ;
block = '{' statements '}' ;
statements = statement* ;
statement = label* nonLabelledStatement ;
nonLabelledStatement = block ;
nonLabelledStatement = initializedVariableDeclaration ';' ;
nonLabelledStatement = iterationStatement ;
nonLabelledStatement = selectionStatement ;
nonLabelledStatement = tryStatement ;
nonLabelledStatement = BREAK IDENTIFIER? ';' ;
nonLabelledStatement = CONTINUE IDENTIFIER? ';' ;
nonLabelledStatement = RETURN expression? ';' ;
nonLabelledStatement = THROW expression? ';' ;
nonLabelledStatement = expression? ';' ;
nonLabelledStatement = ASSERT '(' conditionalExpression ')' ';' ;
nonLabelledStatement = functionDeclaration functionBody ;
initializedVariableDeclaration = declaredIdentifier ('=' expression)? (',' initializedIdentifier)* ;
initializedIdentifier = IDENTIFIER ('=' expression)? ;
iterationStatement = WHILE '(' expression ')' statement ;
iterationStatement = DO statement WHILE '(' expression ')' ';' ;
iterationStatement = FOR '(' forLoopParts ')' statement ;
WHILE = 'while' ;
DO = 'do' ;
FOR = 'for' ;
forLoopParts = forInitializerStatement expression? ';' expressionList? ;
forLoopParts = declaredIdentifier IN expression ;
forLoopParts = IDENTIFIER IN expression ;
forInitializerStatement = initializedVariableDeclaration ';' ;
forInitializerStatement = expression? ';' ;
IN = 'in' ;
selectionStatement = IF '(' expression ')' statement (ELSE statement)? ;
selectionStatement = SWITCH '(' expression ')' '{' switchCase* defaultCase? '}' ;
IF = 'if' ;
ELSE = 'else' ;
SWITCH = 'switch' ;
switchCase = label? (CASE expression ':')+ statements ;
CASE = 'case' ;
defaultCase = label? (CASE expression ':')* DEFAULT ':' statements ;
DEFAULT = 'default' ;
tryStatement = TRY block ((catchPart+ finallyPart?) | finallyPart) ;
TRY = 'try' ;
catchPart = CATCH '(' declaredIdentifier (',' declaredIdentifier)? ')' block ;
CATCH = 'catch' ;
finallyPart = FINALLY block ;
FINALLY = 'finally' ;
BREAK = 'break' ;
CONTINUE = 'continue' ;
RETURN = 'return' ;
THROW = 'throw' ;
conditionalExpression = logicalOrExpression ('?' expression ':' expression)? ;
logicalOrExpression = logicalAndExpression ('||' logicalAndExpression)* ;
logicalAndExpression = bitwiseOrExpression ('&&' bitwiseOrExpression)* ;
bitwiseOrExpression = bitwiseXorExpression ('|' bitwiseXorExpression)* ;
bitwiseOrExpression = SUPER ('|' bitwiseXorExpression)+ ;
bitwiseXorExpression = bitwiseAndExpression ('^' bitwiseAndExpression)* ;
bitwiseXorExpression = SUPER ('^' bitwiseAndExpression)+ ;
bitwiseAndExpression = equalityExpression ('&' equalityExpression)* ;
bitwiseAndExpression = SUPER ('&' equalityExpression)+ ;
equalityExpression = relationalExpression (equalityOperator relationalExpression)? ;
equalityExpression = SUPER equalityOperator relationalExpression ;
relationalExpression = shiftExpression ((isOperator type) | (relationalOperator shiftExpression))? ;
relationalExpression = SUPER relationalOperator shiftExpression ;
shiftExpression = additiveExpression (shiftOperator additiveExpression)* ;
shiftExpression = SUPER (shiftOperator additiveExpression)+ ;
additiveExpression = multiplicativeExpression (additiveOperator multiplicativeExpression)* ;
additiveExpression = SUPER (additiveOperator multiplicativeExpression)+ ;
multiplicativeExpression = unaryExpression (multiplicativeOperator unaryExpression)* ;
multiplicativeExpression = SUPER (multiplicativeOperator unaryExpression)+ ;
unaryExpression = postfixExpression ;
unaryExpression = prefixOperator unaryExpression ;
unaryExpression = negateOperator SUPER ;
unaryExpression = '-' SUPER ;
unaryExpression = incrementOperator assignableExpression ;
postfixExpression = assignableExpression postfixOperator ;
postfixExpression = primary selector* ;
postfixOperator = incrementOperator ;
incrementOperator = '++' ;
incrementOperator = '--' ;
selector = assignableSelector ;
selector = arguments ;
prefixOperator = additiveOperator ;
prefixOperator = negateOperator ;
additiveOperator = '+' ;
additiveOperator = '-' ;
negateOperator = '!' ;
negateOperator = '~' ;
multiplicativeOperator = '*' ;
multiplicativeOperator = '/' ;
multiplicativeOperator = '%' ;
multiplicativeOperator = '~/' ;
shiftOperator = '<<' ;
shiftOperator = '>>>' ;
shiftOperator = '>>' ;
isOperator = IS '!'? ;
relationalOperator = '>=' ;
relationalOperator = '>' ;
relationalOperator = '<=' ;
relationalOperator = '<' ;
equalityOperator = '==' ;
equalityOperator = '!=' ;
equalityOperator = '===' ;
equalityOperator = '!==' ;
functionBody = '=>' expression ';' ;
functionBody = block ;
assignmentOperator = '=' ;
assignmentOperator = '*=' ;
assignmentOperator = '/=' ;
assignmentOperator = '~/=' ;
assignmentOperator = '%=' ;
assignmentOperator = '+=' ;
assignmentOperator = '-=' ;
assignmentOperator = '<<=' ;
assignmentOperator = '>>>=' ;
assignmentOperator = '>>=' ;
assignmentOperator = '&=' ;
assignmentOperator = '^=' ;
assignmentOperator = '|=' ;
topLevelDefinition = classDefinition ;
topLevelDefinition = interfaceDefinition ;
topLevelDefinition = functionTypeAlias ;
topLevelDefinition = functionDeclaration functionBodyOrNative ;
topLevelDefinition = returnType? getOrSet IDENTIFIER formalParameterList functionBodyOrNative ;
topLevelDefinition = FINAL type? staticFinalDeclarationList ';' ;
topLevelDefinition = constInitializedVariableDeclaration ';' ;
classDefinition = CLASS IDENTIFIER typeParameters? superclass? interfaces? '{' classMemberDefinition* '}' ;
classDefinition = CLASS IDENTIFIER typeParameters? interfaces? NATIVE STRING '{' classMemberDefinition* '}' ;
typeParameters = '<' typeParameter (',' typeParameter)* '>' ;
typeParameter = IDENTIFIER (EXTENDS type)? ;
superclass = EXTENDS type ;
interfaces = IMPLEMENTS typeList ;
classMemberDefinition = declaration ';' ;
classMemberDefinition = constructorDeclaration ';' ;
classMemberDefinition = methodDeclaration functionBodyOrNative ;
classMemberDefinition = CONST factoryConstructorDeclaration functionNative ;
declaration = constantConstructorDeclaration (redirection | initializers)? ;
declaration = functionDeclaration redirection ;
declaration = namedConstructorDeclaration redirection ;
declaration = ABSTRACT specialSignatureDefinition ;
declaration = ABSTRACT functionDeclaration ;
declaration = STATIC FINAL type? staticFinalDeclarationList ;
declaration = STATIC? constInitializedVariableDeclaration ;
constantConstructorDeclaration = CONST qualified formalParameterList ;
redirection = ':' THIS ('.' IDENTIFIER)? arguments ;
initializers = ':' superCallOrFieldInitializer (',' superCallOrFieldInitializer)* ;
superCallOrFieldInitializer = SUPER arguments ;
superCallOrFieldInitializer = SUPER '.' IDENTIFIER arguments ;
superCallOrFieldInitializer = fieldInitializer ;
fieldInitializer = (THIS '.')? IDENTIFIER '=' conditionalExpression ;
namedConstructorDeclaration = IDENTIFIER '.' IDENTIFIER formalParameterList ;
specialSignatureDefinition = STATIC? returnType? getOrSet IDENTIFIER formalParameterList ;
specialSignatureDefinition = returnType? OPERATOR userDefinableOperator formalParameterList ;
getOrSet = GET ;
getOrSet = SET ;
userDefinableOperator = multiplicativeOperator ;
userDefinableOperator = additiveOperator ;
userDefinableOperator = shiftOperator ;
userDefinableOperator = relationalOperator ;
userDefinableOperator = bitwiseOperator ;
userDefinableOperator = '==' ;
userDefinableOperator = '~' ;
userDefinableOperator = NEGATE ;
userDefinableOperator = '[' ']' ;
userDefinableOperator = '[' ']' '=' ;
bitwiseOperator = '&' ;
bitwiseOperator = '^' ;
bitwiseOperator = '|' ;
staticFinalDeclarationList = staticFinalDeclaration (',' staticFinalDeclaration)* ;
staticFinalDeclaration = IDENTIFIER '=' constantExpression ;
constInitializedVariableDeclaration = declaredIdentifier ('=' constantExpression)? (',' constInitializedIdentifier)* ;
constInitializedIdentifier = IDENTIFIER ('=' constantExpression)? ;
constructorDeclaration = IDENTIFIER formalParameterList (redirection | initializers)? ;
constructorDeclaration = namedConstructorDeclaration (redirection | initializers)? ;
methodDeclaration = factoryConstructorDeclaration ;
methodDeclaration = STATIC functionDeclaration ;
methodDeclaration = specialSignatureDefinition ;
methodDeclaration = functionDeclaration initializers? ;
methodDeclaration = namedConstructorDeclaration initializers? ;
factoryConstructorDeclaration = FACTORY qualified typeParameters? ('.' IDENTIFIER)? formalParameterList ;
functionBodyOrNative = NATIVE functionBody ;
functionBodyOrNative = functionNative ;
functionBodyOrNative = functionBody ;
functionNative = NATIVE STRING? ';' ;
interfaceDefinition = INTERFACE IDENTIFIER typeParameters? superinterfaces? factorySpecification? '{' interfaceMemberDefinition* '}' ;
superinterfaces = EXTENDS typeList ;
factorySpecification = FACTORY type ;
interfaceMemberDefinition = STATIC FINAL type? initializedIdentifierList ';' ;
interfaceMemberDefinition = functionDeclaration ';' ;
interfaceMemberDefinition = constantConstructorDeclaration ';' ;
interfaceMemberDefinition = namedConstructorDeclaration ';' ;
interfaceMemberDefinition = specialSignatureDefinition ';' ;
interfaceMemberDefinition = variableDeclaration ';' ;
initializedIdentifierList = initializedIdentifier (',' initializedIdentifier)* ;
variableDeclaration = declaredIdentifier (',' IDENTIFIER)* ;
functionTypeAlias = TYPEDEF functionPrefix typeParameters? formalParameterList ';' ;
functionPrefix = returnType? IDENTIFIER ;
libraryUnit = libraryDefinition EOF ;
libraryDefinition = LIBRARY '{' libraryBody '}' ;
libraryBody = libraryImport? librarySource? ;
libraryImport = IMPORT '=' '[' importReferences? ']' ;
importReferences = importReference (',' importReference)* ','? ;
importReference = (IDENTIFIER ':')? STRING ;
librarySource = SOURCE '=' '[' sourceUrls? ']' ;
sourceUrls = STRING (',' STRING)* ','? ;
