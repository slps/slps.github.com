module Main

exports
  sorts
        Class-declaration Indexing Index-list Index-clause Index Index-terms Index-value Class-header Header-mark Class-name Formal-generics Formal-generic-list Formal-generic Formal-generic-name Constraint Obsolete Message Inheritance Parent-list Parent Feature-adaptation Rename Rename-list Rename-pair New-exports New-export-list New-export-item Feature-set Feature-list Clients Class-list Redefine Undefine Select Creators Creation-clause Procedure-list Procedure-name Features Feature-clause Feature-declaration-list Feature-declaration Declaration-body Constant-or-routine Feature-value Unique New-feature-list New-feature Feature-name Prefix Infix Prefix-operator Infix-operator Unary Binary Formal-arguments Entity-declaration-list Entity-declaration-group Identifier-list Type-mark Routine Routine-body Effective Internal Routine-mark Deferred External Language-name External-name Local-declarations Precondition Postcondition Invariant Assertion Assertion-clause Unlabeled-assertion-clause Tag-mark Tag Rescue Type Class-type Actual-generics Type-list Class-type-expanded Class-type-separate Bit-type Bit-length Anchored Anchor Compound Instruction Creation Creation-call Assignment Assignment-attempt Conditional Then-part-list Then-part Else-part Multi-branch When-part-list When-part Choices Choice Interval Choice-constant Loop Initialization Variant Loop-body Exit Debug Debug-keys Debug-key-list Debug-key Check Retry Null-instruction Call Qualified-call Call-qualifier Call-target Call-chain Unqualified-call Precursor Parent-qualification Attribute Writable Actuals Actual-list Actual Address Address-mark Expression Boolean-expression Operator-expression Parenthesized Unary-expression Binary-expression Equality Comparison Manifest-constant Boolean-constant Integer-constant Real-constant Sign Wide-character-constant Wide-manifest-string Manifest-array Expression-list Old Strip Attribute-list Identifier Integer 
  context-free syntax
        Indexing? Class-header Formal-generics? Obsolete? Inheritance? Creators? Features? Invariant? "end" ("--" "class" Class-name)? -> Class-declaration

        "indexing" Index-list -> Indexing

        (Index-clause ";")* -> Index-list

        Index? Index-terms -> Index-clause

        Identifier ":" -> Index

        (Index-value ",")+ -> Index-terms

        Identifier -> Index-value
        Manifest-constant -> Index-value

        Header-mark? "class" Class-name -> Class-header

        "deferred" -> Header-mark
        "expanded" -> Header-mark
        "separate" -> Header-mark

        Identifier -> Class-name

        Formal-generic-list? -> Formal-generics

        (Formal-generic ",")* -> Formal-generic-list

        Formal-generic-name Constraint? -> Formal-generic

        Identifier -> Formal-generic-name

        "-" ">" Class-type -> Constraint

        "obsolete" Message -> Obsolete

        Manifest-string -> Message

        "inherit" Parent-list -> Inheritance

        (Parent ";")* -> Parent-list

        Class-type Feature-adaptation? -> Parent

        Rename? New-exports? Undefine? Redefine? Select? "end" -> Feature-adaptation

        "rename" Rename-list -> Rename

        (Rename-pair ",")* -> Rename-list

        Feature-name "as" Feature-name -> Rename-pair

        "export" New-export-list -> New-exports

        (New-export-item ";")* -> New-export-list

        Clients Feature-set -> New-export-item

        Feature-list -> Feature-set
        "all" -> Feature-set

        (Feature-name ",")* -> Feature-list

        "{" Class-list "}" -> Clients

        (Class-name ",")* -> Class-list

        "redefine" Feature-list -> Redefine

        "undefine" Feature-list -> Undefine

        "select" Feature-list -> Select

        "creation" (Creation-clause "creation")+ -> Creators

        Clients? Header-comment? Procedure-list -> Creation-clause

        (Procedure-name ",")* -> Procedure-list

        Identifier -> Procedure-name

        "feature" (Feature-clause "feature")+ -> Features

        Clients? Header-comment? Feature-declaration-list -> Feature-clause

        (Feature-declaration ";")* -> Feature-declaration-list

        New-feature-list Declaration-body -> Feature-declaration

        Formal-arguments? Type-mark? Constant-or-routine? -> Declaration-body

        "is" Feature-value -> Constant-or-routine

        Manifest-constant -> Feature-value
        Unique -> Feature-value
        Routine -> Feature-value

        "Unique" -> Unique

        (New-feature ",")+ -> New-feature-list

        "frozen"? Feature-name -> New-feature

        Identifier -> Feature-name
        Prefix -> Feature-name
        Infix -> Feature-name

        "prefix" """ Prefix-operator """ -> Prefix

        "infix" """ Infix-operator """ -> Infix

        Unary -> Prefix-operator
        Free-operator -> Prefix-operator

        Binary -> Infix-operator
        Free-operator -> Infix-operator

        "not" -> Unary
        "+" -> Unary
        "-" -> Unary

        "+" -> Binary
        "-" -> Binary
        "*" -> Binary
        "/" -> Binary
        "<" -> Binary
        ">" -> Binary
        "<=" -> Binary
        ">=" -> Binary
        "//" -> Binary
        "\\" -> Binary
        "^" -> Binary
        "and" -> Binary
        "or" -> Binary
        "xor" -> Binary
        "and" "then" -> Binary
        "or" "else" -> Binary
        "implies" -> Binary

        "(" Entity-declaration-list ")" -> Formal-arguments

        (Entity-declaration-group ";")* -> Entity-declaration-list

        Identifier-list Type-mark -> Entity-declaration-group

        (Identifier ",")+ -> Identifier-list

        ":" Type -> Type-mark

        Obsolete? Header-comment? Precondition? Local-declarations? Routine-body Postcondition? Rescue? "end" ("--" Feature-name)? -> Routine

        Effective -> Routine-body
        Deferred -> Routine-body

        Internal -> Effective
        External -> Effective

        Routine-mark Compound -> Internal

        "do" -> Routine-mark
        "once" -> Routine-mark

        "deferred" -> Deferred

        "external" Language-name External-name? -> External

        Manifest-string -> Language-name

        "alias" Manifest-string -> External-name

        "local" Entity-declaration-list -> Local-declarations

        "require" "else"? Assertion -> Precondition

        "ensure" "then"? Assertion -> Postcondition

        "invariant" Assertion -> Invariant

        (Assertion-clause ";")* -> Assertion

        Tag-mark? Unlabeled-assertion-clause -> Assertion-clause

        Boolean-expression -> Unlabeled-assertion-clause
        Comment -> Unlabeled-assertion-clause

        Tag ":" -> Tag-mark

        Identifier -> Tag

        "rescue" Compound -> Rescue

        Class-type -> Type
        Class-type-expanded -> Type
        Class-type-separate -> Type
        Anchored -> Type
        Bit-type -> Type

        Class-name Actual-generics? -> Class-type

        Type-list? -> Actual-generics

        (Type ",")* -> Type-list

        "expanded" Class-type -> Class-type-expanded

        "separate" Class-type -> Class-type-separate

        "BIT" Bit-length -> Bit-type

        Integer-constant -> Bit-length
        Attribute -> Bit-length

        "like" Anchor -> Anchored

        Identifier -> Anchor
        "Current" -> Anchor

        (Instruction ";")* -> Compound

        Creation -> Instruction
        Call -> Instruction
        Assignment -> Instruction
        Assignment-attempt -> Instruction
        Conditional -> Instruction
        Multi-branch -> Instruction
        Loop -> Instruction
        Debug -> Instruction
        Check -> Instruction
        Retry -> Instruction
        Null-instruction -> Instruction

        "!" Type? "!" Writable Creation-call? -> Creation

        "." Procedure-name Actuals? -> Creation-call

        Writable ":=" Expression -> Assignment

        Writable "?=" Expression -> Assignment-attempt

        "if" Then-part-list Else-part? "end" -> Conditional

        (Then-part "elseif")+ -> Then-part-list

        Boolean-expression "then" Compound -> Then-part

        "else" Compound -> Else-part

        "inspect" Expression When-part-list? Else-part? "end" -> Multi-branch

        "when" (When-part "when")+ -> When-part-list

        Choices "then" Compound -> When-part

        (Choice ",")* -> Choices

        Choice-constant -> Choice
        Interval -> Choice

        Choice-constant ".." Choice-constant -> Interval

        Integer-constant -> Choice-constant
        Character-constant -> Choice-constant
        Attribute -> Choice-constant

        Initialization Invariant? Variant? Loop-body "end" -> Loop

        "from" Compound -> Initialization

        "variant" Tag-mark? Expression -> Variant

        Exit "loop" Compound -> Loop-body

        "until" Boolean-expression -> Exit

        "debug" Debug-keys? Compound "end" -> Debug

        "(" Debug-key-list ")" -> Debug-keys

        (Debug-key ",")* -> Debug-key-list

        Manifest-string -> Debug-key

        "check" Assertion "end" -> Check

        "retry" -> Retry

         -> Null-instruction

        Qualified-call -> Call
        Precursor -> Call

        Call-qualifier? Call-chain -> Qualified-call

        Call-target "." -> Call-qualifier

        Parenthesized -> Call-target
        "Result" -> Call-target
        "Current" -> Call-target
        Precursor -> Call-target

        (Unqualified-call ".")+ -> Call-chain

        Identifier Actuals? -> Unqualified-call

        Parent-qualification? "Precursor" Actuals? -> Precursor

        "{" Class-name "}" -> Parent-qualification

        Identifier -> Attribute

        Identifier -> Writable
        "Result" -> Writable

        "(" Actual-list ")" -> Actuals

        (Actual ",")* -> Actual-list

        Expression -> Actual
        Address -> Actual

        "$" Address-mark -> Address

        Feature-name -> Address-mark
        "Current" -> Address-mark
        "Result" -> Address-mark

        "Current" -> Expression
        "Result" -> Expression
        Call -> Expression
        Operator-expression -> Expression
        Equality -> Expression
        Manifest-array -> Expression
        Old -> Expression
        Strip -> Expression
        Boolean-constant -> Expression
        Bit-constant -> Expression
        Integer -> Expression
        Real -> Expression
        Manifest-string -> Expression
        Character-constant -> Expression
        Wide-character-constant -> Expression
        Wide-manifest-string -> Expression
        Hexadecimal-constant -> Expression

        Expression -> Boolean-expression

        Parenthesized -> Operator-expression
        Unary-expression -> Operator-expression
        Binary-expression -> Operator-expression

        "(" Expression ")" -> Parenthesized

        Prefix-operator Expression -> Unary-expression

        Expression Infix-operator Expression -> Binary-expression

        Expression Comparison Expression -> Equality

        "=" -> Comparison
        "/=" -> Comparison

        Boolean-constant -> Manifest-constant
        Character-constant -> Manifest-constant
        Integer-constant -> Manifest-constant
        Real-constant -> Manifest-constant
        Manifest-string -> Manifest-constant
        Bit-constant -> Manifest-constant
        Wide-character-constant -> Manifest-constant
        Wide-manifest-string -> Manifest-constant
        Hexadecimal-constant -> Manifest-constant

        "True" -> Boolean-constant
        "False" -> Boolean-constant

        Sign? Integer -> Integer-constant

        Sign? Real -> Real-constant

        "+" -> Sign
        "-" -> Sign

        "$" Character-constant -> Wide-character-constant

        "$" Manifest-string -> Wide-manifest-string

        "<<" Expression-list ">>" -> Manifest-array

        (Expression ",")* -> Expression-list

        "old" Expression -> Old

        "Strip" "(" Attribute-list ")" -> Strip

        (Attribute ",")* -> Attribute-list

        Letter (Letter | Decimal-digit | "_")* -> Identifier

        Decimal-digit+ -> Integer
        Decimal-digit (Decimal-digit Decimal-digit?)? ("_" Decimal-digit Decimal-digit Decimal-digit)+ -> Integer
