program = Class_declaration* ;
Class_declaration = Indexing? NL Class_header Formal_generics? (NL IN) Obsolete? Inheritance? Creators? Features? Invariant? EX 'end' ;
Indexing = NL 'indexing' Index_list ;
Index_list = (NL IN) Index_clause_Separator* EX ;
Index_clause_Separator = Index_clause Separator ;
Index_clause = Index? Index_terms ;
Index = Identifier ':' ;
Index_terms = Index_value',' ;
Index_value = Identifier+ ;
Index_value = Manifest_constant ;
Class_header = Header_mark? 'class' Class_name ;
Header_mark = 'deferred' ;
Header_mark = 'expanded' ;
Class_name = Identifier ;
Formal_generics = '[' Formal_generic_list ']' ;
Formal_generic_list = Formal_generic',' ;
Formal_generic = Formal_generic_name Constraint? ;
Formal_generic_name = Identifier ;
Constraint = '->' Restricted_type ;
Obsolete = 'obsolete' Message NL ;
Message = Manifest_string ;
Features = feature_Feature_clause+ ;
feature_Feature_clause = NL 'feature' Clients? Feature_clause ;
Feature_clause = Header_comment? Feature_declaration_list ;
Feature_declaration_list = (IN NL) Feature_declaration_Separator* EX ;
Feature_declaration_Separator = Feature_declaration Separator ;
Feature_declaration_Separator = Routine_feature_declaration Separator ;
Header_comment = Comment ;
Feature_declaration = New_feature_list Declaration_body ;
Declaration_body = Formal_arguments? Type_mark? is_Constant? ;
is_Constant = 'is' Feature_value ;
Feature_value = Manifest_constant ;
Feature_value = Unique ;
Routine_feature_declaration = NL New_feature_list Routine_declaration_body ;
Routine_declaration_body = Formal_arguments? Type_mark? is_Routine? ;
is_Routine = 'is' NL Routine ;
New_feature_list = New_feature+ ;
New_feature = 'frozen'? Feature_name ;
Feature_name = Identifier ;
Feature_name = Prefix ;
Feature_name = Infix ;
Prefix = 'prefix' Prefix_name ;
Infix = 'infix' Infix_name ;
Prefix_name = Manifest_string ;
Infix_name = Manifest_string ;
Unary = 'not' ;
Unary = '+' ;
Unary = '-' ;
Binary = '+' ;
Binary = '-' ;
Binary = '*' ;
Binary = '/' ;
Binary = '<' ;
Binary = '>' ;
Binary = '<=' ;
Binary = '>=' ;
Binary = '//' ;
Binary = '\\' ;
Binary = '^' ;
Binary = 'and' ;
Binary = 'or' ;
Binary = 'xor' ;
Binary = 'and' 'then' ;
Binary = 'or' 'else' ;
Binary = 'implies' ;
Inheritance = 'inherit' (NL IN) Parent_list EX ;
Parent_list = Parent_Separator* ;
Parent_Separator = Parent Separator ;
Parent = Restricted_class_type Feature_adaptation? ;
Feature_adaptation = (NL IN) Rename? New_exports? Undefine? Redefine? Select? EX 'end' ;
Rename = 'rename' Rename_list NL ;
Rename_list = Rename_pair',' ;
Rename_pair = Feature_name 'as' Feature_name ;
Clients = '{' Class_list '}' ;
Class_list = Class_name',' ;
New_exports = 'export' New_export_list NL ;
New_export_list = New_export_item_Separator* ;
New_export_item_Separator = New_export_item Separator ;
New_export_item = Clients Feature_set ;
Feature_set = Feature_list ;
Feature_set = 'all' ;
Feature_list = (IN NL) Feature_name',' EX ;
Formal_arguments = '(' Formal_entity_declaration_list ')' ;
Formal_entity_declaration_list = Formal_entity_declaration_group_Separator* ;
Formal_entity_declaration_group_Separator = Entity_declaration_group ';'? ;
Entity_declaration_list = (IN NL) Entity_declaration_group_Separator* EX ;
Entity_declaration_group_Separator = Entity_declaration_group Separator ;
Entity_declaration_group = Identifier_list Type_mark ;
Identifier_list = Identifier+ ;
Type_mark = ':' Type ;
Routine = Obsolete? Header_comment? Precondition? Local_declarations? Routine_body Postcondition? Rescue? 'end' ;
Routine_body = Effective ;
Routine_body = Deferred ;
Effective = Internal ;
Effective = External ;
Internal = Routine_mark Compound ;
Routine_mark = 'do' ;
Routine_mark = 'once' ;
Deferred = IN 'deferred' (NL EX) ;
Local_declarations = 'local' Entity_declaration_list ;
Instruction = Creation ;
Instruction = Call ;
Instruction = Assignment ;
Instruction = Assignment_attempt ;
Instruction = Conditional ;
Instruction = Multi_branch ;
Instruction = Loop ;
Instruction = Debug ;
Instruction = Check ;
Instruction = Retry ;
Instruction = Null ;
Precondition = 'require' 'else'? Assertion ;
Postcondition = 'ensure' 'then'? Assertion ;
Invariant = 'invariant' Assertion ;
Assertion = (NL IN) Assertion_clause_Separator* EX ;
Assertion_clause_Separator = Assertion_clause Separator ;
Assertion_clause = Tag_mark? Unlabeled_assertion_clause ;
Unlabeled_assertion_clause = Boolean_expression ;
Unlabeled_assertion_clause = Comment ;
Tag_mark = Tag ':' ;
Tag = Identifier ;
Old = 'old' Expression ;
Check = 'check' Assertion 'end' ;
Variant = 'variant' Tag_mark? Expression ;
Redefine = 'redefine' Feature_list NL ;
Undefine = 'undefine' Feature_list NL ;
Select = 'select' Feature_list NL ;
Type = Class_type ;
Type = Class_type_expanded ;
Type = Formal_generic_name ;
Type = Anchored ;
Type = Bit_type ;
Class_type = Class_name Actual_generics? ;
Actual_generics = '[' Type_list ']' ;
Type_list = Type',' ;
Class_type_expanded = 'expanded' Class_type ;
Bit_type = 'BIT' Constant ;
Anchored = 'like' Anchor ;
Anchor = Identifier ;
Anchor = 'Current' ;
Restricted_type = Restricted_class_type ;
Restricted_type = Formal_generic_name ;
Restricted_class_type = Class_name Restricted_actual_generics? ;
Restricted_actual_generics = '[' Restricted_type_list ']' ;
Restricted_type_list = Restricted_type',' ;
Compound = (IN NL) Instruction_Separator* EX ;
Instruction_Separator = Instruction Separator ;
Separator = ';'? NL ;
Null = ';' NL ;
Conditional = 'if' Then_part_list Else_part? 'end' ;
Then_part_list = Then_part elseif_Then_part* ;
elseif_Then_part = 'elseif' Then_part ;
Then_part = Boolean_expression 'then' Compound ;
Else_part = 'else' Compound ;
Multi_branch = 'inspect' Expression When_part_list? Else_part? 'end' ;
When_part_list = when_When_part+ ;
when_When_part = 'when' When_part ;
When_part = Choices 'then' Compound ;
Choices = Choice',' ;
Choice = Constant ;
Choice = Interval ;
Interval = Constant '..' Constant ;
Loop = Initialization Invariant? Variant? Loop_body 'end' ;
Initialization = 'from' Compound ;
Loop_body = Exit NL 'loop' Compound ;
Exit = 'until' Boolean_expression ;
Debug = 'debug' Debug_keys? Compound 'end' ;
Debug_keys = '(' Debug_key_list ')' ;
Debug_key_list = Debug_key',' ;
Debug_key = Manifest_string ;
Rescue = 'rescue' Compound ;
Retry = 'retry' ;
Unique = 'unique' ;
Entity = Writable ;
Entity = Read_only ;
Writable = Attribute ;
Writable = Local ;
Attribute = Identifier ;
Local = Identifier ;
Local = 'Result' ;
Read_only = Formal ;
Read_only = 'Current' ;
Formal = Identifier ;
Creators = creation_Creation_clause+ ;
creation_Creation_clause = NL 'creation' Creation_clause ;
Creation_clause = Clients? Header_comment? Feature_list NL ;
Creation = '!!' Writable Creation_call? ;
Creation = '!' Type? '!' Writable Creation_call? ;
Creation_call = '.' Unqualified_call ;
Assignment = Writable ':=' Expression ;
Assignment_attempt = Writable '?=' Expression ;
Call = Parenthesized_qualifier? Call_chain ;
Parenthesized_qualifier = Parenthesized '.' ;
Call_chain = Unqualified_call dot_Unqualified_call* ;
dot_Unqualified_call = '.' Unqualified_call ;
Unqualified_call = Entity Actuals? ;
Actuals = '(' Actual_list ')' ;
Actual_list = Actual',' ;
Actual = Expression ;
Actual = Address ;
Address = '$' Address_mark ;
Address_mark = Feature_name ;
Address_mark = 'Current' ;
Address_mark = 'Result' ;
Expression = Equality ;
Primitive_expression = Call ;
Primitive_expression = Manifest_constant ;
Primitive_expression = Manifest_array ;
Primitive_expression = Old ;
Primitive_expression = Strip ;
Primitive_expression = Parenthesized ;
Boolean_expression = Expression ;
Equality = Operator_expression Comparison_Operator_expression* ;
Comparison_Operator_expression = Comparison Operator_expression ;
Comparison = '=' ;
Comparison = '/=' ;
Operator_expression = Parenthesized ;
Operator_expression = Binary_expression ;
Parenthesized = '(' Expression ')' ;
Unary_expression = Prefix_operator* Primitive_expression ;
Binary_expression = Unary_expression Infix_operator_Unary_expression* ;
Infix_operator_Unary_expression = Infix_operator Unary_expression ;
Prefix_operator = Unary ;
Prefix_operator = Free_operator ;
Infix_operator = Binary ;
Infix_operator = Free_operator ;
Constant = Manifest_constant ;
Constant = Constant_attribute ;
Constant_attribute = Entity ;
Manifest_constant = Boolean_constant ;
Manifest_constant = Character_constant ;
Manifest_constant = Integer_constant ;
Manifest_constant = Real_constant ;
Manifest_constant = Manifest_string ;
Manifest_constant = Bit_constant ;
Sign = '+' ;
Sign = '-' ;
Integer_constant = Sign? Integer ;
Real_constant = Sign? Real ;
Boolean_constant = 'true' ;
Boolean_constant = 'false' ;
Bit_constant = Bit_sequence ;
Manifest_array = '<<' Expression_list '>>' ;
Expression_list = Expression',' ;
Strip = 'strip' '(' Attribute_list ')' ;
Attribute_list = Identifier',' ;
External = 'external' Language_name External_name? NL ;
Language_name = Manifest_string ;
External_name = 'alias' Manifest_string ;
Identifier = id ;
Manifest_string = string ;
Comment = comment ;
Character_constant = character_constant ;
Integer = integer ;
Real = real_number ;
Bit_sequence = bit_sequence ;
Free_operator = free_operator ;
