program = package_declaration ;
package_declaration = package_header? import_declaration* type_declaration* ;
package_header = 'package' package_name ';' NL NL ;
package_name = qualified_name ;
import_declaration = 'import' imported_name ';' NL NL ;
imported_name = package_or_type_name dot_star? ;
package_or_type_name = qualified_name ;
dot_star = '.' '*' ;
declared_name = reference ;
type_declaration = class_declaration NL NL ;
type_declaration = interface_declaration NL NL ;
class_declaration = class_header class_body ;
class_header = modifier* 'class' class_name extends_clause? implements_clause? ;
class_body = class_or_interface_body ;
interface_declaration = interface_header interface_body ;
interface_header = modifier* 'interface' interface_name extends_clause? implements_clause? ;
interface_body = class_or_interface_body ;
modifier = 'abstract' ;
modifier = 'final' ;
modifier = 'public' ;
modifier = 'protected' ;
modifier = 'private' ;
modifier = 'static' ;
modifier = 'transient' ;
modifier = 'volatile' ;
modifier = 'native' ;
modifier = 'synchronized' ;
modifier = 'strictfp' ;
extends_clause = 'extends' type_name+ ;
implements_clause = 'implements' qualified_name+ ;
class_name = declared_name ;
interface_name = declared_name ;
class_or_interface_body = '{' NL IN class_body_declaration* EX '}' ';'? NL NL ;
class_body_declaration = empty_declaration ;
class_body_declaration = member_declaration ;
class_body_declaration = instance_initializer ;
class_body_declaration = static_initializer ;
class_body_declaration = field_declaration ;
empty_declaration = ';' NL ;
member_declaration = method_or_constructor_declaration ;
member_declaration = type_declaration ;
method_or_constructor_declaration = method_declaration ;
method_or_constructor_declaration = constructor_declaration ;
instance_initializer = NL block NL NL ;
static_initializer = NL 'static' block NL NL ;
constructor_declaration = NL modifier* constructor_declarator throws? constructor_body NL NL ;
constructor_declarator = class_name '(' 
	    formal_parameter
	    ','
	   ')' ;
constructor_body = block NL ;
field_declaration = variable_declaration ;
variable_declaration = modifier* type_specifier variable_declarators ';' NL ;
variable_declarators = variable_declarator+ ;
variable_declarator = variable_name equals_variable_initializer? ;
variable_name = declared_name dimension* ;
equals_variable_initializer = '=' variable_initializer ;
variable_initializer = expression ;
variable_initializer = array_initializer ;
array_initializer = '{' 
	    variable_initializer
	    ','
	   ','? '}' ;
method_declaration = NL modifier* type_specifier method_declarator throws? method_body ;
method_declarator = method_name '(' 
	    formal_parameter
	    ','
	   ')' dimension* ;
method_name = declared_name ;
formal_parameter = 'final'? type_specifier formal_parameter_name ;
formal_parameter_name = variable_name ;
throws = 'throws' qualified_name+ ;
method_body = block NL NL ;
method_body = ';' NL NL ;
type_specifier = type_name ;
type_specifier = array_type_specifier ;
array_type_specifier = type_name dimension+ ;
type_name = primitive_type ;
type_name = qualified_name ;
primitive_type = 'boolean' ;
primitive_type = 'char' ;
primitive_type = 'byte' ;
primitive_type = 'short' ;
primitive_type = 'int' ;
primitive_type = 'long' ;
primitive_type = 'float' ;
primitive_type = 'double' ;
primitive_type = 'void' ;
block = '{' NL IN declaration_or_statement* EX '}' ;
declaration_or_statement = local_variable_declaration ;
declaration_or_statement = class_declaration ;
declaration_or_statement = statement ;
local_variable_declaration = variable_declaration ;
statement = label_statement ;
statement = empty_statement ;
statement = expression_statement ;
statement = if_statement ;
statement = switch_statement ;
statement = while_statement ;
statement = do_statement ;
statement = for_statement ;
statement = break_statement ;
statement = continue_statement ;
statement = return_statement ;
statement = throw_statement ;
statement = synchronized_statement ;
statement = try_statement ;
statement = block ;
empty_statement = ';' NL ;
label_statement = label_name ':' NL ;
label_name = reference ;
expression_statement = expression ';' NL ;
if_statement = 'if' '(' expression ')' statement else_clause? NL ;
else_clause = 'else' statement ;
switch_statement = 'switch' '(' expression ')' switch_block NL ;
switch_block = '{' IN NL switch_alternative* EX '}' ;
switch_alternative = switch_label IN NL declaration_or_statement* EX ;
switch_label = 'case' constant_expression ':' ;
switch_label = 'default' ':' ;
while_statement = 'while' '(' expression ')' statement NL ;
do_statement = 'do' statement 'while' '(' expression ')' ';' NL ;
for_statement = 'for' '(' for_init for_expression for_update ')' statement NL ;
for_init = 
		expression
		','
	       ';' ;
for_init = local_variable_declaration ;
for_expression = expression? ';' ;
for_update = 
	expression
	','
       ;
break_statement = 'break' label_name? ';' NL ;
continue_statement = 'continue' label_name? ';' NL ;
return_statement = 'return' expression? ';' NL ;
throw_statement = 'throw' expression ';' NL ;
synchronized_statement = 'synchronized' '(' expression ')' statement NL ;
try_statement = 'try' block catch_clause* finally_clause? NL ;
catch_clause = 'catch' '(' type_specifier variable_name ')' block ;
finally_clause = 'finally' block ;
constant_expression = expression ;
expression = assignment_expression ;
assignment_expression = conditional_expression ;
assignment_expression = unary_expression assignment_operator assignment_expression ;
assignment_operator = '=' ;
assignment_operator = '*=' ;
assignment_operator = '/=' ;
assignment_operator = '%=' ;
assignment_operator = '+=' ;
assignment_operator = '-=' ;
assignment_operator = '<<=' ;
assignment_operator = '>>=' ;
assignment_operator = '>>>=' ;
assignment_operator = '&=' ;
assignment_operator = '^=' ;
assignment_operator = '|=' ;
conditional_expression = conditional_or_expression conditional_choice? ;
conditional_choice = '?' expression ':' conditional_expression ;
conditional_or_expression = conditional_and_expression or_conditional_and_expression* ;
or_conditional_and_expression = '||' conditional_and_expression ;
conditional_and_expression = inclusive_or_expression and_inclusive_or_expression* ;
and_inclusive_or_expression = '&&' inclusive_or_expression ;
inclusive_or_expression = exclusive_or_expression or_exclusive_or_expression* ;
or_exclusive_or_expression = '|' exclusive_or_expression ;
exclusive_or_expression = and_expression or_and_expression* ;
or_and_expression = '^' and_expression ;
and_expression = equality_expression and_equality_expression* ;
and_equality_expression = '&' equality_expression ;
equality_expression = relational_expression equality_op_relational_expression* ;
equality_op_relational_expression = equality_op relational_expression ;
equality_op = '==' ;
equality_op = '!=' ;
relational_expression = shift_expression relational_op_shift_expression* ;
relational_op_shift_expression = relational_op shift_expression ;
relational_op_shift_expression = 'instanceof' type_specifier ;
relational_op = '<' ;
relational_op = '>' ;
relational_op = '<=' ;
relational_op = '>=' ;
shift_expression = additive_expression shift_additive_expression* ;
shift_additive_expression = shift_op additive_expression ;
shift_op = '<<' ;
shift_op = '>>' ;
shift_op = '>>>' ;
additive_expression = multiplicative_expression add_op_multiplicative_expression* ;
add_op_multiplicative_expression = add_op multiplicative_expression ;
add_op = '+' ;
add_op = '-' ;
multiplicative_expression = unary_expression mult_op_unary_expression* ;
mult_op_unary_expression = mult_op unary_expression ;
mult_op = '*' ;
mult_op = '/' ;
mult_op = '%' ;
unary_expression = pre_inc_dec unary_expression ;
unary_expression = unary_op unary_expression ;
unary_expression = postfix_expression ;
unary_expression = cast_expression ;
pre_inc_dec = '++' ;
pre_inc_dec = '--' ;
unary_op = '+' ;
unary_op = '-' ;
unary_op = '~' ;
unary_op = '!' ;
cast_expression = '(' type_specifier ')' unary_expression ;
postfix_expression = primary post_inc_dec* ;
post_inc_dec = '++' ;
post_inc_dec = '--' ;
subscript = '[' expression ']' ;
primary = literal ;
primary = reference ;
primary = '(' expression ')' component* ;
primary = class_instance_creation_expression ;
primary = array_creation_expression ;
literal = numeric_literal ;
literal = character_literal ;
literal = string_literal ;
literal = boolean_literal ;
literal = null_literal ;
numeric_literal = number ;
character_literal = charlit ;
string_literal = stringlit ;
boolean_literal = 'true' ;
boolean_literal = 'false' ;
null_literal = 'null' ;
class_instance_creation_expression = 'new' class_or_interface_name '(' 
	    argument
	    ','
	   ')' class_body? ;
class_or_interface_name = qualified_name ;
array_creation_expression = 'new' array_type_specifier array_initializer? ;
dimension = '[' expression? ']' ;
argument = expression ;
qualified_name = reference ;
reference = id component* ;
component = dot_id ;
component = method_argument ;
component = subscript ;
method_argument = '(' 
	    argument
	    ','
	   ')' ;
dot_id = '.' id ;
