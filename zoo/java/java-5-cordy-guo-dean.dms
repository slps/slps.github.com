program = package_declaration ;
package_declaration = package_header? import_declaration* type_declaration* ;
package_header = annotation* 'package' package_name ';' (NL NL) ;
package_name = qualified_name ;
import_declaration = 'import' 'static'? imported_name ';' (NL NL) ;
import_declaration = ';' NL ;
imported_name = package_or_type_name dot_star? ;
package_or_type_name = qualified_name ;
dot_star = '.' '*' ;
declared_name = id generic_parameter? ;
type_declaration = class_declaration (NL NL) ;
type_declaration = interface_declaration (NL NL) ;
type_declaration = enum_declaration NL ;
class_declaration = class_header class_body ;
class_header = modifier* 'class' class_name extends_clause? implements_clause? ;
class_body = class_or_interface_body ;
interface_declaration = interface_header interface_body ;
interface_header = modifier* annot_marker? 'interface' interface_name extends_clause? implements_clause? ;
annot_marker = '@' ;
interface_body = class_or_interface_body ;
enum_declaration = enum_header enum_body ;
enum_header = modifier* id? 'enum' declared_name? implements_clause? ;
enum_body = '{' IN enum_element',' ','? class_body_declaration* EX '}' ';'? (NL NL) ;
enum_element = NL id method_argument? ;
modifier = 'abstract' ;
modifier = 'final' ;
modifier = 'public' ;
modifier = 'protected' ;
modifier = 'private' ;
modifier = 'static' ;
modifier = 'transient' ;
modifier = 'volatile' ;
modifier = 'native' ;
modifier = 'synchronized' ;
modifier = 'strictfp' ;
modifier = annotation ;
extends_clause = 'extends' type_name+ ;
implements_clause = 'implements' qualified_name+ ;
class_name = declared_name ;
interface_name = declared_name ;
class_or_interface_body = '{' (NL IN) class_body_declaration* EX '}' ';'? (NL NL) ;
class_body_declaration = empty_declaration ;
class_body_declaration = member_declaration ;
class_body_declaration = instance_initializer ;
class_body_declaration = static_initializer ;
class_body_declaration = field_declaration ;
empty_declaration = ';' NL ;
member_declaration = method_or_constructor_declaration ;
member_declaration = type_declaration ;
method_or_constructor_declaration = method_declaration ;
method_or_constructor_declaration = constructor_declaration ;
instance_initializer = NL block (NL NL) ;
static_initializer = NL 'static' block (NL NL) ;
constructor_declaration = NL modifier* generic_parameter? constructor_declarator throws? constructor_body (NL NL) ;
constructor_declarator = class_name '(' formal_parameter',' ')' ;
constructor_body = block NL ;
field_declaration = variable_declaration ;
variable_declaration = modifier* type_specifier variable_declarators ';' NL ;
variable_declarators = variable_declarator+ ;
variable_declarator = variable_name equals_variable_initializer? ;
variable_name = declared_name dimension* ;
equals_variable_initializer = '=' variable_initializer ;
variable_initializer = expression ;
variable_initializer = array_initializer ;
array_initializer = '{' variable_initializer',' ','? '}' ;
method_declaration = NL modifier* generic_parameter? type_specifier method_declarator throws? method_body ;
method_declarator = method_name '(' formal_parameter',' ')' dimension* ;
method_name = declared_name ;
formal_parameter = annotation* 'final'? type_specifier var_arg_specifier? formal_parameter_name ;
var_arg_specifier = '...' ;
formal_parameter_name = variable_name ;
throws = 'throws' qualified_name+ ;
method_body = block (NL NL) ;
method_body = annotation_default? ';' (NL NL) ;
annotation_default = 'default' expression ;
annotation_default = 'default' array_initializer ;
type_specifier = type_name ;
type_specifier = array_type_specifier ;
array_type_specifier = type_name dimension+ ;
type_name = primitive_type ;
type_name = qualified_name ;
primitive_type = 'boolean' ;
primitive_type = 'char' ;
primitive_type = 'byte' ;
primitive_type = 'short' ;
primitive_type = 'int' ;
primitive_type = 'long' ;
primitive_type = 'float' ;
primitive_type = 'double' ;
primitive_type = 'void' ;
annotation = SPOFF '@' reference '@'? SPON annotation_value_spec? NL ;
annotation_value_spec = '(' annotation_value_list ')' ;
annotation_value_list = single_annotation_value ;
annotation_value_list = keyed_annotation_value',' ;
single_annotation_value = expression ;
single_annotation_value = nested_annotation ;
single_annotation_value = '{' expression_or_nested_annotation',' '}' ;
nested_annotation = annotation ;
expression_or_nested_annotation = expression ;
expression_or_nested_annotation = nested_annotation ;
keyed_annotation_value = id '=' single_annotation_value ;
block = '{' (NL IN) declaration_or_statement* EX '}' ;
declaration_or_statement = declaration ;
declaration_or_statement = statement ;
declaration = local_variable_declaration ;
declaration = class_declaration ;
local_variable_declaration = variable_declaration ;
statement = label_statement ;
statement = empty_statement ;
statement = expression_statement ;
statement = if_statement ;
statement = switch_statement ;
statement = while_statement ;
statement = do_statement ;
statement = for_statement ;
statement = for_in_statement ;
statement = break_statement ;
statement = continue_statement ;
statement = return_statement ;
statement = throw_statement ;
statement = synchronized_statement ;
statement = try_statement ;
statement = assert_statement ;
statement = block ;
empty_statement = ';' NL ;
label_statement = label_name ':' statement ;
label_name = reference ;
expression_statement = expression ';' NL ;
if_statement = 'if' '(' expression ')' statement else_clause? NL ;
else_clause = 'else' statement ;
switch_statement = 'switch' '(' expression ')' switch_block NL ;
switch_block = '{' (IN NL) switch_alternative* EX '}' ;
switch_alternative = switch_label (IN NL) declaration_or_statement* EX ;
switch_label = 'case' constant_expression ':' ;
switch_label = 'default' ':' ;
while_statement = 'while' '(' expression ')' statement NL ;
do_statement = 'do' statement 'while' '(' expression ')' ';' NL ;
for_statement = 'for' '(' for_init for_expression for_update ')' statement NL ;
for_init = expression',' ';' ;
for_init = local_variable_declaration ;
for_expression = expression? ';' ;
for_update = expression',' ;
for_in_statement = 'for' '(' for_in_init ':' expression ')' statement NL ;
for_in_init = modifier* type_specifier variable_name ;
break_statement = 'break' label_name? ';' NL ;
continue_statement = 'continue' label_name? ';' NL ;
return_statement = 'return' expression? ';' NL ;
throw_statement = 'throw' expression ';' NL ;
synchronized_statement = 'synchronized' '(' expression ')' statement NL ;
try_statement = 'try' block catch_clause* finally_clause? NL ;
catch_clause = 'catch' '(' modifier* type_specifier variable_name ')' block ;
finally_clause = 'finally' block ;
assert_statement = 'assert' expression assert_error_code? ';' NL ;
assert_error_code = ':' expression ;
constant_expression = expression ;
expression = assignment_expression ;
assignment_expression = conditional_expression ;
assignment_expression = unary_expression assignment_operator assignment_expression ;
assignment_operator = '=' ;
assignment_operator = '*=' ;
assignment_operator = '/=' ;
assignment_operator = '%=' ;
assignment_operator = '+=' ;
assignment_operator = '-=' ;
assignment_operator = '<<=' ;
assignment_operator = SPOFF '>' '>=' SPON ;
assignment_operator = SPOFF '>' '>' '>=' SPON ;
assignment_operator = '&=' ;
assignment_operator = '^=' ;
assignment_operator = '|=' ;
conditional_expression = conditional_or_expression conditional_choice? ;
conditional_choice = '?' expression ':' conditional_expression ;
conditional_or_expression = conditional_and_expression or_conditional_and_expression* ;
or_conditional_and_expression = '||' conditional_and_expression ;
conditional_and_expression = inclusive_or_expression and_inclusive_or_expression* ;
and_inclusive_or_expression = '&&' inclusive_or_expression ;
inclusive_or_expression = exclusive_or_expression or_exclusive_or_expression* ;
or_exclusive_or_expression = '|' exclusive_or_expression ;
exclusive_or_expression = and_expression or_and_expression* ;
or_and_expression = '^' and_expression ;
and_expression = equality_expression and_equality_expression* ;
and_equality_expression = '&' equality_expression ;
equality_expression = relational_expression equality_op_relational_expression* ;
equality_op_relational_expression = equality_op relational_expression ;
equality_op = '==' ;
equality_op = '!=' ;
relational_expression = shift_expression relational_op_shift_expression* ;
relational_op_shift_expression = relational_op shift_expression ;
relational_op_shift_expression = 'instanceof' type_specifier ;
relational_op = '<' ;
relational_op = '>' ;
relational_op = '<=' ;
relational_op = '>=' ;
shift_expression = additive_expression shift_additive_expression* ;
shift_additive_expression = shift_op additive_expression ;
shift_op = '<<' ;
shift_op = SPOFF '>' '>' SPON ;
shift_op = SPOFF '>' '>' '>' SPON ;
additive_expression = multiplicative_expression add_op_multiplicative_expression* ;
add_op_multiplicative_expression = add_op multiplicative_expression ;
add_op = '+' ;
add_op = '-' ;
multiplicative_expression = unary_expression mult_op_unary_expression* ;
mult_op_unary_expression = mult_op unary_expression ;
mult_op = '*' ;
mult_op = '/' ;
mult_op = '%' ;
unary_expression = pre_inc_dec unary_expression ;
unary_expression = unary_op unary_expression ;
unary_expression = postfix_expression ;
unary_expression = cast_expression ;
pre_inc_dec = '++' ;
pre_inc_dec = '--' ;
unary_op = '+' ;
unary_op = '-' ;
unary_op = '~' ;
unary_op = '!' ;
cast_expression = '(' type_specifier ')' unary_expression ;
postfix_expression = primary post_inc_dec* ;
post_inc_dec = '++' ;
post_inc_dec = '--' ;
subscript = '[' expression ']' ;
primary = literal component* ;
primary = reference ;
primary = '(' expression ')' component* ;
primary = class_instance_creation_expression component* ;
primary = array_creation_expression component* ;
literal = numeric_literal ;
literal = character_literal ;
literal = string_literal ;
literal = boolean_literal ;
literal = null_literal ;
numeric_literal = number ;
character_literal = charlit ;
string_literal = stringlit ;
boolean_literal = 'true' ;
boolean_literal = 'false' ;
null_literal = 'null' ;
class_instance_creation_expression = 'new' class_or_interface_name '(' argument',' ')' class_body? ;
class_or_interface_name = id class_or_interface_component* ;
class_or_interface_component = dot_id ;
class_or_interface_component = generic_argument ;
array_creation_expression = 'new' array_type_specifier array_initializer? ;
dimension = '[' expression? ']' ;
argument = expression ;
argument = type_specifier ;
qualified_name = reference ;
reference = id component* ;
reference = primitive_type component* ;
component = dot_id ;
component = method_argument ;
component = subscript ;
component = generic_argument ;
component = class_instance_creation_expression ;
component = dimension ;
class_instance_declaration = class_instance_creation_expression ;
class_instance_declaration = 'class' ;
method_argument = '(' argument',' ')' ;
dot_id = '.' generic_argument? id ;
dot_id = '.' 'class' ;
dot_id = '.' class_instance_declaration ;
generic_argument = '<' type_argument',' '>' ;
type_argument = type_specifier ;
type_argument = wildcard_type ;
wildcard_type = '?' wildcard_type_bound? ;
wildcard_type = id wildcard_type_bound? ;
wildcard_type_bound = 'extends' type_specifier ;
wildcard_type_bound = 'super' type_specifier ;
generic_parameter = '<' type_parameter',' '>' ;
type_parameter = declared_name type_bound_clause? ;
type_bound_clause = 'extends' type_bound ;
type_bound = type_specifier and_type_spec* ;
and_type_spec = '&' type_specifier ;
