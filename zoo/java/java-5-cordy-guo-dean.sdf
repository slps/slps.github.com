module Main

exports
  sorts
        Program Package-declaration Package-header Package-name Import-declaration Imported-name Package-or-type-name Dot-star Declared-name Type-declaration Class-declaration Class-header Class-body Interface-declaration Interface-header Annot-marker Interface-body Enum-declaration Enum-header Enum-body Enum-element Modifier Extends-clause Implements-clause Class-name Interface-name Class-or-interface-body Class-body-declaration Empty-declaration Member-declaration Method-or-constructor-declaration Instance-initializer Static-initializer Constructor-declaration Constructor-declarator Constructor-body Field-declaration Variable-declaration Variable-declarators Variable-declarator Variable-name Equals-variable-initializer Variable-initializer Array-initializer Method-declaration Method-declarator Method-name Formal-parameter Var-arg-specifier Formal-parameter-name Throws Method-body Annotation-default Type-specifier Array-type-specifier Type-name Primitive-type Annotation Annotation-value-spec Annotation-value-list Single-annotation-value Nested-annotation Expression-or-nested-annotation Keyed-annotation-value Block Declaration-or-statement Declaration Local-variable-declaration Statement Empty-statement Label-statement Label-name Expression-statement If-statement Else-clause Switch-statement Switch-block Switch-alternative Switch-label While-statement Do-statement For-statement For-init For-expression For-update For-in-statement For-in-init Break-statement Continue-statement Return-statement Throw-statement Synchronized-statement Try-statement Catch-clause Finally-clause Assert-statement Assert-error-code Constant-expression Expression Assignment-expression Assignment-operator Conditional-expression Conditional-choice Conditional-or-expression Or-conditional-and-expression Conditional-and-expression And-inclusive-or-expression Inclusive-or-expression Or-exclusive-or-expression Exclusive-or-expression Or-and-expression And-expression And-equality-expression Equality-expression Equality-op-relational-expression Equality-op Relational-expression Relational-op-shift-expression Relational-op Shift-expression Shift-additive-expression Shift-op Additive-expression Add-op-multiplicative-expression Add-op Multiplicative-expression Mult-op-unary-expression Mult-op Unary-expression Pre-inc-dec Unary-op Cast-expression Postfix-expression Post-inc-dec Subscript Primary Literal Numeric-literal Character-literal String-literal Boolean-literal Null-literal Class-instance-creation-expression Class-or-interface-name Class-or-interface-component Array-creation-expression Dimension Argument Qualified-name Reference Component Class-instance-declaration Method-argument Dot-id Generic-argument Type-argument Wildcard-type Wildcard-type-bound Generic-parameter Type-parameter Type-bound-clause Type-bound And-type-spec 
  context-free syntax
        Package-declaration -> Program

        Package-header? Import-declaration* Type-declaration* -> Package-declaration

        Annotation* "package" Package-name ";" (NL NL) -> Package-header

        Qualified-name -> Package-name

        "import" "static"? Imported-name ";" (NL NL) -> Import-declaration
        ";" NL -> Import-declaration

        Package-or-type-name Dot-star? -> Imported-name

        Qualified-name -> Package-or-type-name

        "." "*" -> Dot-star

        Id Generic-parameter? -> Declared-name

        Class-declaration (NL NL) -> Type-declaration
        Interface-declaration (NL NL) -> Type-declaration
        Enum-declaration NL -> Type-declaration

        Class-header Class-body -> Class-declaration

        Modifier* "class" Class-name Extends-clause? Implements-clause? -> Class-header

        Class-or-interface-body -> Class-body

        Interface-header Interface-body -> Interface-declaration

        Modifier* Annot-marker? "interface" Interface-name Extends-clause? Implements-clause? -> Interface-header

        "@" -> Annot-marker

        Class-or-interface-body -> Interface-body

        Enum-header Enum-body -> Enum-declaration

        Modifier* Id? "enum" Declared-name? Implements-clause? -> Enum-header

        "{" IN Enum-element"," ","? Class-body-declaration* EX "}" ";"? (NL NL) -> Enum-body

        NL Id Method-argument? -> Enum-element

        "abstract" -> Modifier
        "final" -> Modifier
        "public" -> Modifier
        "protected" -> Modifier
        "private" -> Modifier
        "static" -> Modifier
        "transient" -> Modifier
        "volatile" -> Modifier
        "native" -> Modifier
        "synchronized" -> Modifier
        "strictfp" -> Modifier
        Annotation -> Modifier

        "extends" Type-name+ -> Extends-clause

        "implements" Qualified-name+ -> Implements-clause

        Declared-name -> Class-name

        Declared-name -> Interface-name

        "{" (NL IN) Class-body-declaration* EX "}" ";"? (NL NL) -> Class-or-interface-body

        Empty-declaration -> Class-body-declaration
        Member-declaration -> Class-body-declaration
        Instance-initializer -> Class-body-declaration
        Static-initializer -> Class-body-declaration
        Field-declaration -> Class-body-declaration

        ";" NL -> Empty-declaration

        Method-or-constructor-declaration -> Member-declaration
        Type-declaration -> Member-declaration

        Method-declaration -> Method-or-constructor-declaration
        Constructor-declaration -> Method-or-constructor-declaration

        NL Block (NL NL) -> Instance-initializer

        NL "static" Block (NL NL) -> Static-initializer

        NL Modifier* Generic-parameter? Constructor-declarator Throws? Constructor-body (NL NL) -> Constructor-declaration

        Class-name "(" Formal-parameter"," ")" -> Constructor-declarator

        Block NL -> Constructor-body

        Variable-declaration -> Field-declaration

        Modifier* Type-specifier Variable-declarators ";" NL -> Variable-declaration

        Variable-declarator+ -> Variable-declarators

        Variable-name Equals-variable-initializer? -> Variable-declarator

        Declared-name Dimension* -> Variable-name

        "=" Variable-initializer -> Equals-variable-initializer

        Expression -> Variable-initializer
        Array-initializer -> Variable-initializer

        "{" Variable-initializer"," ","? "}" -> Array-initializer

        NL Modifier* Generic-parameter? Type-specifier Method-declarator Throws? Method-body -> Method-declaration

        Method-name "(" Formal-parameter"," ")" Dimension* -> Method-declarator

        Declared-name -> Method-name

        Annotation* "final"? Type-specifier Var-arg-specifier? Formal-parameter-name -> Formal-parameter

        "..." -> Var-arg-specifier

        Variable-name -> Formal-parameter-name

        "throws" Qualified-name+ -> Throws

        Block (NL NL) -> Method-body
        Annotation-default? ";" (NL NL) -> Method-body

        "default" Expression -> Annotation-default
        "default" Array-initializer -> Annotation-default

        Type-name -> Type-specifier
        Array-type-specifier -> Type-specifier

        Type-name Dimension+ -> Array-type-specifier

        Primitive-type -> Type-name
        Qualified-name -> Type-name

        "boolean" -> Primitive-type
        "char" -> Primitive-type
        "byte" -> Primitive-type
        "short" -> Primitive-type
        "int" -> Primitive-type
        "long" -> Primitive-type
        "float" -> Primitive-type
        "double" -> Primitive-type
        "void" -> Primitive-type

        SPOFF "@" Reference "@"? SPON Annotation-value-spec? NL -> Annotation

        "(" Annotation-value-list ")" -> Annotation-value-spec

        Single-annotation-value -> Annotation-value-list
        Keyed-annotation-value"," -> Annotation-value-list

        Expression -> Single-annotation-value
        Nested-annotation -> Single-annotation-value
        "{" Expression-or-nested-annotation"," "}" -> Single-annotation-value

        Annotation -> Nested-annotation

        Expression -> Expression-or-nested-annotation
        Nested-annotation -> Expression-or-nested-annotation

        Id "=" Single-annotation-value -> Keyed-annotation-value

        "{" (NL IN) Declaration-or-statement* EX "}" -> Block

        Declaration -> Declaration-or-statement
        Statement -> Declaration-or-statement

        Local-variable-declaration -> Declaration
        Class-declaration -> Declaration

        Variable-declaration -> Local-variable-declaration

        Label-statement -> Statement
        Empty-statement -> Statement
        Expression-statement -> Statement
        If-statement -> Statement
        Switch-statement -> Statement
        While-statement -> Statement
        Do-statement -> Statement
        For-statement -> Statement
        For-in-statement -> Statement
        Break-statement -> Statement
        Continue-statement -> Statement
        Return-statement -> Statement
        Throw-statement -> Statement
        Synchronized-statement -> Statement
        Try-statement -> Statement
        Assert-statement -> Statement
        Block -> Statement

        ";" NL -> Empty-statement

        Label-name ":" Statement -> Label-statement

        Reference -> Label-name

        Expression ";" NL -> Expression-statement

        "if" "(" Expression ")" Statement Else-clause? NL -> If-statement

        "else" Statement -> Else-clause

        "switch" "(" Expression ")" Switch-block NL -> Switch-statement

        "{" (IN NL) Switch-alternative* EX "}" -> Switch-block

        Switch-label (IN NL) Declaration-or-statement* EX -> Switch-alternative

        "case" Constant-expression ":" -> Switch-label
        "default" ":" -> Switch-label

        "while" "(" Expression ")" Statement NL -> While-statement

        "do" Statement "while" "(" Expression ")" ";" NL -> Do-statement

        "for" "(" For-init For-expression For-update ")" Statement NL -> For-statement

        Expression"," ";" -> For-init
        Local-variable-declaration -> For-init

        Expression? ";" -> For-expression

        Expression"," -> For-update

        "for" "(" For-in-init ":" Expression ")" Statement NL -> For-in-statement

        Modifier* Type-specifier Variable-name -> For-in-init

        "break" Label-name? ";" NL -> Break-statement

        "continue" Label-name? ";" NL -> Continue-statement

        "return" Expression? ";" NL -> Return-statement

        "throw" Expression ";" NL -> Throw-statement

        "synchronized" "(" Expression ")" Statement NL -> Synchronized-statement

        "try" Block Catch-clause* Finally-clause? NL -> Try-statement

        "catch" "(" Modifier* Type-specifier Variable-name ")" Block -> Catch-clause

        "finally" Block -> Finally-clause

        "assert" Expression Assert-error-code? ";" NL -> Assert-statement

        ":" Expression -> Assert-error-code

        Expression -> Constant-expression

        Assignment-expression -> Expression

        Conditional-expression -> Assignment-expression
        Unary-expression Assignment-operator Assignment-expression -> Assignment-expression

        "=" -> Assignment-operator
        "*=" -> Assignment-operator
        "/=" -> Assignment-operator
        "%=" -> Assignment-operator
        "+=" -> Assignment-operator
        "-=" -> Assignment-operator
        "<<=" -> Assignment-operator
        SPOFF ">" ">=" SPON -> Assignment-operator
        SPOFF ">" ">" ">=" SPON -> Assignment-operator
        "&=" -> Assignment-operator
        "^=" -> Assignment-operator
        "|=" -> Assignment-operator

        Conditional-or-expression Conditional-choice? -> Conditional-expression

        "?" Expression ":" Conditional-expression -> Conditional-choice

        Conditional-and-expression Or-conditional-and-expression* -> Conditional-or-expression

        "||" Conditional-and-expression -> Or-conditional-and-expression

        Inclusive-or-expression And-inclusive-or-expression* -> Conditional-and-expression

        "&&" Inclusive-or-expression -> And-inclusive-or-expression

        Exclusive-or-expression Or-exclusive-or-expression* -> Inclusive-or-expression

        "|" Exclusive-or-expression -> Or-exclusive-or-expression

        And-expression Or-and-expression* -> Exclusive-or-expression

        "^" And-expression -> Or-and-expression

        Equality-expression And-equality-expression* -> And-expression

        "&" Equality-expression -> And-equality-expression

        Relational-expression Equality-op-relational-expression* -> Equality-expression

        Equality-op Relational-expression -> Equality-op-relational-expression

        "==" -> Equality-op
        "!=" -> Equality-op

        Shift-expression Relational-op-shift-expression* -> Relational-expression

        Relational-op Shift-expression -> Relational-op-shift-expression
        "instanceof" Type-specifier -> Relational-op-shift-expression

        "<" -> Relational-op
        ">" -> Relational-op
        "<=" -> Relational-op
        ">=" -> Relational-op

        Additive-expression Shift-additive-expression* -> Shift-expression

        Shift-op Additive-expression -> Shift-additive-expression

        "<<" -> Shift-op
        SPOFF ">" ">" SPON -> Shift-op
        SPOFF ">" ">" ">" SPON -> Shift-op

        Multiplicative-expression Add-op-multiplicative-expression* -> Additive-expression

        Add-op Multiplicative-expression -> Add-op-multiplicative-expression

        "+" -> Add-op
        "-" -> Add-op

        Unary-expression Mult-op-unary-expression* -> Multiplicative-expression

        Mult-op Unary-expression -> Mult-op-unary-expression

        "*" -> Mult-op
        "/" -> Mult-op
        "%" -> Mult-op

        Pre-inc-dec Unary-expression -> Unary-expression
        Unary-op Unary-expression -> Unary-expression
        Postfix-expression -> Unary-expression
        Cast-expression -> Unary-expression

        "++" -> Pre-inc-dec
        "--" -> Pre-inc-dec

        "+" -> Unary-op
        "-" -> Unary-op
        "~" -> Unary-op
        "!" -> Unary-op

        "(" Type-specifier ")" Unary-expression -> Cast-expression

        Primary Post-inc-dec* -> Postfix-expression

        "++" -> Post-inc-dec
        "--" -> Post-inc-dec

        "[" Expression "]" -> Subscript

        Literal Component* -> Primary
        Reference -> Primary
        "(" Expression ")" Component* -> Primary
        Class-instance-creation-expression Component* -> Primary
        Array-creation-expression Component* -> Primary

        Numeric-literal -> Literal
        Character-literal -> Literal
        String-literal -> Literal
        Boolean-literal -> Literal
        Null-literal -> Literal

        Number -> Numeric-literal

        Charlit -> Character-literal

        Stringlit -> String-literal

        "true" -> Boolean-literal
        "false" -> Boolean-literal

        "null" -> Null-literal

        "new" Class-or-interface-name "(" Argument"," ")" Class-body? -> Class-instance-creation-expression

        Id Class-or-interface-component* -> Class-or-interface-name

        Dot-id -> Class-or-interface-component
        Generic-argument -> Class-or-interface-component

        "new" Array-type-specifier Array-initializer? -> Array-creation-expression

        "[" Expression? "]" -> Dimension

        Expression -> Argument
        Type-specifier -> Argument

        Reference -> Qualified-name

        Id Component* -> Reference
        Primitive-type Component* -> Reference

        Dot-id -> Component
        Method-argument -> Component
        Subscript -> Component
        Generic-argument -> Component
        Class-instance-creation-expression -> Component
        Dimension -> Component

        Class-instance-creation-expression -> Class-instance-declaration
        "class" -> Class-instance-declaration

        "(" Argument"," ")" -> Method-argument

        "." Generic-argument? Id -> Dot-id
        "." "class" -> Dot-id
        "." Class-instance-declaration -> Dot-id

        "<" Type-argument"," ">" -> Generic-argument

        Type-specifier -> Type-argument
        Wildcard-type -> Type-argument

        "?" Wildcard-type-bound? -> Wildcard-type
        Id Wildcard-type-bound? -> Wildcard-type

        "extends" Type-specifier -> Wildcard-type-bound
        "super" Type-specifier -> Wildcard-type-bound

        "<" Type-parameter"," ">" -> Generic-parameter

        Declared-name Type-bound-clause? -> Type-parameter

        "extends" Type-bound -> Type-bound-clause

        Type-specifier And-type-spec* -> Type-bound

        "&" Type-specifier -> And-type-spec
