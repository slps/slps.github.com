AbstractTypeDeclaration = AnnotationTypeDeclaration ;
AbstractTypeDeclaration = EnumDeclaration ;
AbstractTypeDeclaration = TypeDeclaration ;
Annotation = type::NamedElementRef values::AnnotationMemberValuePair+ ;
AnnotationMemberValuePair = member::NamedElementRef value::Expression ;
AnnotationTypeDeclaration = originalFileContent::String package::PackageDeclaration bodyDeclarations::BodyDeclaration+ superInterfaces::NamedElementRef+ commentsAfterBody::Comment+ imports::ImportDeclaration+ commentsBeforeBody::Comment+ ;
AnnotationTypeMemberDeclaration = type::NamedElementRef default::Expression ;
AnonymousClassDeclaration = bodyDeclarations::BodyDeclaration+ ;
ArrayAccess = index::Expression array::Expression ;
ArrayCreation = dimensions::Expression+ initializer::ArrayInitializer type::NamedElementRef ;
ArrayInitializer = expressions::Expression+ ;
ArrayLengthAccess = array::Expression ;
AssertStatement = message::Expression expression::Expression ;
Assignment = operator::String rightHandSide::Expression leftHandSide::Expression ;
ASTNode = AnnotationMemberValuePair ;
ASTNode = AnonymousClassDeclaration ;
ASTNode = BodyDeclaration ;
ASTNode = CatchClause ;
ASTNode = Comment ;
ASTNode = Expression ;
ASTNode = ImportDeclaration ;
ASTNode = MemberRef ;
ASTNode = MethodRef ;
ASTNode = MethodRefParameter ;
ASTNode = Statement ;
ASTNode = TagElement ;
ASTNode = TextElement ;
ASTNode = PackageDeclaration ;
ASTNode = ParameterizedType ;
ASTNode = PrimitiveType ;
ASTNode = SingleVariableDeclaration ;
ASTNode = TypeParameter ;
ASTNode = UnresolvedItem ;
ASTNode = WildCardType ;
BodyDeclaration = Initializer ;
BodyDeclaration = EnumConstantDeclaration ;
BodyDeclaration = FieldDeclaration ;
BodyDeclaration = AbstractTypeDeclaration ;
BodyDeclaration = AnnotationTypeMemberDeclaration ;
BodyDeclaration = MethodDeclaration ;
Block = statements::Statement+ ;
BlockComment = content::String isEnclosedByParent::Boolean isPrefixOfParent::Boolean ;
BreakStatement = label::NamedElementRef ;
CastExpression = type::NamedElementRef expression::Expression ;
CatchClause = exception::SingleVariableDeclaration body::Block ;
ClassInstanceCreation = arguments::Expression+ type::NamedElementRef expression::Expression anonymousClassDeclaration::AnonymousClassDeclaration ;
Comment = BlockComment ;
Comment = Javadoc ;
Comment = LineComment ;
ConditionalExpression = elseExpression::Expression thenExpression::Expression expression::Expression ;
ContinueStatement = label::NamedElementRef ;
ConstructorInvocation = arguments::Expression+ ;
DoStatement = expression::Expression body::Statement ;
EmptyStatement =  ;
EnhancedForStatement = parameter::SingleVariableDeclaration expression::Expression body::Statement ;
EnumConstantDeclaration = arguments::Expression+ anonymousClassDeclaration::AnonymousClassDeclaration ;
EnumDeclaration = enumConstants::EnumConstantDeclaration+ ;
Expression = Annotation ;
Expression = ArrayAccess ;
Expression = ArrayCreation ;
Expression = ArrayInitializer ;
Expression = ArrayLengthAccess ;
Expression = Assignment ;
Expression = CastExpression ;
Expression = ClassInstanceCreation ;
Expression = ConditionalExpression ;
Expression = FieldAccess ;
Expression = InfixExpression ;
Expression = InstanceofExpression ;
Expression = MethodInvocation ;
Expression = NamedElementRef ;
Expression = ParenthesizedExpression ;
Expression = PostfixExpression ;
Expression = PrefixExpression ;
Expression = SuperFieldAccess ;
Expression = SuperMethodInvocation ;
Expression = ThisExpression ;
Expression = TypeLiteral ;
Expression = VariableDeclarationExpression ;
ExpressionStatement = expression::Expression ;
FieldAccess = field::NamedElementRef expression::Expression ;
FieldDeclaration = type::NamedElementRef ;
ForStatement = body::Statement expression::Expression initializers::Expression+ updaters::Expression+ ;
InfixExpression = operator::String extendedOperands::Expression+ rightOperand::Expression leftOperand::Expression ;
IfStatement = expression::Expression elseStatement::Statement thenStatement::Statement ;
ImportDeclaration = static::Boolean importedElement::NamedElementRef ;
Initializer = body::Block ;
InstanceofExpression = leftOperand::Expression rightOperand::NamedElementRef ;
Javadoc = tags::TagElement+ ;
LabeledStatement = body::Statement ;
LineComment = content::String isEnclosedByParent::Boolean isPrefixOfParent::Boolean ;
MemberRef = qualifier::NamedElementRef member::NamedElementRef ;
MethodDeclaration = extraArrayDimensions::Integer constructor::Boolean varargs::Boolean body::Block parameters::SingleVariableDeclaration+ typeParameters::TypeParameter+ thrownExceptions::NamedElementRef+ returnType::NamedElementRef ;
MethodInvocation = method::NamedElementRef arguments::Expression+ expression::Expression ;
MethodRef = qualifier::NamedElementRef parameters::MethodRefParameter+ method::NamedElementRef ;
MethodRefParameter = name::String isVarargs::Boolean type::NamedElementRef ;
Model = name::String ownedElements::PackageDeclaration+ orphanTypes::OrphanType+ ;
MultipleValuedNamedElement = FieldDeclaration ;
NamedElement = OrphanType ;
NamedElement = ValuedNamedElement ;
NamedElement = AbstractTypeDeclaration ;
NamedElement = AnnotationTypeMemberDeclaration ;
NamedElement = MethodDeclaration ;
NamedElement = UnresolvedItem ;
NamedElement = EnumConstantDeclaration ;
NamedElement = LabeledStatement ;
NamedElement = PackageDeclaration ;
NamedElement = TypeParameter ;
NamedElementRef = extraArrayDimensions::Integer element::NamedElement qualifier::NamedElementRef ;
OrphanType = WildCardType ;
OrphanType = ParameterizedType ;
OrphanType = PrimitiveType ;
OrphanType = name::String proxy::Boolean ;
PackageDeclaration = model::Model ownedElements::AbstractTypeDeclaration+ ;
ParameterizedType = typeArguments::NamedElementRef+ type::NamedElementRef ;
ParenthesizedExpression = expression::Expression ;
PostfixExpression = operator::String operand::Expression ;
PrefixExpression = operator::String operand::Expression ;
PrimitiveType = comments::Comment+ ;
ReturnStatement = expression::Expression ;
ThrowStatement = expression::Expression ;
SingleVariableDeclaration = modifiers::String isVarargs::Boolean type::NamedElementRef ;
Statement = AssertStatement ;
Statement = Block ;
Statement = BreakStatement ;
Statement = ContinueStatement ;
Statement = ConstructorInvocation ;
Statement = DoStatement ;
Statement = EmptyStatement ;
Statement = EnhancedForStatement ;
Statement = ExpressionStatement ;
Statement = ForStatement ;
Statement = IfStatement ;
Statement = ReturnStatement ;
Statement = ThrowStatement ;
Statement = SuperConstructorInvocation ;
Statement = SwitchCase ;
Statement = SwitchStatement ;
Statement = SynchronizedStatement ;
Statement = TryStatement ;
Statement = TypeDeclarationStatement ;
Statement = WhileStatement ;
Statement = LabeledStatement ;
Statement = VariableDeclarationStatement ;
SuperConstructorInvocation = arguments::Expression+ expression::Expression ;
SuperFieldAccess = qualifier::NamedElementRef field::NamedElementRef ;
SuperMethodInvocation = arguments::Expression+ qualifier::NamedElementRef method::NamedElementRef ;
SwitchCase = expressionInitialized::Boolean expression::Expression ;
SwitchStatement = statements::Statement+ expression::Expression ;
SynchronizedStatement = body::Block expression::Expression ;
TagElement = tagName::String fragments::ASTNode+ ;
TextElement = text::String ;
ThisExpression = qualifier::NamedElementRef ;
TryStatement = finally::Block body::Block catchClauses::CatchClause+ ;
TypeDeclaration = isInterface::Boolean typeParameters::TypeParameter+ superclass::NamedElementRef ;
TypeDeclarationStatement = declaration::AbstractTypeDeclaration ;
TypeLiteral = type::NamedElementRef ;
TypeParameter = bounds::NamedElementRef+ ;
UnresolvedItem = name::String proxy::Boolean comments::Comment+ ;
ValuedNamedElement = MultipleValuedNamedElement ;
ValuedNamedElement = SingleVariableDeclaration ;
VariableDeclarationExpression = modifiers::String type::NamedElementRef ;
VariableDeclarationStatement = modifiers::String type::NamedElementRef ;
WildCardType = isUpperBound::Boolean bound::NamedElementRef ;
WhileStatement = expression::Expression body::Statement ;
String = STR ;
Boolean = 'true' ;
Boolean = 'false' ;
Integer = INT ;
