module Main

exports
  sorts
        LocalVarDec TypeParams Literal ClassMod ClassDecHead ClassDec SwitchGroup ClassBodyDec FloatType ClassMemberDec ConstantMod ConstantDec SwitchBlock CondMid WildcardBound EnumDecHead PackageOrTypeName InterfaceDecHead IntType VarInit EnumBodyDecs ClassType ExtendsInterfaces StaticInit FormalParam EnumConstArgs LocalVarDecStm CompilationUnit EnumConst NumType MethodDecHead Anno FieldDec FieldMod ArraySubscript FloatLiteral ConstrBody PackageName FieldAccess ConstrInv IntLiteral InterfaceMemberDec ElemValPair CatchClause ArrayInit VarDecId Modifier ElemVal ConstrDec ConstrMod InterfaceType PackageDec ArrayAccess ImportDec ArrayBaseType TypeName SwitchLabel ConstrHead Stm NullLiteral ExceptionType ResultType Expr ArrayType ClassBody TypeDecSpec PrimType EnumDec ActualTypeArg MethodName InterfaceDec InterfaceMod ClassLiteral StringLiteral AbstractMethodMod AbstractMethodDec Id TypeBound AnnoElemDec BoolLiteral MethodBody ExprName DefaultVal MethodDec AmbName MethodMod ArrayCreationExpr RefType TypeDec TypeArgs LHS AnnoDecHead TypeParam MethodSpec Type Super CharLiteral InstanceInit EnumBody Throws Block TypeVar TypeVarId Dim BlockStm DimExpr Interfaces VarMod VarDec ClassOrInterfaceType 
  context-free syntax
        localVarDec(Type VarDec",") -> LocalVarDec

        typeParams("<" TypeParam"," ">") -> TypeParams

        CharLiteral -> Literal

        BoolLiteral -> Literal

        ClassLiteral -> Literal

        FloatLiteral -> Literal

        StringLiteral -> Literal

        NullLiteral -> Literal

        IntLiteral -> Literal

        "abstract" -> ClassMod

        "static" -> ClassMod

        "public" -> ClassMod

        "strictfp" -> ClassMod

        "final" -> ClassMod

        "private" -> ClassMod

        "protected" -> ClassMod

        classDecHead("class" Id TypeParams? Super? Interfaces?) -> ClassDecHead

        EnumDec -> ClassDec

        classDec(ClassDecHead ClassBody) -> ClassDec

        switchGroup(SwitchLabel+ BlockStm+) -> SwitchGroup

        ClassMemberDec -> ClassBodyDec

        StaticInit -> ClassBodyDec

        ConstrDec -> ClassBodyDec

        InstanceInit -> ClassBodyDec

        double"double" -> FloatType

        float"float" -> FloatType

        ClassDec -> ClassMemberDec

        MethodDec -> ClassMemberDec

        FieldDec -> ClassMemberDec

        semicolon";" -> ClassMemberDec

        InterfaceDec -> ClassMemberDec

        "static" -> ConstantMod

        "public" -> ConstantMod

        "final" -> ConstantMod

        constantDec(Type VarDec"," ";") -> ConstantDec

        switchBlock("{" SwitchGroup* SwitchLabel* "}") -> SwitchBlock

        "?" Expr ":" -> CondMid

        wildcardUpperBound("extends" RefType) -> WildcardBound

        wildcardLowerBound("super" RefType) -> WildcardBound

        enumDecHead("enum" Id Interfaces?) -> EnumDecHead

        packageOrTypeNameId -> PackageOrTypeName

        packageOrTypeName(PackageOrTypeName "." Id) -> PackageOrTypeName

        interfaceDecHead("interface" Id TypeParams? ExtendsInterfaces?) -> InterfaceDecHead

        int"int" -> IntType

        byte"byte" -> IntType

        long"long" -> IntType

        short"short" -> IntType

        char"char" -> IntType

        Expr -> VarInit

        ArrayInit -> VarInit

        enumBodyDecs(";" ClassBodyDec*) -> EnumBodyDecs

        classType(TypeDecSpec TypeArgs?) -> ClassType

        extendsInterfaces("extends" InterfaceType",") -> ExtendsInterfaces

        staticInit("static" Block) -> StaticInit

        varArityParam(Type "..." VarDecId) -> FormalParam

        param(Type VarDecId) -> FormalParam

        "(" Expr"," ")" -> EnumConstArgs

        localVarDecStm(LocalVarDec ";") -> LocalVarDecStm

        compilationUnit(PackageDec? ImportDec* TypeDec*) -> CompilationUnit

        enumConst(Id EnumConstArgs? ClassBody?) -> EnumConst

        FloatType -> NumType

        IntType -> NumType

        deprMethodDecHead(TypeParams? ResultType Id "(" FormalParam"," ")" Dim+ Throws?) -> MethodDecHead

        methodDecHead(TypeParams? ResultType Id "(" FormalParam"," ")" Throws?) -> MethodDecHead

        singleElemAnno("@" TypeName "(" ")") -> Anno

        anno("@" TypeName "(" ElemValPair"," ")") -> Anno

        markerAnno("@" TypeName) -> Anno

        fieldDec(Type VarDec"," ";") -> FieldDec

        "public" -> FieldMod

        "static" -> FieldMod

        "transient" -> FieldMod

        "final" -> FieldMod

        "volatile" -> FieldMod

        "private" -> FieldMod

        "protected" -> FieldMod

        "[" Expr "]" -> ArraySubscript

        float -> FloatLiteral

        constrBody("{" ConstrInv? BlockStm* "}") -> ConstrBody

        packageNameId"." -> PackageName

        qSuperField(TypeName "." "super" "." Id) -> FieldAccess

        field("." Id) -> FieldAccess

        superField("super" "." Id) -> FieldAccess

        qSuperConstrInv(Expr "." TypeArgs? "super" "(" Expr"," ")" ";") -> ConstrInv

        superConstrInv(TypeArgs? "super" "(" Expr"," ")" ";") -> ConstrInv

        altConstrInv(TypeArgs? "this" "(" Expr"," ")" ";") -> ConstrInv

        octa -> IntLiteral

        hexa -> IntLiteral

        deci -> IntLiteral

        semicolon";" -> InterfaceMemberDec

        InterfaceDec -> InterfaceMemberDec

        AbstractMethodDec -> InterfaceMemberDec

        ClassDec -> InterfaceMemberDec

        ConstantDec -> InterfaceMemberDec

        elemValPair(Id "=") -> ElemValPair

        catch("catch" "(" FormalParam ")" Block) -> CatchClause

        arrayInit("{" VarInit"," "," "}") -> ArrayInit

        arrayInit("{" VarInit"," "}") -> ArrayInit

        Id -> VarDecId

        arrayVarDecId(Id Dim+) -> VarDecId

        "protected" -> Modifier

        "private" -> Modifier

        "volatile" -> Modifier

        "synchronized" -> Modifier

        "final" -> Modifier

        "strictfp" -> Modifier

        "transient" -> Modifier

        "abstract" -> Modifier

        "native" -> Modifier

        "static" -> Modifier

        "public" -> Modifier

        elemValArrayInit("{" ElemVal"," "}") -> ElemVal

        Expr -> ElemVal

        Anno -> ElemVal

        elemValArrayInit("{" ElemVal"," "," "}") -> ElemVal

        constrDec(ConstrHead ConstrBody) -> ConstrDec

        "protected" -> ConstrMod

        "private" -> ConstrMod

        "public" -> ConstrMod

        interfaceType(TypeDecSpec TypeArgs?) -> InterfaceType

        packageDec(Anno* "package" PackageName ";") -> PackageDec

        arrayAccessArraySubscript -> ArrayAccess

        typeImportOnDemandDec("import" PackageName "." "*" ";") -> ImportDec

        typeImportDec("import" TypeName ";") -> ImportDec

        staticImportDec("import" "static" TypeName "." Id ";") -> ImportDec

        staticImportOnDemandDec("import" "static" TypeName "." "*" ";") -> ImportDec

        TypeName -> ArrayBaseType

        PrimType -> ArrayBaseType

        unboundWld(TypeName "<" "?" ">") -> ArrayBaseType

        typeName(PackageOrTypeName "." Id) -> TypeName

        typeNameId -> TypeName

        case("case" Expr ":") -> SwitchLabel

        default("default" ":") -> SwitchLabel

        constrDecHead(TypeParams? Id "(" FormalParam"," ")" Throws?) -> ConstrHead

        synchronized("synchronized" "(" Expr ")" Block) -> Stm

        exprStm(Expr ";") -> Stm

        for("for" "(" Expr"," ";" Expr? ";" Expr"," ")" Stm) -> Stm

        for("for" "(" LocalVarDec ";" Expr? ";" Expr"," ")" Stm) -> Stm

        Block -> Stm

        continue("continue" Id? ";") -> Stm

        try("try" Block CatchClause+) -> Stm

        throw("throw" Expr ";") -> Stm

        switch("switch" "(" Expr ")" SwitchBlock) -> Stm

        if("if" "(" Expr ")" Stm) -> Stm

        break("break" Id? ";") -> Stm

        empty";" -> Stm

        labeled(Id ":" Stm) -> Stm

        assertStm("assert" Expr ":" Expr ";") -> Stm

        forEach("for" "(" FormalParam ":" Expr ")" Stm) -> Stm

        assertStm("assert" Expr ";") -> Stm

        try("try" Block CatchClause* "finally" Block) -> Stm

        return("return" Expr? ";") -> Stm

        doWhile("do" Stm "while" "(" Expr ")" ";") -> Stm

        while("while" "(" Expr ")" Stm) -> Stm

        if("if" "(" Expr ")" Stm "else" Stm) -> Stm

        null"null" -> NullLiteral

        ClassType -> ExceptionType

        Type -> ResultType

        void"void" -> ResultType

        postDecr(Expr "--") -> Expr

        postIncr(Expr "++") -> Expr

        castPrim("(" PrimType ")" Expr) -> Expr

        castRef("(" RefType ")" Expr) -> Expr

        minusExpr -> Expr

        preIncr("++" Expr) -> Expr

        plusExpr -> Expr

        preDecr("--" Expr) -> Expr

        this"this" -> Expr

        mul(Expr "*" Expr) -> Expr

        div(Expr Expr) -> Expr

        remain(Expr "%" Expr) -> Expr

        qThis(TypeName "." "this") -> Expr

        complement("~" Expr) -> Expr

        not("!" Expr) -> Expr

        plus(Expr Expr) -> Expr

        minus(Expr Expr) -> Expr

        uRightShift(Expr ">>>" Expr) -> Expr

        rightShift(Expr ">>" Expr) -> Expr

        leftShift(Expr "<<" Expr) -> Expr

        ltEq(Expr "<=" Expr) -> Expr

        lt(Expr "<" Expr) -> Expr

        gtEq(Expr ">=" Expr) -> Expr

        instanceOf(Expr "instanceof" RefType) -> Expr

        gt(Expr ">" Expr) -> Expr

        eq(Expr "==" Expr) -> Expr

        notEq(Expr "!=" Expr) -> Expr

        and(Expr "&" Expr) -> Expr

        excOr(Expr "^" Expr) -> Expr

        or(Expr "|" Expr) -> Expr

        lazyAnd(Expr "&&" Expr) -> Expr

        lazyOr(Expr "||" Expr) -> Expr

        cond(Expr CondMid Expr) -> Expr

        assignMinus(LHS "-=" Expr) -> Expr

        assignExcOr(LHS "^=" Expr) -> Expr

        assignPlus(LHS "+=" Expr) -> Expr

        assignURightShift(LHS ">>>=" Expr) -> Expr

        assignAnd(LHS "&=" Expr) -> Expr

        assignDiv(LHS "/=" Expr) -> Expr

        assignMul(LHS "*=" Expr) -> Expr

        assignRemain(LHS "%=" Expr) -> Expr

        assignLeftShift(LHS "<<=" Expr) -> Expr

        assignRightShift(LHS ">>=" Expr) -> Expr

        assignOr(LHS "|=" Expr) -> Expr

        assign(LHS "=" Expr) -> Expr

        qNewInstance(Expr "." "new" TypeArgs? Id TypeArgs? "(" Expr"," ")" ClassBody?) -> Expr

        litLiteral -> Expr

        newInstance("new" TypeArgs? ClassOrInterfaceType "(" Expr"," ")" ClassBody?) -> Expr

        exprNameExprName -> Expr

        ArrayCreationExpr -> Expr

        "(" Expr ")" -> Expr

         -> Expr

        invoke(MethodSpec "(" Expr"," ")") -> Expr

        arrayType(Type "[" "]") -> ArrayType

        classBody("{" ClassBodyDec* "}") -> ClassBody

        TypeName -> TypeDecSpec

        member(TypeDecSpec TypeArgs "." Id) -> TypeDecSpec

        NumType -> PrimType

        boolean"boolean" -> PrimType

        enumDec(EnumDecHead EnumBody) -> EnumDec

        Type -> ActualTypeArg

        wildcard("?" WildcardBound?) -> ActualTypeArg

        methodName(AmbName "." Id) -> MethodName

        methodNameId -> MethodName

        InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec

        AnnoDecHead "{" AnnoElemDec* "}" -> InterfaceDec

        "public" -> InterfaceMod

        "static" -> InterfaceMod

        "abstract" -> InterfaceMod

        "strictfp" -> InterfaceMod

        "protected" -> InterfaceMod

        "private" -> InterfaceMod

        voidClass("void" "." "class") -> ClassLiteral

        class(Type "." "class") -> ClassLiteral

         -> StringLiteral

        "abstract" -> AbstractMethodMod

        "public" -> AbstractMethodMod

        abstractMethodDec(TypeParams? ResultType Id "(" FormalParam"," ")" Throws? ";") -> AbstractMethodDec

        deprAbstractMethodDec(TypeParams? ResultType Id "(" FormalParam"," ")" Dim+ Throws? ";") -> AbstractMethodDec

        id -> Id

        typeBound("extends" ClassOrInterfaceType"&") -> TypeBound

        EnumDec -> AnnoElemDec

        semicolon";" -> AnnoElemDec

        ClassDec -> AnnoElemDec

        ConstantDec -> AnnoElemDec

        InterfaceDec -> AnnoElemDec

        annoMethodDec(AbstractMethodMod* Type Id "(" ")" DefaultVal? ";") -> AnnoElemDec

        false"false" -> BoolLiteral

        true"true" -> BoolLiteral

        noMethodBody";" -> MethodBody

        Block -> MethodBody

        exprNameId -> ExprName

        exprName(AmbName "." Id) -> ExprName

        defaultVal"default" -> DefaultVal

        methodDec(MethodDecHead MethodBody) -> MethodDec

        ambName(AmbName "." Id) -> AmbName

        ambNameId -> AmbName

        "final" -> MethodMod

        "strictfp" -> MethodMod

        "synchronized" -> MethodMod

        "protected" -> MethodMod

        "private" -> MethodMod

        "static" -> MethodMod

        "public" -> MethodMod

        "abstract" -> MethodMod

        "native" -> MethodMod

        newArray("new" ArrayBaseType DimExpr+) -> ArrayCreationExpr

        newArray("new" ArrayBaseType ArrayInit) -> ArrayCreationExpr

        ClassOrInterfaceType -> RefType

        ArrayType -> RefType

        InterfaceDec -> TypeDec

        ClassDec -> TypeDec

        semicolon";" -> TypeDec

        typeArgs("<" ActualTypeArg"," ">") -> TypeArgs

        ExprName -> LHS

         -> LHS

        annoDecHead("@" "interface" Id) -> AnnoDecHead

        typeParam(TypeVarId TypeBound?) -> TypeParam

        methodMethodName -> MethodSpec

        superMethod("super" "." TypeArgs? Id) -> MethodSpec

        genericMethod(AmbName "." TypeArgs Id) -> MethodSpec

        qSuperMethod(TypeName "." "super" "." TypeArgs? Id) -> MethodSpec

        method("." TypeArgs? Id) -> MethodSpec

        RefType -> Type

        PrimType -> Type

        superDec("extends" ClassType) -> Super

         -> CharLiteral

        instanceInitBlock -> InstanceInit

        enumBody("{" EnumConst"," EnumBodyDecs? "}") -> EnumBody

        enumBody("{" EnumConst"," "," EnumBodyDecs? "}") -> EnumBody

        throwsDec("throws" ExceptionType",") -> Throws

        block("{" BlockStm* "}") -> Block

        typeVarTypeVarId -> TypeVar

        Id -> TypeVarId

        dim("[" "]") -> Dim

        Stm -> BlockStm

        classDecStmClassDec -> BlockStm

        LocalVarDecStm -> BlockStm

        dim("[" Expr "]") -> DimExpr

        implementsDec("implements" InterfaceType",") -> Interfaces

        "final" -> VarMod

        varDec(VarDecId "=" VarInit) -> VarDec

        varDecVarDecId -> VarDec

        classOrInterfaceType(TypeDecSpec TypeArgs?) -> ClassOrInterfaceType
