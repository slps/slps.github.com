module Main

exports
 context-free start-symbols compilationUnit
  sorts
        CompilationUnit PackageDefinition Annotations Annotation AT Identifier IDENT DOT AnnotationInit LPAREN AnnotationMemberInit ASSIGN AnnotationMemberValue ConditionalExpression LogicalOrExpression LogicalAndExpression InclusiveOrExpression ExclusiveOrExpression AndExpression EqualityExpression RelationalExpression ShiftExpression AdditiveExpression MultiplicativeExpression UnaryExpression INC DEC MINUS PLUS UnaryExpressionNotPlusMinus BNOT LNOT BuiltInTypeSpec BuiltInType LBRACK RBRACK RPAREN ClassTypeSpec ClassOrInterfaceType TypeArguments LT TypeArgument QUESTION ReferenceTypeSpec ArrayTypeSpec COMMA TypeArgumentsEnd GT SR BSR PostfixExpression PrimaryExpression IdentPrimary ArgList ExpressionList Expression AssignmentExpression PLUS-ASSIGN MINUS-ASSIGN STAR-ASSIGN DIV-ASSIGN MOD-ASSIGN SR-ASSIGN BSR-ASSIGN SL-ASSIGN BAND-ASSIGN BXOR-ASSIGN BOR-ASSIGN Constant NUM-INT EXPONENT FLOAT-SUFFIX HEX-DIGIT CHAR-LITERAL ESC STRING-LITERAL NUM-FLOAT NUM-LONG NUM-DOUBLE NewExpression Type ClassBlock LCURLY ClassField Modifiers Modifier InnerTypeDef EnumDefinition ENUM ImplementsClause EnumBlock EnumConst EnumConstInit SEMI RCURLY ClassDefinition TypeParameters TypeParameter BAND SuperClassClause InterfaceDefinition InterfaceExtends InterfaceBlock InterfaceField MemberDef TypeSpec ParameterDeclarationList ParameterDeclaration ParameterModifier ELLIPSIS DeclaratorBrackets ThrowsClause CompoundStatement Statement Declaration VariableDefinitions VariableDeclarator VarInitializer Initializer ArrayInitializer COLON ForInit ForCond ForIter CasesGroup ACase CaseSList TryBlock Handler FinallyClause ASSERT AnnotationTypeDefinition AnnotationBlock AnnotationField DefaultValue CtorHead ConstructorBody ExplicitConstructorInvocation NewArrayDeclarator STAR DIV MOD SL LE GE NOT-EQUAL EQUAL BXOR BOR LAND LOR AnnotationMemberArrayInitializer ImportDefinition IdentifierStar TypeDefinition 
  context-free syntax
        (PackageDefinition | ) ImportDefinition* TypeDefinition* -> CompilationUnit

        Annotations p::"package" Identifier SEMI -> PackageDefinition

        Annotation* -> Annotations

        AT Identifier AnnotationInit -> Annotation

        "@" -> AT

        IDENT (DOT IDENT)* -> Identifier

        ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "$") ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "$")* -> IDENT

        "." -> DOT

        lp::LPAREN ((AnnotationMemberInit (COMMA AnnotationMemberInit)*) | AnnotationMemberValue | ) RPAREN -> AnnotationInit
         -> AnnotationInit

        "(" -> LPAREN

        IDENT ASSIGN AnnotationMemberValue -> AnnotationMemberInit

        "=" -> ASSIGN

        Annotation -> AnnotationMemberValue
        ConditionalExpression -> AnnotationMemberValue
        AnnotationMemberArrayInitializer -> AnnotationMemberValue

        LogicalOrExpression (QUESTION AssignmentExpression COLON ConditionalExpression)? -> ConditionalExpression

        LogicalAndExpression (LOR LogicalAndExpression)* -> LogicalOrExpression

        InclusiveOrExpression (LAND InclusiveOrExpression)* -> LogicalAndExpression

        ExclusiveOrExpression (BOR ExclusiveOrExpression)* -> InclusiveOrExpression

        AndExpression (BXOR AndExpression)* -> ExclusiveOrExpression

        EqualityExpression (BAND EqualityExpression)* -> AndExpression

        RelationalExpression ((NOT-EQUAL | EQUAL) RelationalExpression)* -> EqualityExpression

        ShiftExpression (((LT | GT | LE | GE) ShiftExpression)* | ("instanceof" TypeSpec)) -> RelationalExpression

        AdditiveExpression ((SL | SR | BSR) AdditiveExpression)* -> ShiftExpression

        MultiplicativeExpression ((PLUS | MINUS) MultiplicativeExpression)* -> AdditiveExpression

        UnaryExpression ((STAR | DIV | MOD) UnaryExpression)* -> MultiplicativeExpression

        INC UnaryExpression -> UnaryExpression
        DEC UnaryExpression -> UnaryExpression
        MINUS UnaryExpression -> UnaryExpression
        PLUS UnaryExpression -> UnaryExpression
        UnaryExpressionNotPlusMinus -> UnaryExpression

        "++" -> INC

        "--" -> DEC

        "-" -> MINUS

        "+" -> PLUS

        BNOT UnaryExpression -> UnaryExpressionNotPlusMinus
        LNOT UnaryExpression -> UnaryExpressionNotPlusMinus
        lpb::LPAREN BuiltInTypeSpec RPAREN UnaryExpression -> UnaryExpressionNotPlusMinus
        lp::LPAREN ClassTypeSpec RPAREN UnaryExpressionNotPlusMinus -> UnaryExpressionNotPlusMinus
        PostfixExpression -> UnaryExpressionNotPlusMinus

        "~" -> BNOT

        "!" -> LNOT

        BuiltInType (lb::LBRACK RBRACK)* -> BuiltInTypeSpec

        "void" -> BuiltInType
        "boolean" -> BuiltInType
        "byte" -> BuiltInType
        "char" -> BuiltInType
        "short" -> BuiltInType
        "int" -> BuiltInType
        "float" -> BuiltInType
        "long" -> BuiltInType
        "double" -> BuiltInType

        "[" -> LBRACK

        "]" -> RBRACK

        ")" -> RPAREN

        ClassOrInterfaceType (lb::LBRACK RBRACK)* -> ClassTypeSpec

        IDENT TypeArguments (DOT IDENT TypeArguments)* -> ClassOrInterfaceType

        lt::LT TypeArgument (COMMA TypeArgument)* TypeArgumentsEnd? -> TypeArguments
         -> TypeArguments

        "<" -> LT

        q::QUESTION (("extends" ReferenceTypeSpec) | ("super" ReferenceTypeSpec))? -> TypeArgument
        ReferenceTypeSpec -> TypeArgument

        "?" -> QUESTION

        ClassTypeSpec -> ReferenceTypeSpec
        ArrayTypeSpec -> ReferenceTypeSpec

        BuiltInType (lb::LBRACK RBRACK)+ -> ArrayTypeSpec

        "," -> COMMA

        GT -> TypeArgumentsEnd
        SR -> TypeArgumentsEnd
        BSR -> TypeArgumentsEnd

        ">" -> GT

        ">>" -> SR

        ">>>" -> BSR

        PrimaryExpression ((DOT "this") | (DOT ta1::TypeArguments ((IDENT (lp::LPAREN ArgList RPAREN)?) | ("super" ((lp3::LPAREN ArgList RPAREN) | (DOT ta2::TypeArguments IDENT (lps::LPAREN ArgList RPAREN)?))))) | (DOT NewExpression) | (lb::LBRACK Expression RBRACK))* (in::INC | de::DEC)? -> PostfixExpression

        IdentPrimary (DOT "class")? -> PrimaryExpression
        Constant -> PrimaryExpression
        "true" -> PrimaryExpression
        "false" -> PrimaryExpression
        "null" -> PrimaryExpression
        NewExpression -> PrimaryExpression
        "this" -> PrimaryExpression
        "super" -> PrimaryExpression
        LPAREN AssignmentExpression RPAREN -> PrimaryExpression
        BuiltInType (lbt::LBRACK RBRACK)* DOT "class" -> PrimaryExpression

        ta1::TypeArguments IDENT ((DOT ta2::TypeArguments IDENT) | )* ((lp::LPAREN ArgList RPAREN) | (lbc::LBRACK RBRACK)+)? -> IdentPrimary

        ExpressionList -> ArgList
         -> ArgList

        Expression (COMMA Expression)* -> ExpressionList

        AssignmentExpression -> Expression

        ConditionalExpression ((ASSIGN | PLUS-ASSIGN | MINUS-ASSIGN | STAR-ASSIGN | DIV-ASSIGN | MOD-ASSIGN | SR-ASSIGN | BSR-ASSIGN | SL-ASSIGN | BAND-ASSIGN | BXOR-ASSIGN | BOR-ASSIGN) AssignmentExpression)? -> AssignmentExpression

        "+=" -> PLUS-ASSIGN

        "-=" -> MINUS-ASSIGN

        "*=" -> STAR-ASSIGN

        "/=" -> DIV-ASSIGN

        "%=" -> MOD-ASSIGN

        ">>=" -> SR-ASSIGN

        ">>>=" -> BSR-ASSIGN

        "<<=" -> SL-ASSIGN

        "&=" -> BAND-ASSIGN

        "^=" -> BXOR-ASSIGN

        "|=" -> BOR-ASSIGN

        NUM-INT -> Constant
        CHAR-LITERAL -> Constant
        STRING-LITERAL -> Constant
        NUM-FLOAT -> Constant
        NUM-LONG -> Constant
        NUM-DOUBLE -> Constant

        "." (("." ".") | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? f1::FLOAT-SUFFIX?)?) -> NUM-INT
        (("0" ((("x" | "X") HEX-DIGIT+) | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+)?) | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) ("l" | "L" | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? f2::FLOAT-SUFFIX?) | (EXPONENT f3::FLOAT-SUFFIX?) | f4::FLOAT-SUFFIX)? -> NUM-INT

        ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ -> EXPONENT

        "f" -> FLOAT-SUFFIX
        "F" -> FLOAT-SUFFIX
        "d" -> FLOAT-SUFFIX
        "D" -> FLOAT-SUFFIX

        "0" -> HEX-DIGIT
        "1" -> HEX-DIGIT
        "2" -> HEX-DIGIT
        "3" -> HEX-DIGIT
        "4" -> HEX-DIGIT
        "5" -> HEX-DIGIT
        "6" -> HEX-DIGIT
        "7" -> HEX-DIGIT
        "8" -> HEX-DIGIT
        "9" -> HEX-DIGIT
        "A" -> HEX-DIGIT
        "B" -> HEX-DIGIT
        "C" -> HEX-DIGIT
        "D" -> HEX-DIGIT
        "E" -> HEX-DIGIT
        "F" -> HEX-DIGIT
        "a" -> HEX-DIGIT
        "b" -> HEX-DIGIT
        "c" -> HEX-DIGIT
        "d" -> HEX-DIGIT
        "e" -> HEX-DIGIT
        "f" -> HEX-DIGIT

        "\'" (ESC | STR) "\'" -> CHAR-LITERAL

        "\\" ("n" | "r" | "t" | "b" | "f" | """ | "\'" | "\\" | ("u"+ HEX-DIGIT HEX-DIGIT HEX-DIGIT HEX-DIGIT) | (("0" | "1" | "2" | "3") (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)?) | (("4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)) -> ESC

        """ (ESC | STR)* """ -> STRING-LITERAL

        "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("f" | "F") -> NUM-FLOAT
        "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "f" | "F") -> NUM-FLOAT
        ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("f" | "F")) | EXPONENT) -> NUM-FLOAT

        ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ("l" | "L") -> NUM-LONG

        "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("d" | "D") -> NUM-DOUBLE
        "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "d" | "D") -> NUM-DOUBLE
        ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("d" | "D")) | EXPONENT) -> NUM-DOUBLE

        "new" TypeArguments Type ((LPAREN ArgList RPAREN ClassBlock?) | (NewArrayDeclarator ArrayInitializer?)) -> NewExpression

        ClassOrInterfaceType -> Type
        BuiltInType -> Type

        LCURLY (ClassField | SEMI)* RCURLY -> ClassBlock

        "{" -> LCURLY

        mods::Modifiers (it::InnerTypeDef | (tp::TypeParameters ((h::CtorHead s::ConstructorBody) | md::MemberDef))) -> ClassField
        "static" s3::CompoundStatement -> ClassField
        s4::CompoundStatement -> ClassField

        (Modifier | Annotation)* -> Modifiers

        "private" -> Modifier
        "public" -> Modifier
        "protected" -> Modifier
        "static" -> Modifier
        "transient" -> Modifier
        "final" -> Modifier
        "abstract" -> Modifier
        "native" -> Modifier
        "threadsafe" -> Modifier
        "synchronized" -> Modifier
        "volatile" -> Modifier
        "strictfp" -> Modifier

        ed::EnumDefinition -> InnerTypeDef
        cd::ClassDefinition -> InnerTypeDef
        id::InterfaceDefinition -> InnerTypeDef
        ad::AnnotationTypeDefinition -> InnerTypeDef

        ENUM IDENT ic::ImplementsClause eb::EnumBlock -> EnumDefinition

        "enum" -> ENUM

        (i::"implements" ClassOrInterfaceType (COMMA ClassOrInterfaceType)*)? -> ImplementsClause

        LCURLY (EnumConst (COMMA EnumConst)*)? COMMA? (SEMI (ClassField | SEMI)*)? RCURLY -> EnumBlock

        Annotations IDENT EnumConstInit ClassBlock? -> EnumConst

        lp::LPAREN ArgList RPAREN -> EnumConstInit
         -> EnumConstInit

        ";" -> SEMI

        "}" -> RCURLY

        "class" IDENT tp::TypeParameters sc::SuperClassClause ic::ImplementsClause cb::ClassBlock -> ClassDefinition

        lt::LT TypeParameter (COMMA TypeParameter)* TypeArgumentsEnd? -> TypeParameters
         -> TypeParameters

        IDENT ("extends" ClassOrInterfaceType (BAND ClassOrInterfaceType)*)? -> TypeParameter

        "&" -> BAND

        ("extends" ClassOrInterfaceType)? -> SuperClassClause

        "interface" IDENT tp::TypeParameters ie::InterfaceExtends ib::InterfaceBlock -> InterfaceDefinition

        (e::"extends" ClassOrInterfaceType (COMMA ClassOrInterfaceType)*)? -> InterfaceExtends

        LCURLY (InterfaceField | SEMI)* RCURLY -> InterfaceBlock

        mods::Modifiers (it::InnerTypeDef | (tp::TypeParameters md::MemberDef)) -> InterfaceField

        t::TypeSpec ((IDENT LPAREN param::ParameterDeclarationList RPAREN rt::DeclaratorBrackets tc::ThrowsClause? (SEMI | s2::CompoundStatement)) | (v::VariableDefinitions SEMI)) -> MemberDef

        ClassTypeSpec -> TypeSpec
        BuiltInTypeSpec -> TypeSpec

        (ParameterDeclaration (COMMA ParameterDeclaration)*)? -> ParameterDeclarationList

        pm::ParameterModifier t::TypeSpec el::ELLIPSIS? id::IDENT pd::DeclaratorBrackets -> ParameterDeclaration

        ("final" | Annotation)* -> ParameterModifier

        "..." -> ELLIPSIS

        (lb::LBRACK RBRACK)* -> DeclaratorBrackets

        "throws" Identifier (COMMA Identifier)* -> ThrowsClause

        lc::LCURLY Statement* RCURLY -> CompoundStatement

        CompoundStatement -> Statement
        Declaration SEMI -> Statement
        Expression SEMI -> Statement
        m::Modifiers (EnumDefinition | ClassDefinition) -> Statement
        IDENT c::COLON Statement -> Statement
        "if" LPAREN Expression RPAREN Statement ("else" Statement)? -> Statement
        "for" LPAREN ((ParameterDeclaration COLON Expression) | (ForInit SEMI ForCond SEMI ForIter)) RPAREN Statement -> Statement
        "while" LPAREN Expression RPAREN Statement -> Statement
        "do" Statement "while" LPAREN Expression RPAREN SEMI -> Statement
        "break" IDENT? SEMI -> Statement
        "continue" IDENT? SEMI -> Statement
        "return" Expression? SEMI -> Statement
        "switch" LPAREN Expression RPAREN LCURLY CasesGroup* RCURLY -> Statement
        TryBlock -> Statement
        "throw" Expression SEMI -> Statement
        "synchronized" LPAREN Expression RPAREN CompoundStatement -> Statement
        ASSERT Expression (COLON Expression)? SEMI -> Statement
        s::SEMI -> Statement

        m::Modifiers t::TypeSpec v::VariableDefinitions -> Declaration

        VariableDeclarator (COMMA VariableDeclarator)* -> VariableDefinitions

        id::IDENT d::DeclaratorBrackets v::VarInitializer -> VariableDeclarator

        (ASSIGN Initializer)? -> VarInitializer

        Expression -> Initializer
        ArrayInitializer -> Initializer

        lc::LCURLY (Initializer (COMMA Initializer)*)? COMMA? RCURLY -> ArrayInitializer

        ":" -> COLON

        (Declaration | ExpressionList)? -> ForInit

        Expression? -> ForCond

        ExpressionList? -> ForIter

        ACase+ CaseSList -> CasesGroup

        (("case" Expression) | "default") COLON -> ACase

        Statement* -> CaseSList

        "try" CompoundStatement Handler* FinallyClause? -> TryBlock

        "catch" LPAREN ParameterDeclaration RPAREN CompoundStatement -> Handler

        "finally" CompoundStatement -> FinallyClause

        "assert" -> ASSERT

        AT "interface" IDENT ab::AnnotationBlock -> AnnotationTypeDefinition

        LCURLY (AnnotationField | SEMI)* RCURLY -> AnnotationBlock

        mods::Modifiers (it::InnerTypeDef | (ts::TypeSpec ((i::IDENT LPAREN RPAREN dv::DefaultValue SEMI) | (v::VariableDefinitions SEMI)))) -> AnnotationField

        ("default" AnnotationMemberValue)? -> DefaultValue

        IDENT LPAREN ParameterDeclarationList RPAREN ThrowsClause? -> CtorHead

        lc::LCURLY ExplicitConstructorInvocation? Statement* RCURLY -> ConstructorBody

        TypeArguments (("this" lp1::LPAREN ArgList RPAREN SEMI) | ("super" lp2::LPAREN ArgList RPAREN SEMI)) -> ExplicitConstructorInvocation

        (lb::LBRACK Expression? RBRACK)+ -> NewArrayDeclarator

        "*" -> STAR

        "/" -> DIV

        "%" -> MOD

        "<<" -> SL

        "<=" -> LE

        ">=" -> GE

        "!=" -> NOT-EQUAL

        "==" -> EQUAL

        "^" -> BXOR

        "|" -> BOR

        "&&" -> LAND

        "||" -> LOR

        lc::LCURLY (AnnotationMemberValue (COMMA AnnotationMemberValue)*)? COMMA? RCURLY -> AnnotationMemberArrayInitializer

        i::"import" "static"? IdentifierStar SEMI -> ImportDefinition

        IDENT (DOT IDENT)* (DOT STAR)? -> IdentifierStar

        m::Modifiers (ClassDefinition | EnumDefinition | InterfaceDefinition | AnnotationTypeDefinition) -> TypeDefinition
        SEMI -> TypeDefinition
