String = STR ;
Boolean = 'true' ;
Boolean = 'false' ;
Integer = INT ;
AST = root::ANY ;
ASTNode = AnonymousClassDeclaration ;
ASTNode = BodyDeclaration ;
ASTNode = CatchClause ;
ASTNode = Comment ;
ASTNode = CompilationUnit ;
ASTNode = Expression ;
ASTNode = ImportDeclaration ;
ASTNode = MemberRef ;
ASTNode = MemberValuePair ;
ASTNode = MethodRef ;
ASTNode = MethodRefParameter ;
ASTNode = PackageDeclaration ;
ASTNode = Statement ;
ASTNode = TagElement ;
ASTNode = TextElement ;
ASTNode = Type ;
ASTNode = TypeParameter ;
ASTNode = VariableDeclaration ;
ASTNode = Modifier ;
AnonymousClassDeclaration = bodyDeclarations::ANY+ ;
BodyDeclaration = AbstractTypeDeclaration ;
BodyDeclaration = AnnotationTypeMemberDeclaration ;
BodyDeclaration = EnumConstantDeclaration ;
BodyDeclaration = FieldDeclaration ;
BodyDeclaration = Initializer ;
BodyDeclaration = MethodDeclaration ;
CatchClause = body::ANY exception::ANY ;
Comment = BlockComment ;
Comment = Javadoc ;
Comment = LineComment ;
CompilationUnit = comments::ANY+ package::ANY imports::ANY+ types::ANY+ ;
Expression = ArrayAccess ;
Expression = ArrayCreation ;
Expression = ArrayInitializer ;
Expression = Assignment ;
Expression = BooleanLiteral ;
Expression = CastExpression ;
Expression = CharacterLiteral ;
Expression = ClassInstanceCreation ;
Expression = ConditionalExpression ;
Expression = FieldAccess ;
Expression = InfixExpression ;
Expression = InstanceofExpression ;
Expression = MethodInvocation ;
Expression = Name ;
Expression = NullLiteral ;
Expression = NumberLiteral ;
Expression = ParenthesizedExpression ;
Expression = PostfixExpression ;
Expression = PrefixExpression ;
Expression = StringLiteral ;
Expression = SuperFieldAccess ;
Expression = SuperMethodInvocation ;
Expression = ThisExpression ;
Expression = TypeLiteral ;
Expression = VariableDeclarationExpression ;
Expression = Annotation ;
ImportDeclaration = onDemand::ANY static::ANY name::ANY ;
MemberRef = name::ANY qualifier::ANY ;
MemberValuePair = name::ANY value::ANY ;
MethodRef = name::ANY qualifier::ANY parameters::ANY+ ;
MethodRefParameter = name::ANY type::ANY varargs::ANY ;
ExtendedModifier = Modifier ;
ExtendedModifier = Annotation ;
Modifier = abstract::ANY final::ANY native::ANY none::ANY private::ANY protected::ANY public::ANY static::ANY strictfp::ANY synchronized::ANY transient::ANY volatile::ANY ;
PackageDeclaration = annotations::ANY+ javadoc::ANY name::ANY ;
Statement = AssertStatement ;
Statement = Block ;
Statement = BreakStatement ;
Statement = ConstructorInvocation ;
Statement = ContinueStatement ;
Statement = DoStatement ;
Statement = EmptyStatement ;
Statement = EnhancedForStatement ;
Statement = ExpressionStatement ;
Statement = ForStatement ;
Statement = IfStatement ;
Statement = LabeledStatement ;
Statement = ReturnStatement ;
Statement = SuperConstructorInvocation ;
Statement = SwitchCase ;
Statement = SwitchStatement ;
Statement = SynchronizedStatement ;
Statement = ThrowStatement ;
Statement = TryStatement ;
Statement = TypeDeclarationStatement ;
Statement = VariableDeclarationStatement ;
Statement = WhileStatement ;
TagElement = fragments::ANY+ tagName::ANY nested::ANY ;
TextElement = text::ANY ;
Type = ArrayType ;
Type = ParameterizedType ;
Type = PrimitiveType ;
Type = QualifiedType ;
Type = SimpleType ;
Type = WildcardType ;
TypeParameter = name::ANY typeBounds::ANY+ ;
VariableDeclaration = SingleVariableDeclaration ;
VariableDeclaration = VariableDeclarationFragment ;
AbstractTypeDeclaration = AnnotationTypeDeclaration ;
AbstractTypeDeclaration = EnumDeclaration ;
AbstractTypeDeclaration = TypeDeclaration ;
AnnotationTypeMemberDeclaration = default::ANY name::ANY type::ANY ;
EnumConstantDeclaration = arguments::ANY+ anonymousClassDeclaration::ANY name::ANY ;
FieldDeclaration = fragments::ANY+ type::ANY ;
Initializer = body::ANY ;
MethodDeclaration = body::ANY extraDimensions::ANY name::ANY returnType::ANY constructor::ANY varargs::ANY parameters::ANY+ thrownExceptions::ANY+ typeParameters::ANY+ ;
AnnotationTypeDeclaration = bodyDeclarations::ANY+ name::ANY localTypeDeclaration::ANY memberTypeDeclaration::ANY packageMemberTypeDeclaration::ANY ;
EnumDeclaration = superInterfaceTypes::ANY+ enumConstants::ANY+ ;
TypeDeclaration = superclassType::ANY interface::ANY superInterfaceTypes::ANY+ typeParameters::ANY+ ;
BlockComment = alternateRoot::ANY ;
Javadoc = tags::ANY+ ;
LineComment = alternateRoot::ANY ;
Annotation = MarkerAnnotation ;
Annotation = NormalAnnotation ;
Annotation = SingleMemberAnnotation ;
ArrayAccess = array::ANY index::ANY ;
ArrayCreation = dimensions::ANY+ initializer::ANY type::ANY ;
ArrayInitializer = expressions::ANY+ ;
Assignment = leftHandSide::ANY operator::ANY rightHandSide::ANY ;
AssignementOperatorKind = RIGHT_SHIFT_SIGNED_ASSIGN:: ;
AssignementOperatorKind = BIT_XOR_ASSIGN:: ;
AssignementOperatorKind = TIMES_ASSIGN:: ;
AssignementOperatorKind = LEFT_SHIFT_ASSIGN:: ;
AssignementOperatorKind = MINUS_ASSIGN:: ;
AssignementOperatorKind = BIT_OR_ASSIGN:: ;
AssignementOperatorKind = PLUS_ASSIGN:: ;
AssignementOperatorKind = ASSIGN:: ;
AssignementOperatorKind = RIGHT_SHIFT_UNSIGNED_ASSIGN:: ;
AssignementOperatorKind = REMAINDER_ASSIGN:: ;
AssignementOperatorKind = DIVIDE_ASSIGN:: ;
AssignementOperatorKind = BIT_AND_ASSIGN:: ;
BooleanLiteral = booleanValue::ANY ;
CastExpression = expression::ANY type::ANY ;
CharacterLiteral = charValue::ANY escapedValue::ANY ;
ClassInstanceCreation = arguments::ANY+ anonymousClassDeclaration::ANY expression::ANY type::ANY typeArguments::ANY+ ;
ConditionalExpression = elseExpression::ANY expression::ANY thenExpression::ANY ;
FieldAccess = expression::ANY name::ANY ;
InfixExpression = extendedOperands::ANY+ leftOperand::ANY operator::ANY rightOperand::ANY ;
InfixExpressionOperatorKind = GREATER_EQUALS:: ;
InfixExpressionOperatorKind = OR:: ;
InfixExpressionOperatorKind = RIGHT_SHIFT_SIGNED:: ;
InfixExpressionOperatorKind = MINUS:: ;
InfixExpressionOperatorKind = XOR:: ;
InfixExpressionOperatorKind = LESS_EQUALS:: ;
InfixExpressionOperatorKind = EQUALS:: ;
InfixExpressionOperatorKind = NOT_EQUALS:: ;
InfixExpressionOperatorKind = AND:: ;
InfixExpressionOperatorKind = PLUS:: ;
InfixExpressionOperatorKind = GREATER:: ;
InfixExpressionOperatorKind = CONDITIONAL_OR:: ;
InfixExpressionOperatorKind = REMAINDER:: ;
InfixExpressionOperatorKind = LESS:: ;
InfixExpressionOperatorKind = LEFT_SHIFT:: ;
InfixExpressionOperatorKind = RIGHT_SHIFT_UNSIGNED:: ;
InfixExpressionOperatorKind = CONDITIONAL_AND:: ;
InfixExpressionOperatorKind = TIMES:: ;
InfixExpressionOperatorKind = DIVIDE:: ;
InstanceofExpression = leftOperand::ANY rightOperand::ANY ;
MethodInvocation = arguments::ANY+ expression::ANY name::ANY typeArguments::ANY+ ;
Name = QualifiedName ;
Name = SimpleName ;
NullLiteral = resolveBoxing::ANY resolveUnboxing::ANY ;
NumberLiteral = token::ANY ;
ParenthesizedExpression = expression::ANY ;
PostfixExpression = operand::ANY operator::ANY ;
PostfixExpresssionOperatorKind = INCREMENT:: ;
PostfixExpresssionOperatorKind = DECREMENT:: ;
PrefixExpression = operand::ANY operator::ANY ;
PrefixExpresssionOperatorKind = MINUS:: ;
PrefixExpresssionOperatorKind = NOT:: ;
PrefixExpresssionOperatorKind = DECREMENT:: ;
PrefixExpresssionOperatorKind = COMPLEMENT:: ;
PrefixExpresssionOperatorKind = INCREMENT:: ;
PrefixExpresssionOperatorKind = PLUS:: ;
StringLiteral = escapedValue::ANY literalValue::ANY ;
SuperFieldAccess = name::ANY qualifier::ANY ;
SuperMethodInvocation = arguments::ANY+ name::ANY qualifier::ANY typeArguments::ANY+ ;
ThisExpression = qualifier::ANY ;
TypeLiteral = type::ANY ;
VariableDeclarationExpression = fragments::ANY+ modifiers::ANY+ type::ANY ;
AssertStatement = expression::ANY message::ANY ;
Block = statements::ANY+ ;
BreakStatement = label::ANY ;
ConstructorInvocation = arguments::ANY+ typeArguments::ANY+ ;
ContinueStatement = label::ANY ;
DoStatement = body::ANY expression::ANY ;
EmptyStatement =  ;
EnhancedForStatement = body::ANY expression::ANY parameter::ANY ;
ExpressionStatement = expression::ANY ;
ForStatement = body::ANY expression::ANY initializers::ANY+ updaters::ANY+ ;
IfStatement = elseStatement::ANY expression::ANY thenStatement::ANY ;
LabeledStatement = body::ANY label::ANY ;
ReturnStatement = expression::ANY ;
SuperConstructorInvocation = arguments::ANY+ expression::ANY typeArguments::ANY+ ;
SwitchCase = expression::ANY default::ANY ;
SwitchStatement = expression::ANY statements::ANY+ ;
SynchronizedStatement = body::ANY expression::ANY ;
ThrowStatement = expression::ANY ;
TryStatement = catchClauses::ANY+ body::ANY finally::ANY ;
TypeDeclarationStatement = declaration::ANY ;
VariableDeclarationStatement = fragments::ANY+ modifiers::ANY+ type::ANY ;
WhileStatement = body::ANY expression::ANY ;
ArrayType = componentType::ANY dimensions::ANY elementType::ANY ;
ParameterizedType = type::ANY typeArguments::ANY+ ;
PrimitiveType = code::ANY ;
QualifiedType = name::ANY qualifier::ANY ;
SimpleType = name::ANY ;
WildcardType = bound::ANY upperBound::ANY ;
SingleVariableDeclaration = type::ANY varargs::ANY modifiers::ANY+ ;
VariableDeclarationFragment = extraDimensions::ANY initializer::ANY name::ANY ;
QualifiedName = name::ANY qualifier::ANY ;
SimpleName = identifier::ANY declaration::ANY ;
MarkerAnnotation = typeName::ANY ;
NormalAnnotation = values::ANY+ ;
SingleMemberAnnotation = value::ANY ;
