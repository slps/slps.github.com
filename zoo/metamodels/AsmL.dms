LocatedElement = Body ;
LocatedElement = InWhereHolds ;
LocatedElement = AsmLFile ;
LocatedElement = AsmLElement ;
LocatedElement = VarOrCase ;
LocatedElement = VarOrMethod ;
LocatedElement = Enumerator ;
LocatedElement = Parameter ;
LocatedElement = Initially ;
LocatedElement = Rule ;
LocatedElement = Term ;
Body = rules::Rule+ ;
InWhereHolds = var::Term in::Term where::Term holds::Term ;
AsmLFile = elements::AsmLElement+ main::Main ;
AsmLElement = Namespace ;
AsmLElement = Structure ;
AsmLElement = Class ;
AsmLElement = Enumeration ;
AsmLElement = Function ;
AsmLElement = Type ;
AsmLElement = VarDeclaration ;
VarDeclaration = isConstant::Boolean isDeclaration::Boolean isLocal::Boolean name::String type::Type ;
Namespace = name::String ;
Structure = name::String varOrCase::VarOrCase+ superStructureName::String ;
VarOrCase = Case ;
Case = name::String variables::VarDeclaration+ ;
Class = name::String isAbstract::Boolean superClassName::String varOrMethod::VarOrMethod+ ;
VarOrMethod = Method ;
VarOrMethod = ownerClass::Class ;
Enumeration = name::String enumerators::Enumerator+ ;
Enumerator = name::String value::Term ;
Function = Main ;
Function = Method ;
Method = isAbstract::Boolean isShared::Boolean isEntryPoint::Boolean isOverride::Boolean returnType::Type parameters::Parameter+ ;
Parameter = name::String type::Type ownerMethod::Method ;
Main = mainFile::AsmLFile initialisations::Initially+ ;
Initially = id::VarTerm val::Term ;
Rule = SkipRule ;
Rule = Step ;
Rule = MethodInvocation ;
Rule = UpdateRule ;
Rule = ChooseRule ;
Rule = ForallRule ;
Rule = ConditionalRule ;
Rule = ReturnRule ;
Rule = AddRule ;
Rule = RemoveRule ;
SkipRule = ownerBody::Body ;
Step = StepUntilFixPoint ;
Step = StepExpression ;
Step = StepForEach ;
StepUntilFixPoint = name::String ;
StepExpression = StepWhile ;
StepExpression = StepUntil ;
StepWhile = expression::Term ;
StepUntil = expression::Term ;
StepForEach = expressions::InWhereHolds+ ;
MethodInvocation = called::MethodCallTerm ;
UpdateRule = UpdateVarRule ;
UpdateRule = UpdateFieldRule ;
UpdateRule = UpdateMapRule ;
UpdateVarRule = updateVar::Term ;
UpdateFieldRule = path::VarTerm ;
UpdateMapRule = updateMap::VarTerm parameters::Term+ ;
ChooseRule = expressions::InWhereHolds+ ifChoosenRules::Body ifNotChoosenRule::Body ;
ForallRule = expressions::InWhereHolds+ doRule::Body ;
ConditionalRule = ElseIf ;
ConditionalRule = condition::Term thenRule::Body elseRule::Body elseIfRule::ElseIf ;
ElseIf = condition::Term thenRule::Body elseRule::Body elseIfRule::ElseIf ;
ReturnRule = term::Term ;
AddRule = val::Term set::VarTerm ;
RemoveRule = val::Term set::VarTerm ;
Type = NamedType ;
Type = MapType ;
Type = TupletType ;
Type = SetType ;
Type = SequenceType ;
NamedType = name::String ;
MapType = ofType::Type toType::Type ;
TupletType = types::Type ;
SetType = of::Type ;
SequenceType = of::Type ;
Term = VarTerm ;
Term = Operator ;
Term = MapTerm ;
Term = TulpletTerm ;
Term = MethodCallTerm ;
Term = PredicateTerm ;
Term = SetTerm ;
Term = SequenceTerm ;
Term = Constant ;
VarTerm = name::String ;
Operator = opName::String leftExp::Term rightExp::Term ;
MapTerm = ofTerm::Term toTerm::Term separator::String ;
TulpletTerm = terms::Term ;
MethodCallTerm = NewInstance ;
MethodCallTerm = name::String parameters::Term+ ;
NewInstance = name::String parameters::Term+ ;
PredicateTerm = ForAllTerm ;
PredicateTerm = ExistsTerm ;
PredicateTerm = AnyIn ;
PredicateTerm = expressions::InWhereHolds+ ;
ForAllTerm = expressions::InWhereHolds+ ;
ExistsTerm = isUnique::Boolean ;
AnyIn = expressions::InWhereHolds+ ;
SetTerm = EnumerateSet ;
SetTerm = RangeSet ;
SetTerm = AlgorithmSet ;
EnumerateSet = vals::Term+ ;
RangeSet = minval::Term maxval::Term ;
AlgorithmSet = expressions::InWhereHolds+ ;
SequenceTerm = EnumerateSequence ;
SequenceTerm = RangeSequence ;
EnumerateSequence = vals::Term+ ;
RangeSequence = minval::Term maxval::Term ;
Constant = BooleanConstant ;
Constant = IntegerConstant ;
Constant = StringConstant ;
Constant = NullConstant ;
BooleanConstant = val::Boolean ;
IntegerConstant = val::Integer ;
StringConstant = val::String ;
NullConstant = ;
String = STR ;
Integer = INT ;
Boolean = 'true' ;
Boolean = 'false' ;
