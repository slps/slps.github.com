program = program_definition ;
program = package_definition ;
program = library_definition ;
program = unit_definition ;
program_definition = 'program' decl_name program_file_list? ';' NL program_block '.' ;
program_file_list = '(' 
	    id
	    ','
	   ')' ;
package_definition = 'package' decl_name ';' NL requires_clause? contains_clause? 'end' '.' ;
requires_clause = requires_idList_semicolon* ;
contains_clause = contains_idList_semicolon* ;
requires_idList_semicolon = 'requires' ref_name+ ';' NL ;
contains_idList_semicolon = 'contains' ref_name+ ';' NL ;
library_definition = 'library' decl_name ';' NL program_block '.' ;
unit_definition = 'unit' decl_name ';' NL interface_section NL implementation_section NL init_section '.' ;
interface_section = 'interface' NL NL uses_clause? NL interface_declaration* ;
implementation_section = 'implementation' IN NL uses_clause? declaration_section* EX NL ;
init_section = 'intitialization' IN NL statement_list fin_statement_list? EX NL 'end' ;
init_section = compound_statement ;
init_section = 'end' ;
interface_declaration = constant_section ;
interface_declaration = type_section ;
interface_declaration = var_section ;
interface_declaration = exported_heading directive? ;
exported_heading = procedure_heading ';' NL ;
exported_heading = function_heading ';' NL ;
exported_heading = constructor_heading ';' NL ;
exported_heading = destructor_heading ';' NL ;
program_block = uses_clause? block ;
uses_clause = 'uses' IN NL uses_item+ ';' EX NL ;
uses_item = ref_name in_clause? ;
in_clause = 'in' charlit ;
block = declaration_section* compound_statement ;
declaration_section = label_declaration_section ;
declaration_section = constant_section ;
declaration_section = type_section ;
declaration_section = var_section ;
declaration_section = procedure_section ;
label_declaration_section = 'label' decl_name ;
constant_section = 'const' IN NL constant_declaration* EX NL ;
constant_declaration = decl_name '=' expression ';' NL ;
constant_declaration = decl_name ':' typeId '=' typed_constant ';' NL ;
type_section = 'type' IN NL type_declaration+ EX NL ;
type_declaration = decl_name '=' type_or_restrictedType ;
type_or_restrictedType = type ';' NL ;
type_or_restrictedType = restrictedType ';' NL ;
typed_constant = expression ;
typed_constant = array_constant ;
typed_constant = record_constant ;
array_constant = '(' 
	    typed_constant
	    ','
	   ')' ;
record_constant = '(' typed_constant semicolon_record_field_constant* ')' ;
semicolon_record_field_constant = ';' decl_name ':' typed_constant ;
type = typeId ;
type = simpleType ;
type = structType ;
type = pointerType ;
type = stringType ;
type = procedureType ;
type = variantType ;
type = class_referenceType ;
restrictedType = objectType ;
restrictedType = classType ;
restrictedType = interfaceType ;
class_referenceType = 'class' 'of' typeId ;
simpleType = ordinalType ;
simpleType = realType ;
realType = 'real48' ;
realType = 'real' ;
realType = 'single' ;
realType = 'double' ;
realType = 'extended' ;
realType = 'currency' ;
realType = 'comp' ;
ordinalType = subrangeType ;
ordinalType = enumeratedType ;
ordinalType = ordinal_identifier ;
enumeratedType = '(' 
	    decl_name
	    ','
	   ')' ;
ordinal_identifier = 'shortint' ;
ordinal_identifier = 'smallint' ;
ordinal_identifier = 'integer' ;
ordinal_identifier = 'byte' ;
ordinal_identifier = 'longint' ;
ordinal_identifier = 'int64' ;
ordinal_identifier = 'word' ;
ordinal_identifier = 'boolean' ;
ordinal_identifier = 'char' ;
ordinal_identifier = 'widechar' ;
ordinal_identifier = 'longchar' ;
ordinal_identifier = 'pchar' ;
variantType = 'variant' ;
variantType = 'olevariant' ;
subrangeType = expression '..' expression ;
stringType = 'string' ;
stringType = 'ansistring' ;
stringType = 'widestring' ;
stringType = 'string' '[' expression ']' ;
structType = arrayType 'packed'? ;
structType = setType 'packed'? ;
structType = fileType 'packed'? ;
structType = recordType 'packed'? ;
arrayType = array_word square_ordinalType? 'of' type ;
array_word = 'array' ;
array_word = 'Array' ;
square_ordinalType = '[' 
	    ordinalType
	    ','
	   ']' ;
recordType = 'record' field_list 'end' ;
field_list = field_declaration+ variant_section? ;
field_declaration = decl_name+ ':' type ';' NL ;
variant_section = 'case' id_colon? typeId 'of' record_variant_semicolon+ ';'? ;
id_colon = decl_name ':' ;
record_variant_semicolon = record_variant ';' NL ;
record_variant = expression+ ':' '(' field_list? ')' ;
setType = 'set' 'of' ordinalType ;
fileType = 'file' 'of' typeId ;
pointerType = '^' typeId ;
procedureType = proc_or_func_heading of_object? ;
proc_or_func_heading = procedure_heading ;
proc_or_func_heading = function_heading ;
of_object = 'of' 'object' ;
typeId = ref_name ;
typeId = predefinedType ;
predefinedType = 'integer' ;
predefinedType = 'real' ;
predefinedType = 'boolean' ;
predefinedType = 'char' ;
predefinedType = 'byte' ;
objectType = 'object' object_heritage? object_field_list? method_list? 'end' ;
object_heritage = '(' ref_name ')' ;
method_list = virtual_method_heading semi_virtual_method_heading* ;
semi_virtual_method_heading = ';' NL virtual_method_heading ;
virtual_method_heading = method_heading semi_directive? semicolon_virtual? ;
semicolon_virtual = ';' 'virtual' ;
method_heading = procedure_heading ;
method_heading = function_heading ;
method_heading = destructor_heading ;
method_heading = constructor_heading ;
semi_directive = ';' directive ;
constructor_heading = 'constructor' decl_name formal_parameters? ;
destructor_heading = 'destructor' decl_name formal_parameters? ;
object_field_list = ident_list_colonType semi_ident_list_colonType* ;
semi_ident_list_colonType = ';' NL ident_list_colonType ;
ident_list_colonType = decl_name+ ':' type ;
fin_statement_list = 'finalization' statement_list ;
classType = 'class' class_heritage? IN NL class_element_list? vis_spec_element_list* EX NL 'end'? ;
class_heritage = '(' 
	    ref_name
	    ','
	   ')' ;
class_visibility = 'public' ;
class_visibility = 'protected' ;
class_visibility = 'Protected' ;
class_visibility = 'private' ;
class_visibility = 'published' ;
vis_spec_element_list = NL class_visibility class_element_list? ;
class_element_list = class_element_semi+ ;
class_element_semi = NL class_element ';' ;
class_element = virtual_method_heading ;
class_element = ident_list_colonType ;
class_element = property_list ;
class_element =  ;
class_method_list = class_visibility_method_list* ;
class_visibility_method_list = class_visibility method_list ;
class_property_list = class_visibility_property_list* ;
class_visibility_property_list = class_visibility property_list ;
property_list = property_word decl_name property_interface? property_specifiers* ;
property_word = 'property' ;
property_word = 'Property' ;
property_interface = property_parameter_list? ':' type ;
property_parameter_list = '[' idList_colonTypeId_semicolon* ']' ;
idList_colonTypeId_semicolon = decl_name+ ':' typeId ';' NL ;
property_specifiers = index_expession ;
property_specifiers = read_id ;
property_specifiers = write_id ;
property_specifiers = stored_id_OR_stored_expression ;
property_specifiers = default_expression_OR_nodefault ;
property_specifiers = implementsTypeId ;
index_expession = 'index' expression ;
read_id = 'read' ref_name ;
write_id = 'write' ref_name ;
stored_id_OR_stored_expression = 'stored' id_or_expression ;
default_expression_OR_nodefault = 'default' expression ;
default_expression_OR_nodefault = 'nodefault' ;
implementsTypeId = 'implements' typeId ;
interfaceType = 'interface' interface_heritage? class_method_list? class_property_list? 'end' ;
interface_heritage = '(' 
	    ref_name
	    ','
	   ')' ;
var_section = var NL IN var_declaration_semicolon* NL EX ;
var = 'var' ;
var = 'Var' ;
var_declaration_semicolon = var_declaration ';' NL ;
var_declaration = decl_name+ ':' type var_assignment? ;
var_assignment = absolute_assignment ;
var_assignment = constant_assignment ;
absolute_assignment = 'absolute' id_or_expression ;
id_or_expression = ref_name ;
id_or_expression = expression ;
constant_assignment = '=' expression ;
procedure_section = procedure_declaration ;
procedure_section = function_declaration ;
procedure_section = constructor_declaration ;
procedure_section = destructor_declaration ;
constructor_declaration = constructor_heading ';' IN NL block EX NL ';' NL ;
destructor_declaration = destructor_heading ';' IN NL block EX NL ';' NL ;
procedure_declaration = procedure_heading ';' IN NL block EX NL ';' NL ;
function_declaration = function_heading semi_directive? ';' IN NL block EX NL ';' NL ;
function_heading = function_word decl_name formal_parameters? ':' type_or_string ;
type_or_string = type ;
type_or_string = charlit ;
function_word = 'function' ;
function_word = 'Function' ;
procedure_heading = procedure decl_name formal_parameters? ;
procedure = 'procedure' ;
procedure = 'Procedure' ;
formal_parameters = '(' formal_parameter semi_formal_parameter* ')' ;
semi_formal_parameter = ';' NL formal_parameter ;
formal_parameter = parm_qual? parameter ;
parm_qual = var ;
parm_qual = 'const' ;
parm_qual = 'out' ;
parameter = 
	    decl_name
	    ','
	   parameter_type? ;
parameter_type = ':' array_of? type param_init? ;
param_init = '=' expression ;
array_of = array_word set_constructor? 'of' ;
statement_list = statement semi_statement* ;
semi_statement = ';' NL statement ;
statement = labelId_colon? unlabeled_statement ;
statement =  ;
labelId_colon = labelId ':' ;
unlabeled_statement = simple_statement ;
unlabeled_statement = struct_statement ;
simple_statement = ref_name assign_expression? ;
simple_statement = 'inherited' ref_name? ;
simple_statement = 'goto' labelId ;
assign_expression = ':=' expression ;
labelId = 'label' number+ ';' NL ;
struct_statement = compound_statement ;
struct_statement = conditional_statement ;
struct_statement = loop_statement ;
struct_statement = with_statement ;
struct_statement = try_finally_statement ;
struct_statement = try_except_statement ;
struct_statement = raise_statement ;
compound_statement = begin IN NL statement_list EX NL 'end' NL ;
begin = 'begin' ;
begin = 'Begin' ;
conditional_statement = if_statement ;
conditional_statement = case_statement ;
if_statement = if expression 'then' statement? else_statement? ;
else_statement = 'else' statement? ;
if = 'if' ;
if = 'If' ;
case_statement = 'case' expression 'of' case_selector IN NL semi_case_selector* ';'? EX NL else_statement? ';'? NL 'end' ;
semi_case_selector = ';' NL case_selector ;
case_selector = case_label comma_case_label* ':' statement ;
comma_case_label = ',' case_label ;
case_label = expression dotDot_expression? ;
loop_statement = repeating_statement ;
loop_statement = while_statement ;
loop_statement = for_statement ;
repeating_statement = 'repeat' statement ';'? 'until' expression ;
while_statement = 'while' expression do statement ;
for_statement = for ref_name ':=' expression to_or_downto expression do statement ;
to_or_downto = 'to' ;
to_or_downto = 'downto' ;
for = 'for' ;
for = 'For' ;
do = 'do' ;
do = 'Do' ;
do = 'DO' ;
with_statement = 'with' ref_name+ do statement ;
try_finally_statement = 'try' IN NL statement_list EX NL 'finally' IN NL statement_list EX NL 'end' ;
try_except_statement = 'try' IN NL statement_list EX NL except ';'? IN NL exception_block EX NL 'end' ;
except = 'except' ;
except = 'Except' ;
exception_block =  ;
exception_block = statement_list ;
exception_block = exception_else ;
exception_else = exception_handler_list NL EX else_statement? ;
exception_handler_list = exception_handler semi_exception_handler* ';'? ;
semi_exception_handler = ';' exception_handler ;
exception_handler = 'on' exception_var? type do IN NL statement EX ;
exception_var = decl_name ':' ;
raise_statement = 'raise' ref_name? at_address? ;
at_address = 'at' ref_name ;
expression = factor op_factor* ;
expression = op_factor+ ;
op_factor = op factor ;
op = '>' ;
op = '<' ;
op = '<=' ;
op = '>=' ;
op = '<>' ;
op = '=' ;
op = 'in' ;
op = 'is' ;
op = '+' ;
op = '-' ;
op = 'or' ;
op = 'xor' ;
op = '*' ;
op = '/' ;
op = 'div' ;
op = 'mod' ;
op = 'and' ;
op = 'shl' ;
op = 'shr' ;
op = 'DIV' ;
op = 'AND' ;
rel_op_simple_expression = rel_op simple_expression ;
simple_expression = term? add_op_term* ;
add_op_term = add_op term ;
term = factor mul_op_factor* ;
mul_op_factor = mul_op factor ;
factor = ref_name ;
factor = charlit ;
factor = pond_number+ ;
factor = '@' '@'? ref_name ;
factor = 'nil' ;
factor = '(' expression ')' ;
factor = not_word factor ;
factor = set_constructor ;
factor = predefinedType '(' expression ')' ;
factor = bool_value ;
factor = '-'? number ;
pond_number = '#' number ;
not_word = 'not' ;
not_word = 'Not' ;
not_word = 'NOT' ;
bool_value = 'true' ;
bool_value = 'false' ;
bool_value = 'True' ;
bool_value = 'False' ;
arguments = '(' 
	    expression
	    ','
	   ')' ;
rel_op = '>' ;
rel_op = '<' ;
rel_op = '<=' ;
rel_op = '>=' ;
rel_op = '<>' ;
rel_op = '=' ;
rel_op = 'in' ;
rel_op = 'is' ;
add_op = '+' ;
add_op = '-' ;
add_op = 'or' ;
add_op = 'xor' ;
mul_op = '*' ;
mul_op = '/' ;
mul_op = 'div' ;
mul_op = 'mod' ;
mul_op = 'and' ;
mul_op = 'shl' ;
mul_op = 'shr' ;
mul_op = 'DIV' ;
mul_op = 'AND' ;
set_constructor = '[' 
	    set_element
	    ','
	   ']' ;
set_element = expression dotDot_expression? ;
dotDot_expression = '..' expression ;
startNameTag = SPOFF SP '<' 'UID' SP 'name' '=' stringlit '>' SPON ;
endNameTag = SPOFF SP '</' 'UID' '>' SPON ;
decl_name = id dot_id* ;
ref_name = object ;
object = id object_modifier* ;
object = '(' ref_name ')' object_modifier* ;
object_modifier = '.' id ;
object_modifier = array_subscript ;
object_modifier = arguments ;
object_modifier = '^' ;
object_modifier = as_type ;
dot_id = '.' id ;
array_subscript = '[' 
	    expression
	    ','
	   ']' ;
as_type = as type ;
as = 'As' ;
as = 'as' ;
directive = 'cdecl' ;
directive = 'register' ;
directive = 'dynamic' ;
directive = 'virtual' ;
directive = 'export' ;
directive = 'external' ;
directive = 'far' ;
directive = 'forward' ;
directive = 'message' ref_name? ;
directive = 'override' ;
directive = 'overload' ;
directive = 'pascal' ;
directive = 'reintroduce' ;
directive = 'safecall' ;
directive = 'stdcall' ;
directive = 'Override' ;
