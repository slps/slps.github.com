module Main

exports
  sorts
        Program Program-definition Program-file-list Package-definition Requires-clause Contains-clause Requires-idList-semicolon Contains-idList-semicolon Library-definition Unit-definition Interface-section Implementation-section Init-section Interface-declaration Exported-heading Program-block Uses-clause Uses-item In-clause Block Declaration-section Label-declaration-section Constant-section Constant-declaration Type-section Type-declaration Type-or-restrictedType Typed-constant Array-constant Record-constant Semicolon-record-field-constant Type RestrictedType Class-referenceType SimpleType RealType OrdinalType EnumeratedType Ordinal-identifier VariantType SubrangeType StringType StructType ArrayType Array-word Square-ordinalType RecordType Field-list Field-declaration Variant-section Id-colon Record-variant-semicolon Record-variant SetType FileType PointerType ProcedureType Proc-or-func-heading Of-object TypeId PredefinedType ObjectType Object-heritage Method-list Semi-virtual-method-heading Virtual-method-heading Semicolon-virtual Method-heading Semi-directive Constructor-heading Destructor-heading Object-field-list Semi-ident-list-colonType Ident-list-colonType Fin-statement-list ClassType Class-heritage Class-visibility Vis-spec-element-list Class-element-list Class-element-semi Class-element Class-method-list Class-visibility-method-list Class-property-list Class-visibility-property-list Property-list Property-word Property-interface Property-parameter-list IdList-colonTypeId-semicolon Property-specifiers Index-expession Read-id Write-id Stored-id-OR-stored-expression Default-expression-OR-nodefault ImplementsTypeId InterfaceType Interface-heritage Var-section Var Var-declaration-semicolon Var-declaration Var-assignment Absolute-assignment Id-or-expression Constant-assignment Procedure-section Constructor-declaration Destructor-declaration Procedure-declaration Function-declaration Function-heading Type-or-string Function-word Procedure-heading Procedure Formal-parameters Semi-formal-parameter Formal-parameter Parm-qual Parameter Parameter-type Param-init Array-of Statement-list Semi-statement Statement LabelId-colon Unlabeled-statement Simple-statement Assign-expression LabelId Struct-statement Compound-statement Begin Conditional-statement If-statement Else-statement If Case-statement Semi-case-selector Case-selector Comma-case-label Case-label Loop-statement Repeating-statement While-statement For-statement To-or-downto For Do With-statement Try-finally-statement Try-except-statement Except Exception-block Exception-else Exception-handler-list Semi-exception-handler Exception-handler Exception-var Raise-statement At-address Expression Op-factor Op Rel-op-simple-expression Simple-expression Add-op-term Term Mul-op-factor Factor Pond-number Not-word Bool-value Arguments Rel-op Add-op Mul-op Set-constructor Set-element DotDot-expression StartNameTag EndNameTag Decl-name Ref-name Object Object-modifier Dot-id Array-subscript As-type As Directive 
  context-free syntax
        Program-definition -> Program
        Package-definition -> Program
        Library-definition -> Program
        Unit-definition -> Program

        "program" Decl-name Program-file-list? ";" NL Program-block "." -> Program-definition

        "(" 
	    Id
	    ","
	   ")" -> Program-file-list

        "package" Decl-name ";" NL Requires-clause? Contains-clause? "end" "." -> Package-definition

        Requires-idList-semicolon* -> Requires-clause

        Contains-idList-semicolon* -> Contains-clause

        "requires" Ref-name+ ";" NL -> Requires-idList-semicolon

        "contains" Ref-name+ ";" NL -> Contains-idList-semicolon

        "library" Decl-name ";" NL Program-block "." -> Library-definition

        "unit" Decl-name ";" NL Interface-section NL Implementation-section NL Init-section "." -> Unit-definition

        "interface" NL NL Uses-clause? NL Interface-declaration* -> Interface-section

        "implementation" IN NL Uses-clause? Declaration-section* EX NL -> Implementation-section

        "intitialization" IN NL Statement-list Fin-statement-list? EX NL "end" -> Init-section
        Compound-statement -> Init-section
        "end" -> Init-section

        Constant-section -> Interface-declaration
        Type-section -> Interface-declaration
        Var-section -> Interface-declaration
        Exported-heading Directive? -> Interface-declaration

        Procedure-heading ";" NL -> Exported-heading
        Function-heading ";" NL -> Exported-heading
        Constructor-heading ";" NL -> Exported-heading
        Destructor-heading ";" NL -> Exported-heading

        Uses-clause? Block -> Program-block

        "uses" IN NL Uses-item+ ";" EX NL -> Uses-clause

        Ref-name In-clause? -> Uses-item

        "in" Charlit -> In-clause

        Declaration-section* Compound-statement -> Block

        Label-declaration-section -> Declaration-section
        Constant-section -> Declaration-section
        Type-section -> Declaration-section
        Var-section -> Declaration-section
        Procedure-section -> Declaration-section

        "label" Decl-name -> Label-declaration-section

        "const" IN NL Constant-declaration* EX NL -> Constant-section

        Decl-name "=" Expression ";" NL -> Constant-declaration
        Decl-name ":" TypeId "=" Typed-constant ";" NL -> Constant-declaration

        "type" IN NL Type-declaration+ EX NL -> Type-section

        Decl-name "=" Type-or-restrictedType -> Type-declaration

        Type ";" NL -> Type-or-restrictedType
        RestrictedType ";" NL -> Type-or-restrictedType

        Expression -> Typed-constant
        Array-constant -> Typed-constant
        Record-constant -> Typed-constant

        "(" 
	    Typed-constant
	    ","
	   ")" -> Array-constant

        "(" Typed-constant Semicolon-record-field-constant* ")" -> Record-constant

        ";" Decl-name ":" Typed-constant -> Semicolon-record-field-constant

        TypeId -> Type
        SimpleType -> Type
        StructType -> Type
        PointerType -> Type
        StringType -> Type
        ProcedureType -> Type
        VariantType -> Type
        Class-referenceType -> Type

        ObjectType -> RestrictedType
        ClassType -> RestrictedType
        InterfaceType -> RestrictedType

        "class" "of" TypeId -> Class-referenceType

        OrdinalType -> SimpleType
        RealType -> SimpleType

        "real48" -> RealType
        "real" -> RealType
        "single" -> RealType
        "double" -> RealType
        "extended" -> RealType
        "currency" -> RealType
        "comp" -> RealType

        SubrangeType -> OrdinalType
        EnumeratedType -> OrdinalType
        Ordinal-identifier -> OrdinalType

        "(" 
	    Decl-name
	    ","
	   ")" -> EnumeratedType

        "shortint" -> Ordinal-identifier
        "smallint" -> Ordinal-identifier
        "integer" -> Ordinal-identifier
        "byte" -> Ordinal-identifier
        "longint" -> Ordinal-identifier
        "int64" -> Ordinal-identifier
        "word" -> Ordinal-identifier
        "boolean" -> Ordinal-identifier
        "char" -> Ordinal-identifier
        "widechar" -> Ordinal-identifier
        "longchar" -> Ordinal-identifier
        "pchar" -> Ordinal-identifier

        "variant" -> VariantType
        "olevariant" -> VariantType

        Expression ".." Expression -> SubrangeType

        "string" -> StringType
        "ansistring" -> StringType
        "widestring" -> StringType
        "string" "[" Expression "]" -> StringType

        ArrayType "packed"? -> StructType
        SetType "packed"? -> StructType
        FileType "packed"? -> StructType
        RecordType "packed"? -> StructType

        Array-word Square-ordinalType? "of" Type -> ArrayType

        "array" -> Array-word
        "Array" -> Array-word

        "[" 
	    OrdinalType
	    ","
	   "]" -> Square-ordinalType

        "record" Field-list "end" -> RecordType

        Field-declaration+ Variant-section? -> Field-list

        Decl-name+ ":" Type ";" NL -> Field-declaration

        "case" Id-colon? TypeId "of" Record-variant-semicolon+ ";"? -> Variant-section

        Decl-name ":" -> Id-colon

        Record-variant ";" NL -> Record-variant-semicolon

        Expression+ ":" "(" Field-list? ")" -> Record-variant

        "set" "of" OrdinalType -> SetType

        "file" "of" TypeId -> FileType

        "^" TypeId -> PointerType

        Proc-or-func-heading Of-object? -> ProcedureType

        Procedure-heading -> Proc-or-func-heading
        Function-heading -> Proc-or-func-heading

        "of" "object" -> Of-object

        Ref-name -> TypeId
        PredefinedType -> TypeId

        "integer" -> PredefinedType
        "real" -> PredefinedType
        "boolean" -> PredefinedType
        "char" -> PredefinedType
        "byte" -> PredefinedType

        "object" Object-heritage? Object-field-list? Method-list? "end" -> ObjectType

        "(" Ref-name ")" -> Object-heritage

        Virtual-method-heading Semi-virtual-method-heading* -> Method-list

        ";" NL Virtual-method-heading -> Semi-virtual-method-heading

        Method-heading Semi-directive? Semicolon-virtual? -> Virtual-method-heading

        ";" "virtual" -> Semicolon-virtual

        Procedure-heading -> Method-heading
        Function-heading -> Method-heading
        Destructor-heading -> Method-heading
        Constructor-heading -> Method-heading

        ";" Directive -> Semi-directive

        "constructor" Decl-name Formal-parameters? -> Constructor-heading

        "destructor" Decl-name Formal-parameters? -> Destructor-heading

        Ident-list-colonType Semi-ident-list-colonType* -> Object-field-list

        ";" NL Ident-list-colonType -> Semi-ident-list-colonType

        Decl-name+ ":" Type -> Ident-list-colonType

        "finalization" Statement-list -> Fin-statement-list

        "class" Class-heritage? IN NL Class-element-list? Vis-spec-element-list* EX NL "end"? -> ClassType

        "(" 
	    Ref-name
	    ","
	   ")" -> Class-heritage

        "public" -> Class-visibility
        "protected" -> Class-visibility
        "Protected" -> Class-visibility
        "private" -> Class-visibility
        "published" -> Class-visibility

        NL Class-visibility Class-element-list? -> Vis-spec-element-list

        Class-element-semi+ -> Class-element-list

        NL Class-element ";" -> Class-element-semi

        Virtual-method-heading -> Class-element
        Ident-list-colonType -> Class-element
        Property-list -> Class-element
         -> Class-element

        Class-visibility-method-list* -> Class-method-list

        Class-visibility Method-list -> Class-visibility-method-list

        Class-visibility-property-list* -> Class-property-list

        Class-visibility Property-list -> Class-visibility-property-list

        Property-word Decl-name Property-interface? Property-specifiers* -> Property-list

        "property" -> Property-word
        "Property" -> Property-word

        Property-parameter-list? ":" Type -> Property-interface

        "[" IdList-colonTypeId-semicolon* "]" -> Property-parameter-list

        Decl-name+ ":" TypeId ";" NL -> IdList-colonTypeId-semicolon

        Index-expession -> Property-specifiers
        Read-id -> Property-specifiers
        Write-id -> Property-specifiers
        Stored-id-OR-stored-expression -> Property-specifiers
        Default-expression-OR-nodefault -> Property-specifiers
        ImplementsTypeId -> Property-specifiers

        "index" Expression -> Index-expession

        "read" Ref-name -> Read-id

        "write" Ref-name -> Write-id

        "stored" Id-or-expression -> Stored-id-OR-stored-expression

        "default" Expression -> Default-expression-OR-nodefault
        "nodefault" -> Default-expression-OR-nodefault

        "implements" TypeId -> ImplementsTypeId

        "interface" Interface-heritage? Class-method-list? Class-property-list? "end" -> InterfaceType

        "(" 
	    Ref-name
	    ","
	   ")" -> Interface-heritage

        Var NL IN Var-declaration-semicolon* NL EX -> Var-section

        "var" -> Var
        "Var" -> Var

        Var-declaration ";" NL -> Var-declaration-semicolon

        Decl-name+ ":" Type Var-assignment? -> Var-declaration

        Absolute-assignment -> Var-assignment
        Constant-assignment -> Var-assignment

        "absolute" Id-or-expression -> Absolute-assignment

        Ref-name -> Id-or-expression
        Expression -> Id-or-expression

        "=" Expression -> Constant-assignment

        Procedure-declaration -> Procedure-section
        Function-declaration -> Procedure-section
        Constructor-declaration -> Procedure-section
        Destructor-declaration -> Procedure-section

        Constructor-heading ";" IN NL Block EX NL ";" NL -> Constructor-declaration

        Destructor-heading ";" IN NL Block EX NL ";" NL -> Destructor-declaration

        Procedure-heading ";" IN NL Block EX NL ";" NL -> Procedure-declaration

        Function-heading Semi-directive? ";" IN NL Block EX NL ";" NL -> Function-declaration

        Function-word Decl-name Formal-parameters? ":" Type-or-string -> Function-heading

        Type -> Type-or-string
        Charlit -> Type-or-string

        "function" -> Function-word
        "Function" -> Function-word

        Procedure Decl-name Formal-parameters? -> Procedure-heading

        "procedure" -> Procedure
        "Procedure" -> Procedure

        "(" Formal-parameter Semi-formal-parameter* ")" -> Formal-parameters

        ";" NL Formal-parameter -> Semi-formal-parameter

        Parm-qual? Parameter -> Formal-parameter

        Var -> Parm-qual
        "const" -> Parm-qual
        "out" -> Parm-qual

        
	    Decl-name
	    ","
	   Parameter-type? -> Parameter

        ":" Array-of? Type Param-init? -> Parameter-type

        "=" Expression -> Param-init

        Array-word Set-constructor? "of" -> Array-of

        Statement Semi-statement* -> Statement-list

        ";" NL Statement -> Semi-statement

        LabelId-colon? Unlabeled-statement -> Statement
         -> Statement

        LabelId ":" -> LabelId-colon

        Simple-statement -> Unlabeled-statement
        Struct-statement -> Unlabeled-statement

        Ref-name Assign-expression? -> Simple-statement
        "inherited" Ref-name? -> Simple-statement
        "goto" LabelId -> Simple-statement

        ":=" Expression -> Assign-expression

        "label" Number+ ";" NL -> LabelId

        Compound-statement -> Struct-statement
        Conditional-statement -> Struct-statement
        Loop-statement -> Struct-statement
        With-statement -> Struct-statement
        Try-finally-statement -> Struct-statement
        Try-except-statement -> Struct-statement
        Raise-statement -> Struct-statement

        Begin IN NL Statement-list EX NL "end" NL -> Compound-statement

        "begin" -> Begin
        "Begin" -> Begin

        If-statement -> Conditional-statement
        Case-statement -> Conditional-statement

        If Expression "then" Statement? Else-statement? -> If-statement

        "else" Statement? -> Else-statement

        "if" -> If
        "If" -> If

        "case" Expression "of" Case-selector IN NL Semi-case-selector* ";"? EX NL Else-statement? ";"? NL "end" -> Case-statement

        ";" NL Case-selector -> Semi-case-selector

        Case-label Comma-case-label* ":" Statement -> Case-selector

        "," Case-label -> Comma-case-label

        Expression DotDot-expression? -> Case-label

        Repeating-statement -> Loop-statement
        While-statement -> Loop-statement
        For-statement -> Loop-statement

        "repeat" Statement ";"? "until" Expression -> Repeating-statement

        "while" Expression Do Statement -> While-statement

        For Ref-name ":=" Expression To-or-downto Expression Do Statement -> For-statement

        "to" -> To-or-downto
        "downto" -> To-or-downto

        "for" -> For
        "For" -> For

        "do" -> Do
        "Do" -> Do
        "DO" -> Do

        "with" Ref-name+ Do Statement -> With-statement

        "try" IN NL Statement-list EX NL "finally" IN NL Statement-list EX NL "end" -> Try-finally-statement

        "try" IN NL Statement-list EX NL Except ";"? IN NL Exception-block EX NL "end" -> Try-except-statement

        "except" -> Except
        "Except" -> Except

         -> Exception-block
        Statement-list -> Exception-block
        Exception-else -> Exception-block

        Exception-handler-list NL EX Else-statement? -> Exception-else

        Exception-handler Semi-exception-handler* ";"? -> Exception-handler-list

        ";" Exception-handler -> Semi-exception-handler

        "on" Exception-var? Type Do IN NL Statement EX -> Exception-handler

        Decl-name ":" -> Exception-var

        "raise" Ref-name? At-address? -> Raise-statement

        "at" Ref-name -> At-address

        Factor Op-factor* -> Expression
        Op-factor+ -> Expression

        Op Factor -> Op-factor

        ">" -> Op
        "<" -> Op
        "<=" -> Op
        ">=" -> Op
        "<>" -> Op
        "=" -> Op
        "in" -> Op
        "is" -> Op
        "+" -> Op
        "-" -> Op
        "or" -> Op
        "xor" -> Op
        "*" -> Op
        "/" -> Op
        "div" -> Op
        "mod" -> Op
        "and" -> Op
        "shl" -> Op
        "shr" -> Op
        "DIV" -> Op
        "AND" -> Op

        Rel-op Simple-expression -> Rel-op-simple-expression

        Term? Add-op-term* -> Simple-expression

        Add-op Term -> Add-op-term

        Factor Mul-op-factor* -> Term

        Mul-op Factor -> Mul-op-factor

        Ref-name -> Factor
        Charlit -> Factor
        Pond-number+ -> Factor
        "@" "@"? Ref-name -> Factor
        "nil" -> Factor
        "(" Expression ")" -> Factor
        Not-word Factor -> Factor
        Set-constructor -> Factor
        PredefinedType "(" Expression ")" -> Factor
        Bool-value -> Factor
        "-"? Number -> Factor

        "#" Number -> Pond-number

        "not" -> Not-word
        "Not" -> Not-word
        "NOT" -> Not-word

        "true" -> Bool-value
        "false" -> Bool-value
        "True" -> Bool-value
        "False" -> Bool-value

        "(" 
	    Expression
	    ","
	   ")" -> Arguments

        ">" -> Rel-op
        "<" -> Rel-op
        "<=" -> Rel-op
        ">=" -> Rel-op
        "<>" -> Rel-op
        "=" -> Rel-op
        "in" -> Rel-op
        "is" -> Rel-op

        "+" -> Add-op
        "-" -> Add-op
        "or" -> Add-op
        "xor" -> Add-op

        "*" -> Mul-op
        "/" -> Mul-op
        "div" -> Mul-op
        "mod" -> Mul-op
        "and" -> Mul-op
        "shl" -> Mul-op
        "shr" -> Mul-op
        "DIV" -> Mul-op
        "AND" -> Mul-op

        "[" 
	    Set-element
	    ","
	   "]" -> Set-constructor

        Expression DotDot-expression? -> Set-element

        ".." Expression -> DotDot-expression

        SPOFF SP "<" "UID" SP "name" "=" Stringlit ">" SPON -> StartNameTag

        SPOFF SP "</" "UID" ">" SPON -> EndNameTag

        Id Dot-id* -> Decl-name

        Object -> Ref-name

        Id Object-modifier* -> Object
        "(" Ref-name ")" Object-modifier* -> Object

        "." Id -> Object-modifier
        Array-subscript -> Object-modifier
        Arguments -> Object-modifier
        "^" -> Object-modifier
        As-type -> Object-modifier

        "." Id -> Dot-id

        "[" 
	    Expression
	    ","
	   "]" -> Array-subscript

        As Type -> As-type

        "As" -> As
        "as" -> As

        "cdecl" -> Directive
        "register" -> Directive
        "dynamic" -> Directive
        "virtual" -> Directive
        "export" -> Directive
        "external" -> Directive
        "far" -> Directive
        "forward" -> Directive
        "message" Ref-name? -> Directive
        "override" -> Directive
        "overload" -> Directive
        "pascal" -> Directive
        "reintroduce" -> Directive
        "safecall" -> Directive
        "stdcall" -> Directive
        "Override" -> Directive
