program:
        file_input
file_input:
        stmt_or_newline*
stmt_or_newline:
        stmt
        endofline
decorator:
        "@" dotted_name decorator_arglist? endofline endofline*
decorator_arglist:
        SPOFF "(" SPON IN arglist? endofline* ")" EX
decorators:
        decorator+
decorated:
        decorators classdef
        decorators funcdef
funcdef:
        "def" id parameters ":" suite
parameters:
        SPOFF "(" SPON varargslist? endofline* ")"
varargslist:
        fpdef_test_comma* endofline* "*" id
        fpdef_test_comma* endofline* "*" id endofline? "," endofline* "**" id
        fpdef_test_comma* endofline* "**" id
        fpdef_test+ ","?
fpdef_test:
        endofline* fpdef is_test? endofline?
fpdef_test_comma:
        fpdef_test ","
is_test:
        "=" endofline* test
fpdef:
        id endofline?
        SPOFF "(" SPON fplist endofline* ")" endofline?
fplist:
        fpdef+ ","?
stmt:
        simple_stmt endofline
        compound_stmt
simple_stmt:
        small_stmt semicolon_small_stmt* ";"?
        comment
semicolon_small_stmt:
        ";" small_stmt
small_stmt:
        expr_stmt
        print_stmt
        del_stmt
        pass_stmt
        flow_stmt
        import_stmt
        global_stmt
        exec_stmt
        assert_stmt
expr_stmt:
        testlist is_expr*
        testlist augassign assign_value
is_expr:
        "=" endofline* assign_value
augassign:
        "+="
        "-="
        "*="
        "/="
        "%="
        "&="
        "|="
        "^="
        "<<="
        ">>="
        "**="
        "//="
assign_value:
        yield_expr
        testlist
print_stmt:
        "print" ">>"? {test ","}* ","?
del_stmt:
        "del" exprlist
pass_stmt:
        "pass"
flow_stmt:
        break_stmt
        continue_stmt
        return_stmt
        raise_stmt
        yield_stmt
break_stmt:
        "break"
continue_stmt:
        "continue"
return_stmt:
        "return" testlist?
yield_stmt:
        yield_expr
raise_stmt:
        "raise" test_list?
test_list:
        test comma_test? comma_test?
comma_test:
        endofline? "," test
import_stmt:
        import_name
        import_from
import_name:
        "import" dotted_as_names
import_from:
        "from" "."* dotted_name? endofline* "import" import_items
import_items:
        "*"
        endofline* SPOFF "(" SPON import_as_names endofline* ")"
        endofline* import_as_names
import_as_name:
        endofline* id as_name?
as_name:
        "as" id
dotted_as_name:
        dotted_name as_id?
as_id:
        "as" id
import_as_names:
        import_as_name+ ","?
dotted_as_names:
        dotted_as_name+
dotted_name:
        id dot_dotted_name?
dot_dotted_name:
        endofline* "." endofline* dotted_name
global_stmt:
        "global" id+
exec_stmt:
        "exec" expr in_test? comma_test?
in_test:
        "in" test
assert_stmt:
        "assert" test comma_test?
compound_stmt:
        if_stmt
        while_stmt
        for_stmt
        try_stmt
        with_stmt
        funcdef
        classdef
        decorated
if_stmt:
        "if" test ":" suite elif_clause* else_clause?
elif_clause:
        "elif" test ":" suite
else_clause:
        "else" ":" suite
while_stmt:
        "while" test ":" suite else_clause?
for_stmt:
        "for" exprlist "in" testlist ":" suite else_clause?
try_stmt:
        "try" ":" suite except_clause_suite* else_clause? finally_clause?
finally_clause:
        "finally" ":" suite
except_clause_suite:
        except_clause ":" suite
with_stmt:
        "with" test with_var? ":" suite
with_var:
        "as" expr
except_clause:
        "except" except_test?
except_test:
        test as_or_comma_test?
as_or_comma_test:
        "as" test
        "," test
suite:
        indent endofline stmt_or_newline+ dedent
        simple_stmt endofline
endofline:
        comment? newline
indent:
        "INDENT" IN
dedent:
        "DEDENT" EX
testplist_safe:
        old_test+ ","?
old_test:
        or_test
        old_lambdef
old_lambdef:
        "lambda" varargslist? ":" old_test
test:
        endofline* or_test if_test? endofline?
        endofline* lambdef endofline?
if_test:
        endofline* "if" or_test "else" test
or_test:
        and_test orop_or_test?
orop_or_test:
        endofline* "or" endofline* or_test
and_test:
        not_test andop_and_test?
andop_and_test:
        endofline* "and" endofline* and_test
not_test:
        "not"* endofline* comparison
comparison:
        expr comp_op_comparison?
comp_op_comparison:
        endofline* comp_op endofline* comparison
comp_op:
        "<"
        ">"
        "=="
        ">="
        "<="
        "<>"
        "!="
        "in"
        "not" "in"
        "is"
        "is" "not"
expr:
        xor_expr orop_expr?
orop_expr:
        endofline* "|" endofline* expr
xor_expr:
        and_expr xorop_expr?
xorop_expr:
        endofline* "^" endofline* xor_expr
and_expr:
        shift_expr andop_and_expr?
andop_and_expr:
        endofline* "&" endofline* and_expr
shift_expr:
        arith_expr shiftop_shift_expr*
shiftop_shift_expr:
        endofline? shift_op endofline? shift_expr
shift_op:
        "<<"
        ">>"
arith_expr:
        term op_arith_expr*
op_arith_expr:
        endofline* arith_op endofline* arith_expr
arith_op:
        "+"
        "-"
term:
        factor op_term*
op_term:
        endofline* term_op endofline* term
term_op:
        "*"
        "/"
        "%"
        "//"
factor:
        unary_op* power
unary_op:
        "+"
        "-"
        "~"
power:
        atom trailer* exp_factor?
exp_factor:
        "**" factor
atom:
        id
        literal
        "(" IN endofline* yield_expr? endofline* ")" EX
        "(" IN endofline* testplist_gexp endofline* ")" EX
        "[" IN endofline* listmaker? "]" EX
        "{" IN endofline* dictmaker? endofline* "}" EX
        "`" testlist1 "`"
listmaker:
        endofline* test endofline* plist_for endofline*
        endofline* {test ","}* ","? endofline*
testplist_gexp:
        test+ endofline? ","?
        test endofline? gen_for
lambdef:
        "lambda" varargslist? ":" test
trailer:
        SPOFF "(" SPON IN arglist endofline* ")" EX
        "[" IN subscriptlist "]" EX
        endofline* "." endofline* id
subscriptlist:
        subscript+ "," endofline*
subscript:
        endofline* "." "." "." endofline?
        endofline* test endofline?
        endofline* test? ":" test? sliceop? endofline?
sliceop:
        ":" test?
exprlist:
        expr+ endofline* ","?
testlist:
        test+ endofline* ","?
dictmaker:
        {dict_entry ","}* endofline* ","? endofline*
dict_entry:
        endofline* test ":" endofline* test
classdef:
        "class" id? ":" suite
        "class" id? SPOFF "(" SPON testlist? endofline* ")" ":" suite
arglist:
        star_test? {argument ","}* comma_opt_star_test?
star_test:
        endofline* "*" test
        endofline* "**" test
comma_opt_star_test:
        "," star_test? comma_opt_star_test?
argument:
        endofline* test argument_value? endofline*
argument_value:
        endofline* gen_for?
        "=" endofline* test
plist_iter:
        endofline* plist_for
        endofline* plist_if
plist_for:
        "for" endofline* exprlist "in" testplist_safe plist_iter?
plist_if:
        "if" old_test plist_iter?
gen_iter:
        endofline* gen_for
        endofline* gen_if
gen_for:
        "for" exprlist "in" or_test gen_iter?
gen_if:
        "if" old_test gen_iter?
testlist1:
        {test ","}*
encoding_decl:
        id
yield_expr:
        "yield" testlist
literal:
        stringliteral more_stringliteral*
        integerliteral
        floatliteral
more_stringliteral:
        endofline* stringliteral
stringliteral:
        stringprefix SPOFF string SPON
        string
stringprefix:
        "r"
        "u"
        "ur"
        "R"
        "U"
        "UR"
        "Ur"
        "uR"
        "b"
string:
        stringlit
        charlit
        longstringlit
        longcharlit
integerliteral:
        integer long? imag?
integer:
        integernumber
        hexinteger
        octinteger
long:
        SPOFF "l" SPON
        SPOFF "L" SPON
floatliteral:
        number imag?
        pointfloat imag?
imag:
        SPOFF "j" SPON
        SPOFF "J" SPON
