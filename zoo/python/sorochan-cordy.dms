program = file_input ;
file_input = stmt_or_newline* ;
stmt_or_newline = stmt ;
stmt_or_newline = endofline ;
decorator = '@' dotted_name decorator_arglist? endofline endofline* ;
decorator_arglist = SPOFF '(' SPON IN arglist? endofline* ')' EX ;
decorators = decorator+ ;
decorated = decorators classdef ;
decorated = decorators funcdef ;
funcdef = 'def' id parameters ':' suite ;
parameters = SPOFF '(' SPON varargslist? endofline* ')' ;
varargslist = fpdef_test_comma* endofline* '*' id ;
varargslist = fpdef_test_comma* endofline* '*' id endofline? ',' endofline* '**' id ;
varargslist = fpdef_test_comma* endofline* '**' id ;
varargslist = fpdef_test+ ','? ;
fpdef_test = endofline* fpdef is_test? endofline? ;
fpdef_test_comma = fpdef_test ',' ;
is_test = '=' endofline* test ;
fpdef = id endofline? ;
fpdef = SPOFF '(' SPON fplist endofline* ')' endofline? ;
fplist = fpdef+ ','? ;
stmt = simple_stmt endofline ;
stmt = compound_stmt ;
simple_stmt = small_stmt semicolon_small_stmt* ';'? ;
simple_stmt = comment ;
semicolon_small_stmt = ';' small_stmt ;
small_stmt = expr_stmt ;
small_stmt = print_stmt ;
small_stmt = del_stmt ;
small_stmt = pass_stmt ;
small_stmt = flow_stmt ;
small_stmt = import_stmt ;
small_stmt = global_stmt ;
small_stmt = exec_stmt ;
small_stmt = assert_stmt ;
expr_stmt = testlist is_expr* ;
expr_stmt = testlist augassign assign_value ;
is_expr = '=' endofline* assign_value ;
augassign = '+=' ;
augassign = '-=' ;
augassign = '*=' ;
augassign = '/=' ;
augassign = '%=' ;
augassign = '&=' ;
augassign = '|=' ;
augassign = '^=' ;
augassign = '<<=' ;
augassign = '>>=' ;
augassign = '**=' ;
augassign = '//=' ;
assign_value = yield_expr ;
assign_value = testlist ;
print_stmt = 'print' '>>'? test',' ','? ;
del_stmt = 'del' exprlist ;
pass_stmt = 'pass' ;
flow_stmt = break_stmt ;
flow_stmt = continue_stmt ;
flow_stmt = return_stmt ;
flow_stmt = raise_stmt ;
flow_stmt = yield_stmt ;
break_stmt = 'break' ;
continue_stmt = 'continue' ;
return_stmt = 'return' testlist? ;
yield_stmt = yield_expr ;
raise_stmt = 'raise' test_list? ;
test_list = test comma_test? comma_test? ;
comma_test = endofline? ',' test ;
import_stmt = import_name ;
import_stmt = import_from ;
import_name = 'import' dotted_as_names ;
import_from = 'from' '.'* dotted_name? endofline* 'import' import_items ;
import_items = '*' ;
import_items = endofline* SPOFF '(' SPON import_as_names endofline* ')' ;
import_items = endofline* import_as_names ;
import_as_name = endofline* id as_name? ;
as_name = 'as' id ;
dotted_as_name = dotted_name as_id? ;
as_id = 'as' id ;
import_as_names = import_as_name+ ','? ;
dotted_as_names = dotted_as_name+ ;
dotted_name = id dot_dotted_name? ;
dot_dotted_name = endofline* '.' endofline* dotted_name ;
global_stmt = 'global' id+ ;
exec_stmt = 'exec' expr in_test? comma_test? ;
in_test = 'in' test ;
assert_stmt = 'assert' test comma_test? ;
compound_stmt = if_stmt ;
compound_stmt = while_stmt ;
compound_stmt = for_stmt ;
compound_stmt = try_stmt ;
compound_stmt = with_stmt ;
compound_stmt = funcdef ;
compound_stmt = classdef ;
compound_stmt = decorated ;
if_stmt = 'if' test ':' suite elif_clause* else_clause? ;
elif_clause = 'elif' test ':' suite ;
else_clause = 'else' ':' suite ;
while_stmt = 'while' test ':' suite else_clause? ;
for_stmt = 'for' exprlist 'in' testlist ':' suite else_clause? ;
try_stmt = 'try' ':' suite except_clause_suite* else_clause? finally_clause? ;
finally_clause = 'finally' ':' suite ;
except_clause_suite = except_clause ':' suite ;
with_stmt = 'with' test with_var? ':' suite ;
with_var = 'as' expr ;
except_clause = 'except' except_test? ;
except_test = test as_or_comma_test? ;
as_or_comma_test = 'as' test ;
as_or_comma_test = ',' test ;
suite = indent endofline stmt_or_newline+ dedent ;
suite = simple_stmt endofline ;
endofline = comment? newline ;
indent = 'INDENT' IN ;
dedent = 'DEDENT' EX ;
testplist_safe = old_test+ ','? ;
old_test = or_test ;
old_test = old_lambdef ;
old_lambdef = 'lambda' varargslist? ':' old_test ;
test = endofline* or_test if_test? endofline? ;
test = endofline* lambdef endofline? ;
if_test = endofline* 'if' or_test 'else' test ;
or_test = and_test orop_or_test? ;
orop_or_test = endofline* 'or' endofline* or_test ;
and_test = not_test andop_and_test? ;
andop_and_test = endofline* 'and' endofline* and_test ;
not_test = 'not'* endofline* comparison ;
comparison = expr comp_op_comparison? ;
comp_op_comparison = endofline* comp_op endofline* comparison ;
comp_op = '<' ;
comp_op = '>' ;
comp_op = '==' ;
comp_op = '>=' ;
comp_op = '<=' ;
comp_op = '<>' ;
comp_op = '!=' ;
comp_op = 'in' ;
comp_op = 'not' 'in' ;
comp_op = 'is' ;
comp_op = 'is' 'not' ;
expr = xor_expr orop_expr? ;
orop_expr = endofline* '|' endofline* expr ;
xor_expr = and_expr xorop_expr? ;
xorop_expr = endofline* '^' endofline* xor_expr ;
and_expr = shift_expr andop_and_expr? ;
andop_and_expr = endofline* '&' endofline* and_expr ;
shift_expr = arith_expr shiftop_shift_expr* ;
shiftop_shift_expr = endofline? shift_op endofline? shift_expr ;
shift_op = '<<' ;
shift_op = '>>' ;
arith_expr = term op_arith_expr* ;
op_arith_expr = endofline* arith_op endofline* arith_expr ;
arith_op = '+' ;
arith_op = '-' ;
term = factor op_term* ;
op_term = endofline* term_op endofline* term ;
term_op = '*' ;
term_op = '/' ;
term_op = '%' ;
term_op = '//' ;
factor = unary_op* power ;
unary_op = '+' ;
unary_op = '-' ;
unary_op = '~' ;
power = atom trailer* exp_factor? ;
exp_factor = '**' factor ;
atom = id ;
atom = literal ;
atom = '(' IN endofline* yield_expr? endofline* ')' EX ;
atom = '(' IN endofline* testplist_gexp endofline* ')' EX ;
atom = '[' IN endofline* listmaker? ']' EX ;
atom = '{' IN endofline* dictmaker? endofline* '}' EX ;
atom = '`' testlist1 '`' ;
listmaker = endofline* test endofline* plist_for endofline* ;
listmaker = endofline* test',' ','? endofline* ;
testplist_gexp = test+ endofline? ','? ;
testplist_gexp = test endofline? gen_for ;
lambdef = 'lambda' varargslist? ':' test ;
trailer = SPOFF '(' SPON IN arglist endofline* ')' EX ;
trailer = '[' IN subscriptlist ']' EX ;
trailer = endofline* '.' endofline* id ;
subscriptlist = subscript+ ',' endofline* ;
subscript = endofline* '.' '.' '.' endofline? ;
subscript = endofline* test endofline? ;
subscript = endofline* test? ':' test? sliceop? endofline? ;
sliceop = ':' test? ;
exprlist = expr+ endofline* ','? ;
testlist = test+ endofline* ','? ;
dictmaker = dict_entry',' endofline* ','? endofline* ;
dict_entry = endofline* test ':' endofline* test ;
classdef = 'class' id? ':' suite ;
classdef = 'class' id? SPOFF '(' SPON testlist? endofline* ')' ':' suite ;
arglist = star_test? argument',' comma_opt_star_test? ;
star_test = endofline* '*' test ;
star_test = endofline* '**' test ;
comma_opt_star_test = ',' star_test? comma_opt_star_test? ;
argument = endofline* test argument_value? endofline* ;
argument_value = endofline* gen_for? ;
argument_value = '=' endofline* test ;
plist_iter = endofline* plist_for ;
plist_iter = endofline* plist_if ;
plist_for = 'for' endofline* exprlist 'in' testplist_safe plist_iter? ;
plist_if = 'if' old_test plist_iter? ;
gen_iter = endofline* gen_for ;
gen_iter = endofline* gen_if ;
gen_for = 'for' exprlist 'in' or_test gen_iter? ;
gen_if = 'if' old_test gen_iter? ;
testlist1 = test',' ;
encoding_decl = id ;
yield_expr = 'yield' testlist ;
literal = stringliteral more_stringliteral* ;
literal = integerliteral ;
literal = floatliteral ;
more_stringliteral = endofline* stringliteral ;
stringliteral = stringprefix SPOFF string SPON ;
stringliteral = string ;
stringprefix = 'r' ;
stringprefix = 'u' ;
stringprefix = 'ur' ;
stringprefix = 'R' ;
stringprefix = 'U' ;
stringprefix = 'UR' ;
stringprefix = 'Ur' ;
stringprefix = 'uR' ;
stringprefix = 'b' ;
string = stringlit ;
string = charlit ;
string = longstringlit ;
string = longcharlit ;
integerliteral = integer long? imag? ;
integer = integernumber ;
integer = hexinteger ;
integer = octinteger ;
long = SPOFF 'l' SPON ;
long = SPOFF 'L' SPON ;
floatliteral = number imag? ;
floatliteral = pointfloat imag? ;
imag = SPOFF 'j' SPON ;
imag = SPOFF 'J' SPON ;
